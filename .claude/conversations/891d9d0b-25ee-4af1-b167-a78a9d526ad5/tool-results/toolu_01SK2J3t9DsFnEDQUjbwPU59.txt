     1→/*
     2→ * builtins.c - TCL Built-in Commands
     3→ *
     4→ * Static table of built-in commands and their implementations.
     5→ */
     6→
     7→#include "internal.h"
     8→
     9→/* ========================================================================
    10→ * puts Command
    11→ * ======================================================================== */
    12→
    13→TclResult tclCmdPuts(TclInterp *interp, int objc, TclObj **objv) {
    14→    const TclHost *host = interp->host;
    15→    int newline = 1;
    16→    int argStart = 1;
    17→    TclChannel *chan = host->chanStdout(interp->hostCtx);
    18→
    19→    /* Check for -nonewline flag */
    20→    if (objc >= 2) {
    21→        size_t len;
    22→        const char *arg = host->getStringPtr(objv[1], &len);
    23→        if (len == 10 && tclStrncmp(arg, "-nonewline", 10) == 0) {
    24→            newline = 0;
    25→            argStart = 2;
    26→        }
    27→    }
    28→
    29→    /* Check argument count */
    30→    int remaining = objc - argStart;
    31→    if (remaining < 1 || remaining > 2) {
    32→        tclSetError(interp, "wrong # args: should be \"puts ?-nonewline? ?channelId? string\"", -1);
    33→        return TCL_ERROR;
    34→    }
    35→
    36→    /* Get channel and string */
    37→    TclObj *strObj;
    38→    if (remaining == 2) {
    39→        size_t chanLen;
    40→        const char *chanName = host->getStringPtr(objv[argStart], &chanLen);
    41→
    42→        if (chanLen == 6 && tclStrncmp(chanName, "stdout", 6) == 0) {
    43→            chan = host->chanStdout(interp->hostCtx);
    44→        } else if (chanLen == 6 && tclStrncmp(chanName, "stderr", 6) == 0) {
    45→            chan = host->chanStderr(interp->hostCtx);
    46→        } else {
    47→            tclSetError(interp, "can not find channel", -1);
    48→            return TCL_ERROR;
    49→        }
    50→        strObj = objv[argStart + 1];
    51→    } else {
    52→        strObj = objv[argStart];
    53→    }
    54→
    55→    /* Write string */
    56→    size_t strLen;
    57→    const char *str = host->getStringPtr(strObj, &strLen);
    58→    host->chanWrite(chan, str, strLen);
    59→    if (newline) {
    60→        host->chanWrite(chan, "\n", 1);
    61→    }
    62→
    63→    tclSetResult(interp, host->newString("", 0));
    64→    return TCL_OK;
    65→}
    66→
    67→/* ========================================================================
    68→ * set Command
    69→ * ======================================================================== */
    70→
    71→TclResult tclCmdSet(TclInterp *interp, int objc, TclObj **objv) {
    72→    const TclHost *host = interp->host;
    73→
    74→    if (objc < 2 || objc > 3) {
    75→        tclSetError(interp, "wrong # args: should be \"set varName ?newValue?\"", -1);
    76→        return TCL_ERROR;
    77→    }
    78→
    79→    size_t nameLen;
    80→    const char *name = host->getStringPtr(objv[1], &nameLen);
    81→    void *vars = interp->currentFrame->varsHandle;
    82→
    83→    if (objc == 3) {
    84→        /* Setting a value */
    85→        TclObj *value = host->dup(objv[2]);
    86→        host->varSet(vars, name, nameLen, value);
    87→        tclSetResult(interp, host->dup(objv[2]));
    88→    } else {
    89→        /* Getting a value */
    90→        TclObj *value = host->varGet(vars, name, nameLen);
    91→
    92→        /* Try global frame if not found */
    93→        if (!value && interp->currentFrame != interp->globalFrame) {
    94→            value = host->varGet(interp->globalFrame->varsHandle, name, nameLen);
    95→        }
    96→
    97→        if (!value) {
    98→            tclSetError(interp, "can't read variable: no such variable", -1);
    99→            return TCL_ERROR;
   100→        }
   101→        tclSetResult(interp, host->dup(value));
   102→    }
   103→
   104→    return TCL_OK;
   105→}
   106→
   107→/* ========================================================================
   108→ * string Command
   109→ * ======================================================================== */
   110→
   111→TclResult tclCmdString(TclInterp *interp, int objc, TclObj **objv) {
   112→    const TclHost *host = interp->host;
   113→
   114→    if (objc < 2) {
   115→        tclSetError(interp, "wrong # args: should be \"string subcommand ?arg ...?\"", -1);
   116→        return TCL_ERROR;
   117→    }
   118→
   119→    size_t subcmdLen;
   120→    const char *subcmd = host->getStringPtr(objv[1], &subcmdLen);
   121→
   122→    if (subcmdLen == 6 && tclStrncmp(subcmd, "length", 6) == 0) {
   123→        if (objc != 3) {
   124→            tclSetError(interp, "wrong # args: should be \"string length string\"", -1);
   125→            return TCL_ERROR;
   126→        }
   127→        size_t len;
   128→        host->getStringPtr(objv[2], &len);
   129→        tclSetResult(interp, host->newInt((int64_t)len));
   130→        return TCL_OK;
   131→    }
   132→
   133→    if (subcmdLen == 7 && tclStrncmp(subcmd, "toupper", 7) == 0) {
   134→        if (objc != 3) {
   135→            tclSetError(interp, "wrong # args: should be \"string toupper string\"", -1);
   136→            return TCL_ERROR;
   137→        }
   138→        size_t len;
   139→        const char *str = host->getStringPtr(objv[2], &len);
   140→
   141→        void *arena = host->arenaPush(interp->hostCtx);
   142→        char *buf = host->arenaAlloc(arena, len + 1, 1);
   143→        for (size_t i = 0; i < len; i++) {
   144→            char c = str[i];
   145→            buf[i] = (c >= 'a' && c <= 'z') ? c - 32 : c;
   146→        }
   147→        buf[len] = '\0';
   148→
   149→        TclObj *result = host->newString(buf, len);
   150→        host->arenaPop(interp->hostCtx, arena);
   151→        tclSetResult(interp, result);
   152→        return TCL_OK;
   153→    }
   154→
   155→    if (subcmdLen == 7 && tclStrncmp(subcmd, "tolower", 7) == 0) {
   156→        if (objc != 3) {
   157→            tclSetError(interp, "wrong # args: should be \"string tolower string\"", -1);
   158→            return TCL_ERROR;
   159→        }
   160→        size_t len;
   161→        const char *str = host->getStringPtr(objv[2], &len);
   162→
   163→        void *arena = host->arenaPush(interp->hostCtx);
   164→        char *buf = host->arenaAlloc(arena, len + 1, 1);
   165→        for (size_t i = 0; i < len; i++) {
   166→            char c = str[i];
   167→            buf[i] = (c >= 'A' && c <= 'Z') ? c + 32 : c;
   168→        }
   169→        buf[len] = '\0';
   170→
   171→        TclObj *result = host->newString(buf, len);
   172→        host->arenaPop(interp->hostCtx, arena);
   173→        tclSetResult(interp, result);
   174→        return TCL_OK;
   175→    }
   176→
   177→    if (subcmdLen == 6 && tclStrncmp(subcmd, "repeat", 6) == 0) {
   178→        if (objc != 4) {
   179→            tclSetError(interp, "wrong # args: should be \"string repeat string count\"", -1);
   180→            return TCL_ERROR;
   181→        }
   182→        size_t strLen;
   183→        const char *str = host->getStringPtr(objv[2], &strLen);
   184→
   185→        int64_t count;
   186→        if (host->asInt(objv[3], &count) != 0 || count < 0) {
   187→            tclSetError(interp, "expected integer but got invalid value", -1);
   188→            return TCL_ERROR;
   189→        }
   190→
   191→        size_t resultLen = strLen * (size_t)count;
   192→        void *arena = host->arenaPush(interp->hostCtx);
   193→        char *buf = host->arenaAlloc(arena, resultLen + 1, 1);
   194→
   195→        char *p = buf;
   196→        for (int64_t i = 0; i < count; i++) {
   197→            for (size_t j = 0; j < strLen; j++) {
   198→                *p++ = str[j];
   199→            }
   200→        }
   201→        *p = '\0';
   202→
   203→        TclObj *result = host->newString(buf, resultLen);
   204→        host->arenaPop(interp->hostCtx, arena);
   205→        tclSetResult(interp, result);
   206→        return TCL_OK;
   207→    }
   208→
   209→    tclSetError(interp, "unknown or ambiguous subcommand", -1);
   210→    return TCL_ERROR;
   211→}
   212→
   213→/* ========================================================================
   214→ * expr Command (Simple Arithmetic)
   215→ * ======================================================================== */
   216→
   217→TclResult tclCmdExpr(TclInterp *interp, int objc, TclObj **objv) {
   218→    const TclHost *host = interp->host;
   219→
   220→    if (objc < 2) {
   221→        tclSetError(interp, "wrong # args: should be \"expr arg ?arg ...?\"", -1);
   222→        return TCL_ERROR;
   223→    }
   224→
   225→    /* Concatenate all args with spaces */
   226→    void *arena = host->arenaPush(interp->hostCtx);
   227→    size_t totalLen = 0;
   228→    for (int i = 1; i < objc; i++) {
   229→        size_t len;
   230→        host->getStringPtr(objv[i], &len);
   231→        totalLen += len + 1;
   232→    }
   233→
   234→    char *expr = host->arenaAlloc(arena, totalLen + 1, 1);
   235→    char *p = expr;
   236→    for (int i = 1; i < objc; i++) {
   237→        size_t len;
   238→        const char *s = host->getStringPtr(objv[i], &len);
   239→        if (i > 1) *p++ = ' ';
   240→        for (size_t j = 0; j < len; j++) {
   241→            *p++ = s[j];
   242→        }
   243→    }
   244→    *p = '\0';
   245→
   246→    /* Simple expression parser: integers with + - * / */
   247→    const char *ep = expr;
   248→    while (*ep == ' ') ep++;
   249→
   250→    int64_t result = 0;
   251→    int haveResult = 0;
   252→    char op = '+';
   253→
   254→    while (*ep) {
   255→        while (*ep == ' ') ep++;
   256→        if (!*ep) break;
   257→
   258→        /* Parse number */
   259→        int neg = 0;
   260→        if (*ep == '-' && !haveResult) {
   261→            neg = 1;
   262→            ep++;
   263→        } else if (*ep == '+' && !haveResult) {
   264→            ep++;
   265→        }
   266→
   267→        int64_t num = 0;
   268→        while (*ep >= '0' && *ep <= '9') {
   269→            num = num * 10 + (*ep - '0');
   270→            ep++;
   271→        }
   272→        if (neg) num = -num;
   273→
   274→        if (!haveResult) {
   275→            result = num;
   276→            haveResult = 1;
   277→        } else {
   278→            switch (op) {
   279→                case '+': result += num; break;
   280→                case '-': result -= num; break;
   281→                case '*': result *= num; break;
   282→                case '/': if (num != 0) result /= num; break;
   283→            }
   284→        }
   285→
   286→        while (*ep == ' ') ep++;
   287→        if (*ep == '+' || *ep == '-' || *ep == '*' || *ep == '/') {
   288→            op = *ep++;
   289→        }
   290→    }
   291→
   292→    host->arenaPop(interp->hostCtx, arena);
   293→    tclSetResult(interp, host->newInt(result));
   294→    return TCL_OK;
   295→}
   296→
   297→/* ========================================================================
   298→ * subst Command
   299→ * ======================================================================== */
   300→
   301→TclResult tclCmdSubst(TclInterp *interp, int objc, TclObj **objv) {
   302→    const TclHost *host = interp->host;
   303→
   304→    if (objc < 2) {
   305→        tclSetError(interp, "wrong # args: should be \"subst ?-nobackslashes? ?-nocommands? ?-novariables? string\"", -1);
   306→        return TCL_ERROR;
   307→    }
   308→
   309→    int flags = TCL_SUBST_ALL;
   310→    int stringIdx = 1;
   311→
   312→    /* Parse flags */
   313→    for (int i = 1; i < objc - 1; i++) {
   314→        size_t len;
   315→        const char *arg = host->getStringPtr(objv[i], &len);
   316→
   317→        if (len == 14 && tclStrncmp(arg, "-nobackslashes", 14) == 0) {
   318→            flags &= ~TCL_SUBST_BACKSLASH;
   319→            stringIdx = i + 1;
   320→        } else if (len == 11 && tclStrncmp(arg, "-nocommands", 11) == 0) {
   321→            flags &= ~TCL_SUBST_COMMANDS;
   322→            stringIdx = i + 1;
   323→        } else if (len == 12 && tclStrncmp(arg, "-novariables", 12) == 0) {
   324→            flags &= ~TCL_SUBST_VARIABLES;
   325→            stringIdx = i + 1;
   326→        }
   327→    }
   328→
   329→    /* Get the string */
   330→    size_t strLen;
   331→    const char *str = host->getStringPtr(objv[stringIdx], &strLen);
   332→
   333→    /* Perform substitution */
   334→    TclObj *result = tclSubstString(interp, str, strLen, flags);
   335→    if (!result) {
   336→        return TCL_ERROR;
   337→    }
   338→
   339→    tclSetResult(interp, result);
   340→    return TCL_OK;
   341→}
   342→
   343→/* ========================================================================
   344→ * proc Command
   345→ * ======================================================================== */
   346→
   347→TclResult tclCmdProc(TclInterp *interp, int objc, TclObj **objv) {
   348→    const TclHost *host = interp->host;
   349→
   350→    if (objc != 4) {
   351→        tclSetError(interp, "wrong # args: should be \"proc name args body\"", -1);
   352→        return TCL_ERROR;
   353→    }
   354→
   355→    size_t nameLen;
   356→    const char *name = host->getStringPtr(objv[1], &nameLen);
   357→
   358→    /* Register the procedure with the host */
   359→    void *handle = host->procRegister(interp->hostCtx, name, nameLen, objv[2], objv[3]);
   360→    if (!handle) {
   361→        tclSetError(interp, "failed to register procedure", -1);
   362→        return TCL_ERROR;
   363→    }
   364→
   365→    tclSetResult(interp, host->newString("", 0));
   366→    return TCL_OK;
   367→}
   368→
   369→/* ========================================================================
   370→ * return Command
   371→ * ======================================================================== */
   372→
   373→TclResult tclCmdReturn(TclInterp *interp, int objc, TclObj **objv) {
   374→    const TclHost *host = interp->host;
   375→
   376→    /* Default return value is empty string */
   377→    TclObj *result = host->newString("", 0);
   378→    int code = TCL_OK;
   379→    int level = 1;
   380→
   381→    /* Parse options: return ?-code code? ?-level level? ?result? */
   382→    int i = 1;
   383→    while (i < objc) {
   384→        size_t len;
   385→        const char *arg = host->getStringPtr(objv[i], &len);
   386→
   387→        if (len >= 1 && arg[0] == '-') {
   388→            if (len == 5 && tclStrncmp(arg, "-code", 5) == 0) {
   389→                if (i + 1 >= objc) {
   390→                    tclSetError(interp, "wrong # args: should be \"-code code\"", -1);
   391→                    return TCL_ERROR;
   392→                }
   393→                i++;
   394→                size_t codeLen;
   395→                const char *codeStr = host->getStringPtr(objv[i], &codeLen);
   396→
   397→                /* Parse code value */
   398→                if (codeLen == 2 && tclStrncmp(codeStr, "ok", 2) == 0) {
   399→                    code = TCL_OK;
   400→                } else if (codeLen == 5 && tclStrncmp(codeStr, "error", 5) == 0) {
   401→                    code = TCL_ERROR;
   402→                } else if (codeLen == 6 && tclStrncmp(codeStr, "return", 6) == 0) {
   403→                    code = TCL_RETURN;
   404→                } else if (codeLen == 5 && tclStrncmp(codeStr, "break", 5) == 0) {
   405→                    code = TCL_BREAK;
   406→                } else if (codeLen == 8 && tclStrncmp(codeStr, "continue", 8) == 0) {
   407→                    code = TCL_CONTINUE;
   408→                } else {
   409→                    /* Try as integer */
   410→                    int64_t val;
   411→                    if (host->asInt(objv[i], &val) == 0) {
   412→                        code = (int)val;
   413→                    } else {
   414→                        tclSetError(interp, "bad completion code", -1);
   415→                        return TCL_ERROR;
   416→                    }
   417→                }
   418→                i++;
   419→            } else if (len == 6 && tclStrncmp(arg, "-level", 6) == 0) {
   420→                if (i + 1 >= objc) {
   421→                    tclSetError(interp, "wrong # args: should be \"-level level\"", -1);
   422→                    return TCL_ERROR;
   423→                }
   424→                i++;
   425→                int64_t val;
   426→                if (host->asInt(objv[i], &val) != 0 || val < 0) {
   427→                    tclSetError(interp, "bad level", -1);
   428→                    return TCL_ERROR;
   429→                }
   430→                level = (int)val;
   431→                i++;
   432→            } else {
   433→                /* Unknown option - treat as result value */
   434→                result = objv[i];
   435→                i++;
   436→            }
   437→        } else {
   438→            /* Result value */
   439→            result = objv[i];
   440→            i++;
   441→        }
   442→    }
   443→
   444→    /* Set interpreter state for return */
   445→    interp->result = result;
   446→    interp->returnCode = code;
   447→    interp->returnLevel = level;
   448→
   449→    return TCL_RETURN;
   450→}
   451→
   452→/* ========================================================================
   453→ * Expression Boolean Evaluation Helper
   454→ * ======================================================================== */
   455→
   456→/* Evaluate expression string and return boolean result */
   457→static int evalExprBool(TclInterp *interp, const char *exprRaw, size_t lenRaw, int *result) {
   458→    const TclHost *host = interp->host;
   459→
   460→    /* First, perform variable/command substitution on the expression */
   461→    TclObj *substResult = tclSubstString(interp, exprRaw, lenRaw, TCL_SUBST_ALL);
   462→    if (!substResult) {
   463→        return -1;
   464→    }
   465→
   466→    size_t len;
   467→    const char *expr = host->getStringPtr(substResult, &len);
   468→
   469→    /* Simple expression evaluator - handles:
   470→     * - Integer literals (0 = false, non-zero = true)
   471→     * - Comparisons: ==, !=, <, >, <=, >=
   472→     * - Boolean literals: true, false, yes, no, on, off
   473→     */
   474→    const char *p = expr;
   475→    const char *end = expr + len;
   476→
   477→    /* Skip whitespace */
   478→    while (p < end && (*p == ' ' || *p == '\t')) p++;
   479→    if (p >= end) {
   480→        *result = 0;
   481→        return 0;
   482→    }
   483→
   484→    /* Check for boolean literals */
   485→    size_t remaining = end - p;
   486→    if (remaining == 4 && tclStrncmp(p, "true", 4) == 0) { *result = 1; return 0; }
   487→    if (remaining == 5 && tclStrncmp(p, "false", 5) == 0) { *result = 0; return 0; }
   488→    if (remaining == 3 && tclStrncmp(p, "yes", 3) == 0) { *result = 1; return 0; }
   489→    if (remaining == 2 && tclStrncmp(p, "no", 2) == 0) { *result = 0; return 0; }
   490→    if (remaining == 2 && tclStrncmp(p, "on", 2) == 0) { *result = 1; return 0; }
   491→    if (remaining == 3 && tclStrncmp(p, "off", 3) == 0) { *result = 0; return 0; }
   492→
   493→    /* Try to parse as simple comparison or arithmetic */
   494→    /* First, look for comparison operators */
   495→    const char *op = NULL;
   496→    int opLen = 0;
   497→    const char *scan = p;
   498→    while (scan < end) {
   499→        if (scan + 1 < end) {
   500→            if ((scan[0] == '=' && scan[1] == '=') ||
   501→                (scan[0] == '!' && scan[1] == '=') ||
   502→                (scan[0] == '<' && scan[1] == '=') ||
   503→                (scan[0] == '>' && scan[1] == '=')) {
   504→                op = scan;
   505→                opLen = 2;
   506→                break;
   507→            }
   508→        }
   509→        if (*scan == '<' || *scan == '>') {
   510→            op = scan;
   511→            opLen = 1;
   512→            break;
   513→        }
   514→        scan++;
   515→    }
   516→
   517→    if (op) {
   518→        /* Comparison expression */
   519→        /* Parse left operand */
   520→        const char *leftStart = p;
   521→        while (leftStart < op && (*leftStart == ' ' || *leftStart == '\t')) leftStart++;
   522→        const char *leftEnd = op;
   523→        while (leftEnd > leftStart && (leftEnd[-1] == ' ' || leftEnd[-1] == '\t')) leftEnd--;
   524→
   525→        /* Strip quotes from left operand */
   526→        if (leftEnd > leftStart && *leftStart == '"' && leftEnd[-1] == '"') {
   527→            leftStart++;
   528→            leftEnd--;
   529→        }
   530→
   531→        /* Parse right operand */
   532→        const char *rightStart = op + opLen;
   533→        while (rightStart < end && (*rightStart == ' ' || *rightStart == '\t')) rightStart++;
   534→        const char *rightEnd = end;
   535→        while (rightEnd > rightStart && (rightEnd[-1] == ' ' || rightEnd[-1] == '\t')) rightEnd--;
   536→
   537→        /* Strip quotes from right operand */
   538→        if (rightEnd > rightStart && *rightStart == '"' && rightEnd[-1] == '"') {
   539→            rightStart++;
   540→            rightEnd--;
   541→        }
   542→
   543→        /* Try as integers first */
   544→        int64_t leftVal = 0, rightVal = 0;
   545→        int leftIsInt = 1, rightIsInt = 1;
   546→
   547→        /* Parse left as int */
   548→        const char *lp = leftStart;
   549→        int lneg = 0;
   550→        if (lp < leftEnd && *lp == '-') { lneg = 1; lp++; }
   551→        else if (lp < leftEnd && *lp == '+') { lp++; }
   552→        if (lp < leftEnd && *lp >= '0' && *lp <= '9') {
   553→            while (lp < leftEnd && *lp >= '0' && *lp <= '9') {
   554→                leftVal = leftVal * 10 + (*lp - '0');
   555→                lp++;
   556→            }
   557→            if (lneg) leftVal = -leftVal;
   558→            /* Check for trailing non-digits */
   559→            while (lp < leftEnd && (*lp == ' ' || *lp == '\t')) lp++;
   560→            if (lp != leftEnd) leftIsInt = 0;
   561→        } else {
   562→            leftIsInt = 0;
   563→        }
   564→
   565→        /* Parse right as int */
   566→        const char *rp = rightStart;
   567→        int rneg = 0;
   568→        if (rp < rightEnd && *rp == '-') { rneg = 1; rp++; }
   569→        else if (rp < rightEnd && *rp == '+') { rp++; }
   570→        if (rp < rightEnd && *rp >= '0' && *rp <= '9') {
   571→            while (rp < rightEnd && *rp >= '0' && *rp <= '9') {
   572→                rightVal = rightVal * 10 + (*rp - '0');
   573→                rp++;
   574→            }
   575→            if (rneg) rightVal = -rightVal;
   576→            while (rp < rightEnd && (*rp == ' ' || *rp == '\t')) rp++;
   577→            if (rp != rightEnd) rightIsInt = 0;
   578→        } else {
   579→            rightIsInt = 0;
   580→        }
   581→
   582→        if (leftIsInt && rightIsInt) {
   583→            /* Integer comparison */
   584→            if (opLen == 2 && op[0] == '=' && op[1] == '=') {
   585→                *result = (leftVal == rightVal);
   586→            } else if (opLen == 2 && op[0] == '!' && op[1] == '=') {
   587→                *result = (leftVal != rightVal);
   588→            } else if (opLen == 2 && op[0] == '<' && op[1] == '=') {
   589→                *result = (leftVal <= rightVal);
   590→            } else if (opLen == 2 && op[0] == '>' && op[1] == '=') {
   591→                *result = (leftVal >= rightVal);
   592→            } else if (opLen == 1 && op[0] == '<') {
   593→                *result = (leftVal < rightVal);
   594→            } else if (opLen == 1 && op[0] == '>') {
   595→                *result = (leftVal > rightVal);
   596→            }
   597→            return 0;
   598→        } else {
   599→            /* String comparison */
   600→            size_t leftLen = leftEnd - leftStart;
   601→            size_t rightLen = rightEnd - rightStart;
   602→            int cmp = 0;
   603→            size_t minLen = leftLen < rightLen ? leftLen : rightLen;
   604→            cmp = tclStrncmp(leftStart, rightStart, minLen);
   605→            if (cmp == 0) {
   606→                if (leftLen < rightLen) cmp = -1;
   607→                else if (leftLen > rightLen) cmp = 1;
   608→            }
   609→
   610→            if (opLen == 2 && op[0] == '=' && op[1] == '=') {
   611→                *result = (cmp == 0);
   612→            } else if (opLen == 2 && op[0] == '!' && op[1] == '=') {
   613→                *result = (cmp != 0);
   614→            } else if (opLen == 2 && op[0] == '<' && op[1] == '=') {
   615→                *result = (cmp <= 0);
   616→            } else if (opLen == 2 && op[0] == '>' && op[1] == '=') {
   617→                *result = (cmp >= 0);
   618→            } else if (opLen == 1 && op[0] == '<') {
   619→                *result = (cmp < 0);
   620→            } else if (opLen == 1 && op[0] == '>') {
   621→                *result = (cmp > 0);
   622→            }
   623→            return 0;
   624→        }
   625→    }
   626→
   627→    /* Try as simple integer (non-zero = true) */
   628→    int64_t val = 0;
   629→    int neg = 0;
   630→    if (p < end && *p == '-') { neg = 1; p++; }
   631→    else if (p < end && *p == '+') { p++; }
   632→
   633→    if (p < end && *p >= '0' && *p <= '9') {
   634→        while (p < end && *p >= '0' && *p <= '9') {
   635→            val = val * 10 + (*p - '0');
   636→            p++;
   637→        }
   638→        if (neg) val = -val;
   639→        *result = (val != 0);
   640→        return 0;
   641→    }
   642→
   643→    /* Use expr command and interpret result */
   644→    TclObj *exprObj = host->newString(expr, len);
   645→    TclObj *args[2] = { host->newString("expr", 4), exprObj };
   646→    TclResult res = tclCmdExpr(interp, 2, args);
   647→    if (res != TCL_OK) {
   648→        return -1;
   649→    }
   650→
   651→    /* Check result */
   652→    int64_t intResult;
   653→    if (host->asInt(interp->result, &intResult) == 0) {
   654→        *result = (intResult != 0);
   655→        return 0;
   656→    }
   657→
   658→    /* Try as boolean */
   659→    int boolResult;
   660→    if (host->asBool(interp->result, &boolResult) == 0) {
   661→        *result = boolResult;
   662→        return 0;
   663→    }
   664→
   665→    tclSetError(interp, "expected boolean expression", -1);
   666→    return -1;
   667→}
   668→
   669→/* ========================================================================
   670→ * if Command
   671→ * ======================================================================== */
   672→
   673→TclResult tclCmdIf(TclInterp *interp, int objc, TclObj **objv) {
   674→    const TclHost *host = interp->host;
   675→
   676→    if (objc < 3) {
   677→        tclSetError(interp, "wrong # args: should be \"if expr1 ?then? body1 elseif expr2 ?then? body2 ... ?else? ?bodyN?\"", -1);
   678→        return TCL_ERROR;
   679→    }
   680→
   681→    int i = 1;
   682→    while (i < objc) {
   683→        /* Get condition expression */
   684→        size_t exprLen;
   685→        const char *exprStr = host->getStringPtr(objv[i], &exprLen);
   686→        i++;
   687→
   688→        /* Evaluate condition */
   689→        int condResult;
   690→        if (evalExprBool(interp, exprStr, exprLen, &condResult) != 0) {
   691→            return TCL_ERROR;
   692→        }
   693→
   694→        /* Skip optional "then" */
   695→        if (i < objc) {
   696→            size_t kwLen;
   697→            const char *kw = host->getStringPtr(objv[i], &kwLen);
   698→            if (kwLen == 4 && tclStrncmp(kw, "then", 4) == 0) {
   699→                i++;
   700→            }
   701→        }
   702→
   703→        if (i >= objc) {
   704→            tclSetError(interp, "wrong # args: no body after condition", -1);
   705→            return TCL_ERROR;
   706→        }
   707→
   708→        if (condResult) {
   709→            /* Execute this branch */
   710→            size_t bodyLen;
   711→            const char *bodyStr = host->getStringPtr(objv[i], &bodyLen);
   712→            return tclEvalScript(interp, bodyStr, bodyLen);
   713→        }
   714→
   715→        i++;  /* Skip body */
   716→
   717→        /* Check for elseif or else */
   718→        if (i >= objc) {
   719→            /* No more branches, return empty */
   720→            tclSetResult(interp, host->newString("", 0));
   721→            return TCL_OK;
   722→        }
   723→
   724→        size_t kwLen;
   725→        const char *kw = host->getStringPtr(objv[i], &kwLen);
   726→
   727→        if (kwLen == 6 && tclStrncmp(kw, "elseif", 6) == 0) {
   728→            i++;
   729→            continue;  /* Process next condition */
   730→        }
   731→
   732→        if (kwLen == 4 && tclStrncmp(kw, "else", 4) == 0) {
   733→            i++;
   734→            if (i >= objc) {
   735→                tclSetError(interp, "wrong # args: no body after else", -1);
   736→                return TCL_ERROR;
   737→            }
   738→            /* Execute else branch */
   739→            size_t bodyLen;
   740→            const char *bodyStr = host->getStringPtr(objv[i], &bodyLen);
   741→            return tclEvalScript(interp, bodyStr, bodyLen);
   742→        }
   743→
   744→        /* Must be else body without "else" keyword */
   745→        size_t bodyLen;
   746→        const char *bodyStr = host->getStringPtr(objv[i], &bodyLen);
   747→        return tclEvalScript(interp, bodyStr, bodyLen);
   748→    }
   749→
   750→    tclSetResult(interp, host->newString("", 0));
   751→    return TCL_OK;
   752→}
   753→
   754→/* ========================================================================
   755→ * while Command
   756→ * ======================================================================== */
   757→
   758→TclResult tclCmdWhile(TclInterp *interp, int objc, TclObj **objv) {
   759→    const TclHost *host = interp->host;
   760→
   761→    if (objc != 3) {
   762→        tclSetError(interp, "wrong # args: should be \"while test command\"", -1);
   763→        return TCL_ERROR;
   764→    }
   765→
   766→    size_t testLen, bodyLen;
   767→    const char *testStr = host->getStringPtr(objv[1], &testLen);
   768→    const char *bodyStr = host->getStringPtr(objv[2], &bodyLen);
   769→
   770→    tclSetResult(interp, host->newString("", 0));
   771→
   772→    while (1) {
   773→        /* Evaluate condition */
   774→        int condResult;
   775→        if (evalExprBool(interp, testStr, testLen, &condResult) != 0) {
   776→            return TCL_ERROR;
   777→        }
   778→
   779→        if (!condResult) {
   780→            break;
   781→        }
   782→
   783→        /* Execute body */
   784→        TclResult result = tclEvalScript(interp, bodyStr, bodyLen);
   785→
   786→        if (result == TCL_BREAK) {
   787→            break;
   788→        }
   789→        if (result == TCL_CONTINUE) {
   790→            continue;
   791→        }
   792→        if (result == TCL_ERROR || result == TCL_RETURN) {
   793→            return result;
   794→        }
   795→    }
   796→
   797→    tclSetResult(interp, host->newString("", 0));
   798→    return TCL_OK;
   799→}
   800→
   801→/* ========================================================================
   802→ * for Command
   803→ * ======================================================================== */
   804→
   805→TclResult tclCmdFor(TclInterp *interp, int objc, TclObj **objv) {
   806→    const TclHost *host = interp->host;
   807→
   808→    if (objc != 5) {
   809→        tclSetError(interp, "wrong # args: should be \"for start test next command\"", -1);
   810→        return TCL_ERROR;
   811→    }
   812→
   813→    size_t startLen, testLen, nextLen, bodyLen;
   814→    const char *startStr = host->getStringPtr(objv[1], &startLen);
   815→    const char *testStr = host->getStringPtr(objv[2], &testLen);
   816→    const char *nextStr = host->getStringPtr(objv[3], &nextLen);
   817→    const char *bodyStr = host->getStringPtr(objv[4], &bodyLen);
   818→
   819→    /* Execute initialization */
   820→    TclResult result = tclEvalScript(interp, startStr, startLen);
   821→    if (result != TCL_OK) {
   822→        return result;
   823→    }
   824→
   825→    while (1) {
   826→        /* Evaluate condition */
   827→        int condResult;
   828→        if (evalExprBool(interp, testStr, testLen, &condResult) != 0) {
   829→            return TCL_ERROR;
   830→        }
   831→
   832→        if (!condResult) {
   833→            break;
   834→        }
   835→
   836→        /* Execute body */
   837→        result = tclEvalScript(interp, bodyStr, bodyLen);
   838→
   839→        if (result == TCL_BREAK) {
   840→            break;
   841→        }
   842→        if (result == TCL_CONTINUE) {
   843→            /* Fall through to next */
   844→        } else if (result == TCL_ERROR || result == TCL_RETURN) {
   845→            return result;
   846→        }
   847→
   848→        /* Execute next */
   849→        result = tclEvalScript(interp, nextStr, nextLen);
   850→        if (result != TCL_OK && result != TCL_CONTINUE) {
   851→            return result;
   852→        }
   853→    }
   854→
   855→    tclSetResult(interp, host->newString("", 0));
   856→    return TCL_OK;
   857→}
   858→
   859→/* ========================================================================
   860→ * foreach Command
   861→ * ======================================================================== */
   862→
   863→TclResult tclCmdForeach(TclInterp *interp, int objc, TclObj **objv) {
   864→    const TclHost *host = interp->host;
   865→
   866→    if (objc != 4) {
   867→        tclSetError(interp, "wrong # args: should be \"foreach varname list body\"", -1);
   868→        return TCL_ERROR;
   869→    }
   870→
   871→    size_t varNameLen;
   872→    const char *varName = host->getStringPtr(objv[1], &varNameLen);
   873→
   874→    /* Parse list */
   875→    TclObj **elems = NULL;
   876→    size_t elemCount = 0;
   877→    if (host->asList(objv[2], &elems, &elemCount) != 0) {
   878→        tclSetError(interp, "invalid list", -1);
   879→        return TCL_ERROR;
   880→    }
   881→
   882→    size_t bodyLen;
   883→    const char *bodyStr = host->getStringPtr(objv[3], &bodyLen);
   884→
   885→    void *vars = interp->currentFrame->varsHandle;
   886→
   887→    for (size_t i = 0; i < elemCount; i++) {
   888→        /* Set loop variable */
   889→        host->varSet(vars, varName, varNameLen, host->dup(elems[i]));
   890→
   891→        /* Execute body */
   892→        TclResult result = tclEvalScript(interp, bodyStr, bodyLen);
   893→
   894→        if (result == TCL_BREAK) {
   895→            break;
   896→        }
   897→        if (result == TCL_CONTINUE) {
   898→            continue;
   899→        }
   900→        if (result == TCL_ERROR || result == TCL_RETURN) {
   901→            return result;
   902→        }
   903→    }
   904→
   905→    tclSetResult(interp, host->newString("", 0));
   906→    return TCL_OK;
   907→}
   908→
   909→/* ========================================================================
   910→ * break Command
   911→ * ======================================================================== */
   912→
   913→TclResult tclCmdBreak(TclInterp *interp, int objc, TclObj **objv) {
   914→    (void)objv;
   915→
   916→    if (objc != 1) {
   917→        tclSetError(interp, "wrong # args: should be \"break\"", -1);
   918→        return TCL_ERROR;
   919→    }
   920→
   921→    tclSetResult(interp, interp->host->newString("", 0));
   922→    return TCL_BREAK;
   923→}
   924→
   925→/* ========================================================================
   926→ * continue Command
   927→ * ======================================================================== */
   928→
   929→TclResult tclCmdContinue(TclInterp *interp, int objc, TclObj **objv) {
   930→    (void)objv;
   931→
   932→    if (objc != 1) {
   933→        tclSetError(interp, "wrong # args: should be \"continue\"", -1);
   934→        return TCL_ERROR;
   935→    }
   936→
   937→    tclSetResult(interp, interp->host->newString("", 0));
   938→    return TCL_CONTINUE;
   939→}
   940→
   941→/* ========================================================================
   942→ * incr Command
   943→ * ======================================================================== */
   944→
   945→TclResult tclCmdIncr(TclInterp *interp, int objc, TclObj **objv) {
   946→    const TclHost *host = interp->host;
   947→
   948→    if (objc < 2 || objc > 3) {
   949→        tclSetError(interp, "wrong # args: should be \"incr varName ?increment?\"", -1);
   950→        return TCL_ERROR;
   951→    }
   952→
   953→    size_t nameLen;
   954→    const char *name = host->getStringPtr(objv[1], &nameLen);
   955→    void *vars = interp->currentFrame->varsHandle;
   956→
   957→    /* Get increment value (default 1) */
   958→    int64_t increment = 1;
   959→    if (objc == 3) {
   960→        if (host->asInt(objv[2], &increment) != 0) {
   961→            tclSetError(interp, "expected integer but got non-integer value", -1);
   962→            return TCL_ERROR;
   963→        }
   964→    }
   965→
   966→    /* Get current value (or 0 if doesn't exist) */
   967→    int64_t currentVal = 0;
   968→    TclObj *current = host->varGet(vars, name, nameLen);
   969→    if (!current && interp->currentFrame != interp->globalFrame) {
   970→        current = host->varGet(interp->globalFrame->varsHandle, name, nameLen);
   971→    }
   972→
   973→    if (current) {
   974→        if (host->asInt(current, &currentVal) != 0) {
   975→            tclSetError(interp, "expected integer but got non-integer value", -1);
   976→            return TCL_ERROR;
   977→        }
   978→    }
   979→
   980→    /* Calculate new value */
   981→    int64_t newVal = currentVal + increment;
   982→
   983→    /* Store and return */
   984→    TclObj *result = host->newInt(newVal);
   985→    host->varSet(vars, name, nameLen, host->dup(result));
   986→    tclSetResult(interp, result);
   987→    return TCL_OK;
   988→}
   989→
   990→/* ========================================================================
   991→ * append Command
   992→ * ======================================================================== */
   993→
   994→TclResult tclCmdAppend(TclInterp *interp, int objc, TclObj **objv) {
   995→    const TclHost *host = interp->host;
   996→
   997→    if (objc < 2) {
   998→        tclSetError(interp, "wrong # args: should be \"append varName ?value ...?\"", -1);
   999→        return TCL_ERROR;
  1000→    }
  1001→
  1002→    size_t nameLen;
  1003→    const char *name = host->getStringPtr(objv[1], &nameLen);
  1004→    void *vars = interp->currentFrame->varsHandle;
  1005→
  1006→    /* Get current value (or empty if doesn't exist) */
  1007→    TclObj *current = host->varGet(vars, name, nameLen);
  1008→    if (!current && interp->currentFrame != interp->globalFrame) {
  1009→        current = host->varGet(interp->globalFrame->varsHandle, name, nameLen);
  1010→    }
  1011→
  1012→    size_t currentLen = 0;
  1013→    const char *currentStr = "";
  1014→    if (current) {
  1015→        currentStr = host->getStringPtr(current, &currentLen);
  1016→    }
  1017→
  1018→    /* Calculate total length */
  1019→    size_t totalLen = currentLen;
  1020→    for (int i = 2; i < objc; i++) {
  1021→        size_t len;
  1022→        host->getStringPtr(objv[i], &len);
  1023→        totalLen += len;
  1024→    }
  1025→
  1026→    /* Build result */
  1027→    void *arena = host->arenaPush(interp->hostCtx);
  1028→    char *buf = host->arenaAlloc(arena, totalLen + 1, 1);
  1029→    char *p = buf;
  1030→
  1031→    /* Copy current value */
  1032→    for (size_t i = 0; i < currentLen; i++) {
  1033→        *p++ = currentStr[i];
  1034→    }
  1035→
  1036→    /* Append all values */
  1037→    for (int i = 2; i < objc; i++) {
  1038→        size_t len;
  1039→        const char *s = host->getStringPtr(objv[i], &len);
  1040→        for (size_t j = 0; j < len; j++) {
  1041→            *p++ = s[j];
  1042→        }
  1043→    }
  1044→    *p = '\0';
  1045→
  1046→    TclObj *result = host->newString(buf, totalLen);
  1047→    host->arenaPop(interp->hostCtx, arena);
  1048→
  1049→    host->varSet(vars, name, nameLen, host->dup(result));
  1050→    tclSetResult(interp, result);
  1051→    return TCL_OK;
  1052→}
  1053→
  1054→/* ========================================================================
  1055→ * unset Command
  1056→ * ======================================================================== */
  1057→
  1058→TclResult tclCmdUnset(TclInterp *interp, int objc, TclObj **objv) {
  1059→    const TclHost *host = interp->host;
  1060→
  1061→    int nocomplain = 0;
  1062→    int argStart = 1;
  1063→
  1064→    /* Parse options */
  1065→    while (argStart < objc) {
  1066→        size_t len;
  1067→        const char *arg = host->getStringPtr(objv[argStart], &len);
  1068→
  1069→        if (len == 11 && tclStrncmp(arg, "-nocomplain", 11) == 0) {
  1070→            nocomplain = 1;
  1071→            argStart++;
  1072→        } else if (len == 2 && tclStrncmp(arg, "--", 2) == 0) {
  1073→            argStart++;
  1074→            break;
  1075→        } else {
  1076→            break;
  1077→        }
  1078→    }
  1079→
  1080→    void *vars = interp->currentFrame->varsHandle;
  1081→
  1082→    /* Unset each variable */
  1083→    for (int i = argStart; i < objc; i++) {
  1084→        size_t nameLen;
  1085→        const char *name = host->getStringPtr(objv[i], &nameLen);
  1086→
  1087→        /* Check if variable exists */
  1088→        if (!host->varExists(vars, name, nameLen)) {
  1089→            if (interp->currentFrame != interp->globalFrame) {
  1090→                if (host->varExists(interp->globalFrame->varsHandle, name, nameLen)) {
  1091→                    host->varUnset(interp->globalFrame->varsHandle, name, nameLen);
  1092→                    continue;
  1093→                }
  1094→            }
  1095→            if (!nocomplain) {
  1096→                tclSetError(interp, "can't unset: no such variable", -1);
  1097→                return TCL_ERROR;
  1098→            }
  1099→        } else {
  1100→            host->varUnset(vars, name, nameLen);
  1101→        }
  1102→    }
  1103→
  1104→    tclSetResult(interp, host->newString("", 0));
  1105→    return TCL_OK;
  1106→}
  1107→
  1108→/* ========================================================================
  1109→ * array Command
  1110→ * ======================================================================== */
  1111→
  1112→TclResult tclCmdArray(TclInterp *interp, int objc, TclObj **objv) {
  1113→    const TclHost *host = interp->host;
  1114→
  1115→    if (objc < 2) {
  1116→        tclSetError(interp, "wrong # args: should be \"array subcommand arrayName ?arg ...?\"", -1);
  1117→        return TCL_ERROR;
  1118→    }
  1119→
  1120→    size_t subcmdLen;
  1121→    const char *subcmd = host->getStringPtr(objv[1], &subcmdLen);
  1122→
  1123→    /* array exists arrayName */
  1124→    if (subcmdLen == 6 && tclStrncmp(subcmd, "exists", 6) == 0) {
  1125→        if (objc != 3) {
  1126→            tclSetError(interp, "wrong # args: should be \"array exists arrayName\"", -1);
  1127→            return TCL_ERROR;
  1128→        }
  1129→        size_t arrLen;
  1130→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
  1131→        void *vars = interp->currentFrame->varsHandle;
  1132→
  1133→        /* Check if any array elements exist */
  1134→        size_t size = host->arraySize(vars, arrName, arrLen);
  1135→        if (size == 0 && interp->currentFrame != interp->globalFrame) {
  1136→            size = host->arraySize(interp->globalFrame->varsHandle, arrName, arrLen);
  1137→        }
  1138→
  1139→        tclSetResult(interp, host->newInt(size > 0 ? 1 : 0));
  1140→        return TCL_OK;
  1141→    }
  1142→
  1143→    /* array names arrayName ?pattern? */
  1144→    if (subcmdLen == 5 && tclStrncmp(subcmd, "names", 5) == 0) {
  1145→        if (objc < 3 || objc > 4) {
  1146→            tclSetError(interp, "wrong # args: should be \"array names arrayName ?pattern?\"", -1);
  1147→            return TCL_ERROR;
  1148→        }
  1149→        size_t arrLen;
  1150→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
  1151→        const char *pattern = NULL;
  1152→        if (objc == 4) {
  1153→            size_t patLen;
  1154→            pattern = host->getStringPtr(objv[3], &patLen);
  1155→        }
  1156→
  1157→        void *vars = interp->currentFrame->varsHandle;
  1158→        TclObj *names = host->arrayNames(vars, arrName, arrLen, pattern);
  1159→        if (!names && interp->currentFrame != interp->globalFrame) {
  1160→            names = host->arrayNames(interp->globalFrame->varsHandle, arrName, arrLen, pattern);
  1161→        }
  1162→
  1163→        tclSetResult(interp, names ? names : host->newString("", 0));
  1164→        return TCL_OK;
  1165→    }
  1166→
  1167→    /* array size arrayName */
  1168→    if (subcmdLen == 4 && tclStrncmp(subcmd, "size", 4) == 0) {
  1169→        if (objc != 3) {
  1170→            tclSetError(interp, "wrong # args: should be \"array size arrayName\"", -1);
  1171→            return TCL_ERROR;
  1172→        }
  1173→        size_t arrLen;
  1174→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
  1175→        void *vars = interp->currentFrame->varsHandle;
  1176→
  1177→        size_t size = host->arraySize(vars, arrName, arrLen);
  1178→        if (size == 0 && interp->currentFrame != interp->globalFrame) {
  1179→            size = host->arraySize(interp->globalFrame->varsHandle, arrName, arrLen);
  1180→        }
  1181→
  1182→        tclSetResult(interp, host->newInt((int64_t)size));
  1183→        return TCL_OK;
  1184→    }
  1185→
  1186→    /* array get arrayName ?pattern? */
  1187→    if (subcmdLen == 3 && tclStrncmp(subcmd, "get", 3) == 0) {
  1188→        if (objc < 3 || objc > 4) {
  1189→            tclSetError(interp, "wrong # args: should be \"array get arrayName ?pattern?\"", -1);
  1190→            return TCL_ERROR;
  1191→        }
  1192→        size_t arrLen;
  1193→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
  1194→        const char *pattern = NULL;
  1195→        if (objc == 4) {
  1196→            size_t patLen;
  1197→            pattern = host->getStringPtr(objv[3], &patLen);
  1198→        }
  1199→
  1200→        void *vars = interp->currentFrame->varsHandle;
  1201→
  1202→        /* Get array names */
  1203→        TclObj *names = host->arrayNames(vars, arrName, arrLen, pattern);
  1204→        if (!names && interp->currentFrame != interp->globalFrame) {
  1205→            vars = interp->globalFrame->varsHandle;
  1206→            names = host->arrayNames(vars, arrName, arrLen, pattern);
  1207→        }
  1208→
  1209→        if (!names) {
  1210→            tclSetResult(interp, host->newString("", 0));
  1211→            return TCL_OK;
  1212→        }
  1213→
  1214→        /* Parse names and build key-value list */
  1215→        TclObj **nameList;
  1216→        size_t nameCount;
  1217→        if (host->asList(names, &nameList, &nameCount) != 0 || nameCount == 0) {
  1218→            tclSetResult(interp, host->newString("", 0));
  1219→            return TCL_OK;
  1220→        }
  1221→
  1222→        /* Build result list with key value pairs */
  1223→        void *arena = host->arenaPush(interp->hostCtx);
  1224→        size_t resultCount = nameCount * 2;
  1225→        TclObj **resultElems = host->arenaAlloc(arena, resultCount * sizeof(TclObj*), sizeof(void*));
  1226→
  1227→        for (size_t i = 0; i < nameCount; i++) {
  1228→            size_t keyLen;
  1229→            const char *key = host->getStringPtr(nameList[i], &keyLen);
  1230→            resultElems[i * 2] = nameList[i];
  1231→            resultElems[i * 2 + 1] = host->arrayGet(vars, arrName, arrLen, key, keyLen);
  1232→        }
  1233→
  1234→        TclObj *result = host->newList(resultElems, resultCount);
  1235→        host->arenaPop(interp->hostCtx, arena);
  1236→        tclSetResult(interp, result);
  1237→        return TCL_OK;
  1238→    }
  1239→
  1240→    /* array set arrayName list */
  1241→    if (subcmdLen == 3 && tclStrncmp(subcmd, "set", 3) == 0) {
  1242→        if (objc != 4) {
  1243→            tclSetError(interp, "wrong # args: should be \"array set arrayName list\"", -1);
  1244→            return TCL_ERROR;
  1245→        }
  1246→        size_t arrLen;
  1247→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
  1248→
  1249→        /* Parse list */
  1250→        TclObj **elems;
  1251→        size_t elemCount;
  1252→        if (host->asList(objv[3], &elems, &elemCount) != 0) {
  1253→            tclSetError(interp, "list must have an even number of elements", -1);
  1254→            return TCL_ERROR;
  1255→        }
  1256→
  1257→        if (elemCount % 2 != 0) {
  1258→            tclSetError(interp, "list must have an even number of elements", -1);
  1259→            return TCL_ERROR;
  1260→        }
  1261→
  1262→        void *vars = interp->currentFrame->varsHandle;
  1263→
  1264→        /* Set each key-value pair */
  1265→        for (size_t i = 0; i < elemCount; i += 2) {
  1266→            size_t keyLen;
  1267→            const char *key = host->getStringPtr(elems[i], &keyLen);
  1268→            host->arraySet(vars, arrName, arrLen, key, keyLen, host->dup(elems[i + 1]));
  1269→        }
  1270→
  1271→        tclSetResult(interp, host->newString("", 0));
  1272→        return TCL_OK;
  1273→    }
  1274→
  1275→    /* array unset arrayName ?pattern? */
  1276→    if (subcmdLen == 5 && tclStrncmp(subcmd, "unset", 5) == 0) {
  1277→        if (objc < 3 || objc > 4) {
  1278→            tclSetError(interp, "wrong # args: should be \"array unset arrayName ?pattern?\"", -1);
  1279→            return TCL_ERROR;
  1280→        }
  1281→        size_t arrLen;
  1282→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
  1283→        const char *pattern = NULL;
  1284→        if (objc == 4) {
  1285→            size_t patLen;
  1286→            pattern = host->getStringPtr(objv[3], &patLen);
  1287→        }
  1288→
  1289→        void *vars = interp->currentFrame->varsHandle;
  1290→
  1291→        if (pattern == NULL) {
  1292→            /* Unset entire array - get all names and unset each */
  1293→            TclObj *names = host->arrayNames(vars, arrName, arrLen, NULL);
  1294→            if (names) {
  1295→                TclObj **nameList;
  1296→                size_t nameCount;
  1297→                if (host->asList(names, &nameList, &nameCount) == 0) {
  1298→                    for (size_t i = 0; i < nameCount; i++) {
  1299→                        size_t keyLen;
  1300→                        const char *key = host->getStringPtr(nameList[i], &keyLen);
  1301→                        host->arrayUnset(vars, arrName, arrLen, key, keyLen);
  1302→                    }
  1303→                }
  1304→            }
  1305→        } else {
  1306→            /* Unset matching elements */
  1307→            TclObj *names = host->arrayNames(vars, arrName, arrLen, pattern);
  1308→            if (names) {
  1309→                TclObj **nameList;
  1310→                size_t nameCount;
  1311→                if (host->asList(names, &nameList, &nameCount) == 0) {
  1312→                    for (size_t i = 0; i < nameCount; i++) {
  1313→                        size_t keyLen;
  1314→                        const char *key = host->getStringPtr(nameList[i], &keyLen);
  1315→                        host->arrayUnset(vars, arrName, arrLen, key, keyLen);
  1316→                    }
  1317→                }
  1318→            }
  1319→        }
  1320→
  1321→        tclSetResult(interp, host->newString("", 0));
  1322→        return TCL_OK;
  1323→    }
  1324→
  1325→    tclSetError(interp, "unknown or ambiguous subcommand", -1);
  1326→    return TCL_ERROR;
  1327→}
  1328→
  1329→/* ========================================================================
  1330→ * info Command
  1331→ * ======================================================================== */
  1332→
  1333→TclResult tclCmdInfo(TclInterp *interp, int objc, TclObj **objv) {
  1334→    const TclHost *host = interp->host;
  1335→
  1336→    if (objc < 2) {
  1337→        tclSetError(interp, "wrong # args: should be \"info subcommand ?arg ...?\"", -1);
  1338→        return TCL_ERROR;
  1339→    }
  1340→
  1341→    size_t subcmdLen;
  1342→    const char *subcmd = host->getStringPtr(objv[1], &subcmdLen);
  1343→
  1344→    /* info exists varName */
  1345→    if (subcmdLen == 6 && tclStrncmp(subcmd, "exists", 6) == 0) {
  1346→        if (objc != 3) {
  1347→            tclSetError(interp, "wrong # args: should be \"info exists varName\"", -1);
  1348→            return TCL_ERROR;
  1349→        }
  1350→        size_t nameLen;
  1351→        const char *name = host->getStringPtr(objv[2], &nameLen);
  1352→        void *vars = interp->currentFrame->varsHandle;
  1353→
  1354→        int exists = host->varExists(vars, name, nameLen);
  1355→        if (!exists && interp->currentFrame != interp->globalFrame) {
  1356→            exists = host->varExists(interp->globalFrame->varsHandle, name, nameLen);
  1357→        }
  1358→
  1359→        tclSetResult(interp, host->newInt(exists ? 1 : 0));
  1360→        return TCL_OK;
  1361→    }
  1362→
  1363→    tclSetError(interp, "unknown or ambiguous subcommand", -1);
  1364→    return TCL_ERROR;
  1365→}
  1366→
  1367→/* ========================================================================
  1368→ * Builtin Table
  1369→ * ======================================================================== */
  1370→
  1371→/* Sorted alphabetically for binary search */
  1372→static const TclBuiltinEntry builtinTable[] = {
  1373→    {"break",    tclCmdBreak},
  1374→    {"continue", tclCmdContinue},
  1375→    {"expr",     tclCmdExpr},
  1376→    {"for",      tclCmdFor},
  1377→    {"foreach",  tclCmdForeach},
  1378→    {"if",       tclCmdIf},
  1379→    {"proc",     tclCmdProc},
  1380→    {"puts",     tclCmdPuts},
  1381→    {"return",   tclCmdReturn},
  1382→    {"set",      tclCmdSet},
  1383→    {"string",   tclCmdString},
  1384→    {"subst",    tclCmdSubst},
  1385→    {"while",    tclCmdWhile},
  1386→};
  1387→
  1388→static const int builtinCount = sizeof(builtinTable) / sizeof(builtinTable[0]);
  1389→
  1390→/* Binary search for builtin command */
  1391→int tclBuiltinLookup(const char *name, size_t len) {
  1392→    int lo = 0;
  1393→    int hi = builtinCount - 1;
  1394→
  1395→    while (lo <= hi) {
  1396→        int mid = (lo + hi) / 2;
  1397→        const char *midName = builtinTable[mid].name;
  1398→        size_t midLen = tclStrlen(midName);
  1399→
  1400→        /* Compare */
  1401→        int cmp;
  1402→        size_t minLen = len < midLen ? len : midLen;
  1403→        cmp = tclStrncmp(name, midName, minLen);
  1404→        if (cmp == 0) {
  1405→            if (len < midLen) cmp = -1;
  1406→            else if (len > midLen) cmp = 1;
  1407→        }
  1408→
  1409→        if (cmp < 0) {
  1410→            hi = mid - 1;
  1411→        } else if (cmp > 0) {
  1412→            lo = mid + 1;
  1413→        } else {
  1414→            return mid;
  1415→        }
  1416→    }
  1417→
  1418→    return -1;  /* Not found */
  1419→}
  1420→
  1421→const TclBuiltinEntry *tclBuiltinGet(int index) {
  1422→    if (index < 0 || index >= builtinCount) {
  1423→        return NULL;
  1424→    }
  1425→    return &builtinTable[index];
  1426→}
  1427→
  1428→int tclBuiltinCount(void) {
  1429→    return builtinCount;
  1430→}
  1431→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
