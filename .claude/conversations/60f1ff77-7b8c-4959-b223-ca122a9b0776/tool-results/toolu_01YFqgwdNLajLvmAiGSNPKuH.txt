     1→/*
     2→ * host.c - TclHost Callback Table for C Host (GLib version)
     3→ *
     4→ * Assembles all host callbacks into the TclHost structure using GLib.
     5→ */
     6→
     7→#include "../../core/tclc.h"
     8→#include <glib.h>
     9→#include <string.h>
    10→
    11→/* External functions from object.c */
    12→extern TclObj *hostNewString(const char *s, size_t len);
    13→extern TclObj *hostNewInt(int64_t val);
    14→extern TclObj *hostNewDouble(double val);
    15→extern TclObj *hostNewBool(int val);
    16→extern TclObj *hostNewList(TclObj **elems, size_t count);
    17→extern TclObj *hostNewDict(void);
    18→extern TclObj *hostDup(TclObj *obj);
    19→extern void hostFreeObj(TclObj *obj);
    20→extern const char *hostGetStringPtr(TclObj *obj, size_t *lenOut);
    21→extern int hostAsInt(TclObj *obj, int64_t *out);
    22→extern int hostAsDouble(TclObj *obj, double *out);
    23→extern int hostAsBool(TclObj *obj, int *out);
    24→extern int hostAsList(TclObj *obj, TclObj ***elemsOut, size_t *countOut);
    25→extern size_t hostStringLength(TclObj *str);
    26→extern int hostStringCompare(TclObj *a, TclObj *b);
    27→extern size_t hostListLengthImpl(TclObj *list);
    28→extern TclObj *hostListIndexImpl(TclObj *list, size_t idx);
    29→
    30→/* External functions from vars.c */
    31→extern void *hostVarsNew(void *ctx);
    32→extern void hostVarsFree(void *ctx, void *vars);
    33→extern TclObj *hostVarGet(void *vars, const char *name, size_t len);
    34→extern void hostVarSet(void *vars, const char *name, size_t len, TclObj *val);
    35→extern void hostVarUnset(void *vars, const char *name, size_t len);
    36→extern int hostVarExists(void *vars, const char *name, size_t len);
    37→extern TclObj *hostVarNames(void *vars, const char *pattern);
    38→extern void hostVarLink(void *localVars, const char *localName, size_t localLen,
    39→                        void *targetVars, const char *targetName, size_t targetLen);
    40→extern void hostArraySet(void *vars, const char *arr, size_t arrLen,
    41→                         const char *key, size_t keyLen, TclObj *val);
    42→extern TclObj *hostArrayGet(void *vars, const char *arr, size_t arrLen,
    43→                            const char *key, size_t keyLen);
    44→extern int hostArrayExists(void *vars, const char *arr, size_t arrLen,
    45→                           const char *key, size_t keyLen);
    46→extern TclObj *hostArrayNames(void *vars, const char *arr, size_t arrLen,
    47→                              const char *pattern);
    48→extern void hostArrayUnset(void *vars, const char *arr, size_t arrLen,
    49→                           const char *key, size_t keyLen);
    50→extern size_t hostArraySize(void *vars, const char *arr, size_t arrLen);
    51→
    52→/* External functions from arena.c */
    53→extern void *hostArenaPush(void *ctx);
    54→extern void hostArenaPop(void *ctx, void *arena);
    55→extern void *hostArenaAlloc(void *arena, size_t size, size_t align);
    56→extern char *hostArenaStrdup(void *arena, const char *s, size_t len);
    57→extern size_t hostArenaMark(void *arena);
    58→extern void hostArenaReset(void *arena, size_t mark);
    59→
    60→/* External functions from channel.c */
    61→extern TclChannel *hostChanOpen(void *ctx, const char *name, const char *mode);
    62→extern void hostChanClose(void *ctx, TclChannel *chan);
    63→extern TclChannel *hostChanStdin(void *ctx);
    64→extern TclChannel *hostChanStdout(void *ctx);
    65→extern TclChannel *hostChanStderr(void *ctx);
    66→extern int hostChanRead(TclChannel *chan, char *buf, size_t len);
    67→extern int hostChanWrite(TclChannel *chan, const char *buf, size_t len);
    68→extern TclObj *hostChanGets(TclChannel *chan, int *eofOut);
    69→extern int hostChanFlush(TclChannel *chan);
    70→extern int hostChanSeek(TclChannel *chan, int64_t offset, int whence);
    71→extern int64_t hostChanTell(TclChannel *chan);
    72→extern int hostChanEof(TclChannel *chan);
    73→extern int hostChanBlocked(TclChannel *chan);
    74→extern int hostChanConfigure(TclChannel *chan, const char *opt, TclObj *val);
    75→extern TclObj *hostChanCget(TclChannel *chan, const char *opt);
    76→extern TclObj *hostChanNames(void *ctx, const char *pattern);
    77→extern void hostChanShare(void *fromCtx, void *toCtx, TclChannel *chan);
    78→extern void hostChanTransfer(void *fromCtx, void *toCtx, TclChannel *chan);
    79→
    80→/* ========================================================================
    81→ * Proc Storage
    82→ * ======================================================================== */
    83→
    84→typedef struct ProcDef {
    85→    gchar   *name;      /* Procedure name */
    86→    gsize    nameLen;   /* Name length */
    87→    TclObj  *argList;   /* Argument list */
    88→    TclObj  *body;      /* Procedure body */
    89→} ProcDef;
    90→
    91→/* ========================================================================
    92→ * Interpreter Context
    93→ * ======================================================================== */
    94→
    95→typedef struct HostContext {
    96→    void       *globalVars;   /* Global variable table */
    97→    GHashTable *procs;        /* Procedure definitions: name -> ProcDef* */
    98→} HostContext;
    99→
   100→/* Free a proc definition */
   101→static void procDefFree(gpointer data) {
   102→    ProcDef *proc = data;
   103→    if (proc) {
   104→        g_free(proc->name);
   105→        hostFreeObj(proc->argList);
   106→        hostFreeObj(proc->body);
   107→        g_free(proc);
   108→    }
   109→}
   110→
   111→static void *hostInterpContextNew(void *parentCtx, int safe) {
   112→    (void)parentCtx;
   113→    (void)safe;
   114→
   115→    HostContext *ctx = g_new0(HostContext, 1);
   116→    if (!ctx) return NULL;
   117→
   118→    ctx->globalVars = hostVarsNew(ctx);
   119→    ctx->procs = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, procDefFree);
   120→    return ctx;
   121→}
   122→
   123→static void hostInterpContextFree(void *ctxPtr) {
   124→    HostContext *ctx = ctxPtr;
   125→    if (!ctx) return;
   126→
   127→    g_hash_table_destroy(ctx->procs);
   128→    hostVarsFree(ctx, ctx->globalVars);
   129→    g_free(ctx);
   130→}
   131→
   132→/* ========================================================================
   133→ * Frame Allocation
   134→ * ======================================================================== */
   135→
   136→static TclFrame *hostFrameAlloc(void *ctx) {
   137→    TclFrame *frame = g_new0(TclFrame, 1);
   138→    if (frame) {
   139→        frame->varsHandle = hostVarsNew(ctx);
   140→    }
   141→    return frame;
   142→}
   143→
   144→static void hostFrameFree(void *ctx, TclFrame *frame) {
   145→    if (frame) {
   146→        hostVarsFree(ctx, frame->varsHandle);
   147→        g_free(frame);
   148→    }
   149→}
   150→
   151→/* ========================================================================
   152→ * Command Lookup - finds procedures registered via proc command
   153→ * ======================================================================== */
   154→
   155→static int hostCmdLookup(void *ctxPtr, const char *name, size_t len, TclCmdInfo *out) {
   156→    HostContext *ctx = ctxPtr;
   157→
   158→    gchar *key = g_strndup(name, len);
   159→    ProcDef *proc = g_hash_table_lookup(ctx->procs, key);
   160→    g_free(key);
   161→
   162→    if (proc) {
   163→        out->type = TCL_CMD_PROC;
   164→        out->u.procHandle = proc;
   165→        return 0;
   166→    }
   167→
   168→    out->type = TCL_CMD_NOT_FOUND;
   169→    return 0;
   170→}
   171→
   172→static void *hostProcRegister(void *ctxPtr, const char *name, size_t len,
   173→                              TclObj *argList, TclObj *body) {
   174→    HostContext *ctx = ctxPtr;
   175→
   176→    gchar *key = g_strndup(name, len);
   177→    ProcDef *existing = g_hash_table_lookup(ctx->procs, key);
   178→
   179→    if (existing) {
   180→        /* Replace the existing definition */
   181→        hostFreeObj(existing->argList);
   182→        hostFreeObj(existing->body);
   183→        existing->argList = hostDup(argList);
   184→        existing->body = hostDup(body);
   185→        g_free(key);
   186→        return existing;
   187→    }
   188→
   189→    /* Create new proc definition */
   190→    ProcDef *proc = g_new0(ProcDef, 1);
   191→    proc->name = g_strndup(name, len);
   192→    proc->nameLen = len;
   193→    proc->argList = hostDup(argList);
   194→    proc->body = hostDup(body);
   195→
   196→    g_hash_table_insert(ctx->procs, key, proc);
   197→    return proc;
   198→}
   199→
   200→static int hostProcGetDef(void *handle, TclObj **argListOut, TclObj **bodyOut) {
   201→    ProcDef *proc = handle;
   202→    if (!proc) return -1;
   203→
   204→    *argListOut = proc->argList;
   205→    *bodyOut = proc->body;
   206→    return 0;
   207→}
   208→
   209→static TclResult hostExtInvoke(TclInterp *interp, void *handle,
   210→                               int objc, TclObj **objv) {
   211→    (void)interp;
   212→    (void)handle;
   213→    (void)objc;
   214→    (void)objv;
   215→    return TCL_ERROR;
   216→}
   217→
   218→static int hostCmdRename(void *ctx, const char *oldName, size_t oldLen,
   219→                         const char *newName, size_t newLen) {
   220→    (void)ctx;
   221→    (void)oldName;
   222→    (void)oldLen;
   223→    (void)newName;
   224→    (void)newLen;
   225→    return -1;
   226→}
   227→
   228→static int hostCmdDelete(void *ctx, const char *name, size_t len) {
   229→    (void)ctx;
   230→    (void)name;
   231→    (void)len;
   232→    return -1;
   233→}
   234→
   235→static int hostCmdExists(void *ctx, const char *name, size_t len) {
   236→    (void)ctx;
   237→    (void)name;
   238→    (void)len;
   239→    return 0;
   240→}
   241→
   242→static TclObj *hostCmdList(void *ctx, const char *pattern) {
   243→    (void)ctx;
   244→    (void)pattern;
   245→    return hostNewString("", 0);
   246→}
   247→
   248→static void hostCmdHide(void *ctx, const char *name, size_t len) {
   249→    (void)ctx;
   250→    (void)name;
   251→    (void)len;
   252→}
   253→
   254→static void hostCmdExpose(void *ctx, const char *name, size_t len) {
   255→    (void)ctx;
   256→    (void)name;
   257→    (void)len;
   258→}
   259→
   260→/* ========================================================================
   261→ * List Operations
   262→ * ======================================================================== */
   263→
   264→static size_t hostListLength(TclObj *list) {
   265→    return hostListLengthImpl(list);
   266→}
   267→
   268→static TclObj *hostListIndex(TclObj *list, size_t idx) {
   269→    return hostListIndexImpl(list, idx);
   270→}
   271→
   272→static TclObj *hostListRange(TclObj *list, size_t first, size_t last) {
   273→    if (!list || first > last) {
   274→        return hostNewString("", 0);
   275→    }
   276→
   277→    size_t listLen = hostListLengthImpl(list);
   278→    if (first >= listLen) {
   279→        return hostNewString("", 0);
   280→    }
   281→    if (last >= listLen) {
   282→        last = listLen - 1;
   283→    }
   284→
   285→    size_t count = last - first + 1;
   286→    TclObj **elems = g_new(TclObj*, count);
   287→    if (!elems) return hostNewString("", 0);
   288→
   289→    for (size_t i = 0; i < count; i++) {
   290→        elems[i] = hostListIndexImpl(list, first + i);
   291→    }
   292→
   293→    TclObj *result = hostNewList(elems, count);
   294→    g_free(elems);
   295→    return result;
   296→}
   297→
   298→static TclObj *hostListSet(TclObj *list, size_t idx, TclObj *val) {
   299→    (void)list;
   300→    (void)idx;
   301→    (void)val;
   302→    return NULL;
   303→}
   304→
   305→static TclObj *hostListAppend(TclObj *list, TclObj *elem) {
   306→    if (!elem) return list ? hostDup(list) : hostNewString("", 0);
   307→
   308→    size_t listLen = list ? hostListLengthImpl(list) : 0;
   309→    size_t newCount = listLen + 1;
   310→
   311→    TclObj **elems = g_new(TclObj*, newCount);
   312→    if (!elems) return list ? hostDup(list) : hostNewString("", 0);
   313→
   314→    /* Copy existing elements */
   315→    for (size_t i = 0; i < listLen; i++) {
   316→        elems[i] = hostListIndexImpl(list, i);
   317→    }
   318→    /* Add new element */
   319→    elems[listLen] = elem;
   320→
   321→    TclObj *result = hostNewList(elems, newCount);
   322→    g_free(elems);
   323→    return result;
   324→}
   325→
   326→static TclObj *hostListConcat(TclObj *a, TclObj *b) {
   327→    (void)a;
   328→    (void)b;
   329→    return NULL;
   330→}
   331→
   332→static TclObj *hostListInsert(TclObj *list, size_t idx, TclObj **elems, size_t count) {
   333→    (void)list;
   334→    (void)idx;
   335→    (void)elems;
   336→    (void)count;
   337→    return NULL;
   338→}
   339→
   340→/* Compare function for qsort - ascending string */
   341→static gint cmpStrAsc(gconstpointer a, gconstpointer b) {
   342→    TclObj *oa = *(TclObj **)a;
   343→    TclObj *ob = *(TclObj **)b;
   344→    return hostStringCompare(oa, ob);
   345→}
   346→
   347→/* Compare function for qsort - descending string */
   348→static gint cmpStrDesc(gconstpointer a, gconstpointer b) {
   349→    return -cmpStrAsc(a, b);
   350→}
   351→
   352→/* Compare function for qsort - ascending string nocase */
   353→static gint cmpStrNocaseAsc(gconstpointer a, gconstpointer b) {
   354→    TclObj *oa = *(TclObj **)a;
   355→    TclObj *ob = *(TclObj **)b;
   356→    size_t lenA, lenB;
   357→    const char *sa = hostGetStringPtr(oa, &lenA);
   358→    const char *sb = hostGetStringPtr(ob, &lenB);
   359→    return g_ascii_strcasecmp(sa, sb);
   360→}
   361→
   362→/* Compare function for qsort - descending string nocase */
   363→static gint cmpStrNocaseDesc(gconstpointer a, gconstpointer b) {
   364→    return -cmpStrNocaseAsc(a, b);
   365→}
   366→
   367→/* Compare function for qsort - ascending integer */
   368→static gint cmpIntAsc(gconstpointer a, gconstpointer b) {
   369→    TclObj *oa = *(TclObj **)a;
   370→    TclObj *ob = *(TclObj **)b;
   371→    int64_t ia, ib;
   372→    hostAsInt(oa, &ia);
   373→    hostAsInt(ob, &ib);
   374→    if (ia < ib) return -1;
   375→    if (ia > ib) return 1;
   376→    return 0;
   377→}
   378→
   379→/* Compare function for qsort - descending integer */
   380→static gint cmpIntDesc(gconstpointer a, gconstpointer b) {
   381→    return -cmpIntAsc(a, b);
   382→}
   383→
   384→/* Compare function for qsort - ascending real */
   385→static gint cmpRealAsc(gconstpointer a, gconstpointer b) {
   386→    TclObj *oa = *(TclObj **)a;
   387→    TclObj *ob = *(TclObj **)b;
   388→    double da, db;
   389→    hostAsDouble(oa, &da);
   390→    hostAsDouble(ob, &db);
   391→    if (da < db) return -1;
   392→    if (da > db) return 1;
   393→    return 0;
   394→}
   395→
   396→/* Compare function for qsort - descending real */
   397→static gint cmpRealDesc(gconstpointer a, gconstpointer b) {
   398→    return -cmpRealAsc(a, b);
   399→}
   400→
   401→/* Dictionary comparison - case insensitive with embedded numbers */
   402→static gint dictcmp(const gchar *a, const gchar *b) {
   403→    while (*a && *b) {
   404→        /* Check if both are digits */
   405→        if (g_ascii_isdigit(*a) && g_ascii_isdigit(*b)) {
   406→            /* Compare as numbers */
   407→            glong na = 0, nb = 0;
   408→            while (g_ascii_isdigit(*a)) { na = na * 10 + (*a - '0'); a++; }
   409→            while (g_ascii_isdigit(*b)) { nb = nb * 10 + (*b - '0'); b++; }
   410→            if (na != nb) return (na < nb) ? -1 : 1;
   411→        } else {
   412→            /* Compare as case-insensitive chars */
   413→            gchar ca = g_ascii_tolower(*a);
   414→            gchar cb = g_ascii_tolower(*b);
   415→            if (ca != cb) return (guchar)ca - (guchar)cb;
   416→            a++; b++;
   417→        }
   418→    }
   419→    return (guchar)*a - (guchar)*b;
   420→}
   421→
   422→/* Compare function for qsort - ascending dictionary */
   423→static gint cmpDictAsc(gconstpointer a, gconstpointer b) {
   424→    TclObj *oa = *(TclObj **)a;
   425→    TclObj *ob = *(TclObj **)b;
   426→    size_t lenA, lenB;
   427→    const char *sa = hostGetStringPtr(oa, &lenA);
   428→    const char *sb = hostGetStringPtr(ob, &lenB);
   429→    return dictcmp(sa, sb);
   430→}
   431→
   432→/* Compare function for qsort - descending dictionary */
   433→static gint cmpDictDesc(gconstpointer a, gconstpointer b) {
   434→    return -cmpDictAsc(a, b);
   435→}
   436→
   437→static TclObj *hostListSort(TclObj *list, int flags) {
   438→    if (!list) return hostNewString("", 0);
   439→
   440→    size_t listLen = hostListLengthImpl(list);
   441→    if (listLen == 0) return hostNewString("", 0);
   442→    if (listLen == 1) return hostDup(list);
   443→
   444→    /* Get all elements */
   445→    TclObj **elems = g_new(TclObj*, listLen);
   446→    if (!elems) return hostDup(list);
   447→
   448→    for (size_t i = 0; i < listLen; i++) {
   449→        elems[i] = hostListIndexImpl(list, i);
   450→    }
   451→
   452→    /* flags: 1=decreasing, 2=integer, 4=nocase, 8=unique, 16=dictionary, 32=real */
   453→    gboolean decreasing = flags & 1;
   454→    gboolean integer = flags & 2;
   455→    gboolean nocase = flags & 4;
   456→    gboolean unique = flags & 8;
   457→    gboolean dictionary = flags & 16;
   458→    gboolean real = flags & 32;
   459→
   460→    /* Select comparison function */
   461→    GCompareFunc cmpfn;
   462→    if (integer) {
   463→        cmpfn = decreasing ? cmpIntDesc : cmpIntAsc;
   464→    } else if (real) {
   465→        cmpfn = decreasing ? cmpRealDesc : cmpRealAsc;
   466→    } else if (dictionary) {
   467→        cmpfn = decreasing ? cmpDictDesc : cmpDictAsc;
   468→    } else if (nocase) {
   469→        cmpfn = decreasing ? cmpStrNocaseDesc : cmpStrNocaseAsc;
   470→    } else {
   471→        cmpfn = decreasing ? cmpStrDesc : cmpStrAsc;
   472→    }
   473→
   474→    qsort(elems, listLen, sizeof(TclObj*), cmpfn);
   475→
   476→    /* Apply -unique if requested */
   477→    size_t resultLen = listLen;
   478→    if (unique && listLen > 1) {
   479→        /* Remove duplicates in-place - use same comparison for equality */
   480→        size_t writeIdx = 1;
   481→        for (size_t i = 1; i < listLen; i++) {
   482→            gboolean same = FALSE;
   483→            if (integer) {
   484→                int64_t a, b;
   485→                hostAsInt(elems[writeIdx-1], &a);
   486→                hostAsInt(elems[i], &b);
   487→                same = (a == b);
   488→            } else if (real) {
   489→                double a, b;
   490→                hostAsDouble(elems[writeIdx-1], &a);
   491→                hostAsDouble(elems[i], &b);
   492→                same = (a == b);
   493→            } else if (dictionary || nocase) {
   494→                size_t lenA, lenB;
   495→                const char *sa = hostGetStringPtr(elems[writeIdx-1], &lenA);
   496→                const char *sb = hostGetStringPtr(elems[i], &lenB);
   497→                same = (g_ascii_strcasecmp(sa, sb) == 0);
   498→            } else {
   499→                same = (hostStringCompare(elems[writeIdx-1], elems[i]) == 0);
   500→            }
   501→            if (!same) {
   502→                if (writeIdx != i) {
   503→                    hostFreeObj(elems[writeIdx]);
   504→                    elems[writeIdx] = elems[i];
   505→                    elems[i] = NULL;
   506→                }
   507→                writeIdx++;
   508→            } else {
   509→                hostFreeObj(elems[i]);
   510→                elems[i] = NULL;
   511→            }
   512→        }
   513→        resultLen = writeIdx;
   514→    }
   515→
   516→    TclObj *result = hostNewList(elems, resultLen);
   517→
   518→    /* Free remaining elements */
   519→    for (size_t i = 0; i < listLen; i++) {
   520→        if (elems[i]) hostFreeObj(elems[i]);
   521→    }
   522→    g_free(elems);
   523→    return result;
   524→}
   525→
   526→/* ========================================================================
   527→ * Dict Operations (stubs)
   528→ * ======================================================================== */
   529→
   530→static TclObj *hostDictGet(TclObj *dict, TclObj *key) {
   531→    (void)dict;
   532→    (void)key;
   533→    return NULL;
   534→}
   535→
   536→static TclObj *hostDictSet(TclObj *dict, TclObj *key, TclObj *val) {
   537→    (void)dict;
   538→    (void)key;
   539→    (void)val;
   540→    return NULL;
   541→}
   542→
   543→static int hostDictExists(TclObj *dict, TclObj *key) {
   544→    (void)dict;
   545→    (void)key;
   546→    return 0;
   547→}
   548→
   549→static TclObj *hostDictKeys(TclObj *dict, const char *pattern) {
   550→    (void)dict;
   551→    (void)pattern;
   552→    return hostNewString("", 0);
   553→}
   554→
   555→static TclObj *hostDictValues(TclObj *dict, const char *pattern) {
   556→    (void)dict;
   557→    (void)pattern;
   558→    return hostNewString("", 0);
   559→}
   560→
   561→static TclObj *hostDictRemove(TclObj *dict, TclObj *key) {
   562→    (void)dict;
   563→    (void)key;
   564→    return NULL;
   565→}
   566→
   567→static size_t hostDictSize(TclObj *dict) {
   568→    (void)dict;
   569→    return 0;
   570→}
   571→
   572→/* ========================================================================
   573→ * More String Operations (stubs)
   574→ * ======================================================================== */
   575→
   576→static TclObj *hostStringIndex(TclObj *str, size_t idx) {
   577→    (void)str;
   578→    (void)idx;
   579→    return hostNewString("", 0);
   580→}
   581→
   582→static TclObj *hostStringRange(TclObj *str, size_t first, size_t last) {
   583→    (void)str;
   584→    (void)first;
   585→    (void)last;
   586→    return hostNewString("", 0);
   587→}
   588→
   589→static TclObj *hostStringConcat(TclObj **parts, size_t count) {
   590→    (void)parts;
   591→    (void)count;
   592→    return hostNewString("", 0);
   593→}
   594→
   595→static int hostStringCompareNocase(TclObj *a, TclObj *b) {
   596→    if (!a && !b) return 0;
   597→    if (!a) return -1;
   598→    if (!b) return 1;
   599→    size_t lenA, lenB;
   600→    const char *sa = hostGetStringPtr(a, &lenA);
   601→    const char *sb = hostGetStringPtr(b, &lenB);
   602→    return g_ascii_strcasecmp(sa, sb);
   603→}
   604→
   605→/* Helper for glob pattern matching */
   606→static gboolean globMatch(const gchar *pat, gsize patLen, const gchar *str, gsize strLen, gboolean nocase) {
   607→    gsize p = 0, s = 0;
   608→    gsize starP = (gsize)-1, starS = (gsize)-1;
   609→
   610→    while (s < strLen) {
   611→        if (p < patLen && pat[p] == '*') {
   612→            /* Remember position for backtracking */
   613→            starP = p++;
   614→            starS = s;
   615→        } else if (p < patLen && pat[p] == '?') {
   616→            /* Match any single character */
   617→            p++;
   618→            s++;
   619→        } else if (p < patLen && pat[p] == '[') {
   620→            /* Character class */
   621→            p++;
   622→            gboolean invert = FALSE;
   623→            if (p < patLen && pat[p] == '!') {
   624→                invert = TRUE;
   625→                p++;
   626→            }
   627→            gboolean matched = FALSE;
   628→            gchar sc = nocase ? g_ascii_tolower(str[s]) : str[s];
   629→            while (p < patLen && pat[p] != ']') {
   630→                gchar c1 = nocase ? g_ascii_tolower(pat[p]) : pat[p];
   631→                if (p + 2 < patLen && pat[p + 1] == '-' && pat[p + 2] != ']') {
   632→                    gchar c2 = nocase ? g_ascii_tolower(pat[p + 2]) : pat[p + 2];
   633→                    if (sc >= c1 && sc <= c2) matched = TRUE;
   634→                    p += 3;
   635→                } else {
   636→                    if (sc == c1) matched = TRUE;
   637→                    p++;
   638→                }
   639→            }
   640→            if (p < patLen) p++; /* skip ] */
   641→            if (matched == invert) {
   642→                /* No match, try backtracking */
   643→                if (starP == (gsize)-1) return FALSE;
   644→                p = starP + 1;
   645→                s = ++starS;
   646→            } else {
   647→                s++;
   648→            }
   649→        } else if (p < patLen && pat[p] == '\\' && p + 1 < patLen) {
   650→            /* Escaped character */
   651→            p++;
   652→            gchar pc = pat[p];
   653→            gchar sc = str[s];
   654→            if (nocase) {
   655→                pc = g_ascii_tolower(pc);
   656→                sc = g_ascii_tolower(sc);
   657→            }
   658→            if (pc == sc) {
   659→                p++;
   660→                s++;
   661→            } else if (starP != (gsize)-1) {
   662→                p = starP + 1;
   663→                s = ++starS;
   664→            } else {
   665→                return FALSE;
   666→            }
   667→        } else if (p < patLen) {
   668→            /* Literal character */
   669→            gchar pc = pat[p];
   670→            gchar sc = str[s];
   671→            if (nocase) {
   672→                pc = g_ascii_tolower(pc);
   673→                sc = g_ascii_tolower(sc);
   674→            }
   675→            if (pc == sc) {
   676→                p++;
   677→                s++;
   678→            } else if (starP != (gsize)-1) {
   679→                p = starP + 1;
   680→                s = ++starS;
   681→            } else {
   682→                return FALSE;
   683→            }
   684→        } else if (starP != (gsize)-1) {
   685→            p = starP + 1;
   686→            s = ++starS;
   687→        } else {
   688→            return FALSE;
   689→        }
   690→    }
   691→
   692→    /* Skip trailing stars */
   693→    while (p < patLen && pat[p] == '*') p++;
   694→
   695→    return p == patLen;
   696→}
   697→
   698→static int hostStringMatch(const char *pattern, TclObj *str, int nocase) {
   699→    size_t strLen;
   700→    const char *strPtr = hostGetStringPtr(str, &strLen);
   701→    gsize patLen = strlen(pattern);
   702→    return globMatch(pattern, patLen, strPtr, strLen, nocase);
   703→}
   704→
   705→static TclObj *hostStringToLower(TclObj *str) {
   706→    (void)str;
   707→    return hostNewString("", 0);
   708→}
   709→
   710→static TclObj *hostStringToUpper(TclObj *str) {
   711→    (void)str;
   712→    return hostNewString("", 0);
   713→}
   714→
   715→static TclObj *hostStringTrim(TclObj *str, const char *chars) {
   716→    (void)str;
   717→    (void)chars;
   718→    return hostNewString("", 0);
   719→}
   720→
   721→static TclObj *hostStringReplace(TclObj *str, size_t first, size_t last, TclObj *rep) {
   722→    (void)str;
   723→    (void)first;
   724→    (void)last;
   725→    (void)rep;
   726→    return hostNewString("", 0);
   727→}
   728→
   729→static int hostStringFirst(TclObj *needle, TclObj *haystack, size_t start) {
   730→    (void)needle;
   731→    (void)haystack;
   732→    (void)start;
   733→    return -1;
   734→}
   735→
   736→static int hostStringLast(TclObj *needle, TclObj *haystack, size_t start) {
   737→    (void)needle;
   738→    (void)haystack;
   739→    (void)start;
   740→    return -1;
   741→}
   742→
   743→/* ========================================================================
   744→ * Trace Operations (stubs)
   745→ * ======================================================================== */
   746→
   747→static void hostTraceVarAdd(void *vars, const char *name, size_t len, int ops,
   748→                            TclTraceProc callback, void *clientData) {
   749→    (void)vars;
   750→    (void)name;
   751→    (void)len;
   752→    (void)ops;
   753→    (void)callback;
   754→    (void)clientData;
   755→}
   756→
   757→static void hostTraceVarRemove(void *vars, const char *name, size_t len,
   758→                               TclTraceProc callback, void *clientData) {
   759→    (void)vars;
   760→    (void)name;
   761→    (void)len;
   762→    (void)callback;
   763→    (void)clientData;
   764→}
   765→
   766→/* ========================================================================
   767→ * Event Loop (stubs)
   768→ * ======================================================================== */
   769→
   770→static TclTimerToken hostAfterMs(void *ctx, int ms, TclObj *script) {
   771→    (void)ctx;
   772→    (void)ms;
   773→    (void)script;
   774→    return NULL;
   775→}
   776→
   777→static TclTimerToken hostAfterIdle(void *ctx, TclObj *script) {
   778→    (void)ctx;
   779→    (void)script;
   780→    return NULL;
   781→}
   782→
   783→static void hostAfterCancel(void *ctx, TclTimerToken token) {
   784→    (void)ctx;
   785→    (void)token;
   786→}
   787→
   788→static TclObj *hostAfterInfo(void *ctx, TclTimerToken token) {
   789→    (void)ctx;
   790→    (void)token;
   791→    return hostNewString("", 0);
   792→}
   793→
   794→static void hostFileeventSet(void *ctx, TclChannel *chan, int mask, TclObj *script) {
   795→    (void)ctx;
   796→    (void)chan;
   797→    (void)mask;
   798→    (void)script;
   799→}
   800→
   801→static TclObj *hostFileeventGet(void *ctx, TclChannel *chan, int mask) {
   802→    (void)ctx;
   803→    (void)chan;
   804→    (void)mask;
   805→    return NULL;
   806→}
   807→
   808→static int hostDoOneEvent(void *ctx, int flags) {
   809→    (void)ctx;
   810→    (void)flags;
   811→    return 0;
   812→}
   813→
   814→/* ========================================================================
   815→ * Process/Socket/File stubs
   816→ * ======================================================================== */
   817→
   818→static TclProcess *hostProcessSpawn(const char **argv, int argc, int flags,
   819→                                    TclChannel **pipeIn, TclChannel **pipeOut,
   820→                                    TclChannel **pipeErr) {
   821→    (void)argv; (void)argc; (void)flags;
   822→    (void)pipeIn; (void)pipeOut; (void)pipeErr;
   823→    return NULL;
   824→}
   825→
   826→static int hostProcessWait(TclProcess *proc, int *exitCode) {
   827→    (void)proc; (void)exitCode;
   828→    return -1;
   829→}
   830→
   831→static int hostProcessPid(TclProcess *proc) {
   832→    (void)proc;
   833→    return -1;
   834→}
   835→
   836→static void hostProcessKill(TclProcess *proc, int signal) {
   837→    (void)proc; (void)signal;
   838→}
   839→
   840→static TclChannel *hostSocketOpen(const char *host, int port, int flags) {
   841→    (void)host; (void)port; (void)flags;
   842→    return NULL;
   843→}
   844→
   845→static void *hostSocketListen(const char *addr, int port,
   846→                              TclAcceptProc onAccept, void *clientData) {
   847→    (void)addr; (void)port; (void)onAccept; (void)clientData;
   848→    return NULL;
   849→}
   850→
   851→static void hostSocketListenClose(void *listener) {
   852→    (void)listener;
   853→}
   854→
   855→static int hostFileExists(const char *path) { (void)path; return 0; }
   856→static int hostFileIsFile(const char *path) { (void)path; return 0; }
   857→static int hostFileIsDir(const char *path) { (void)path; return 0; }
   858→static int hostFileReadable(const char *path) { (void)path; return 0; }
   859→static int hostFileWritable(const char *path) { (void)path; return 0; }
   860→static int hostFileExecutable(const char *path) { (void)path; return 0; }
   861→static int64_t hostFileSize(const char *path) { (void)path; return -1; }
   862→static int64_t hostFileMtime(const char *path) { (void)path; return -1; }
   863→static int64_t hostFileAtime(const char *path) { (void)path; return -1; }
   864→static int hostFileDelete(const char *path, int force) { (void)path; (void)force; return -1; }
   865→static int hostFileRename(const char *old, const char *new_, int force) {
   866→    (void)old; (void)new_; (void)force; return -1;
   867→}
   868→static int hostFileMkdir(const char *path) { (void)path; return -1; }
   869→static int hostFileCopy(const char *src, const char *dst, int force) {
   870→    (void)src; (void)dst; (void)force; return -1;
   871→}
   872→static TclObj *hostFileDirname(const char *path) { (void)path; return hostNewString("", 0); }
   873→static TclObj *hostFileTail(const char *path) { (void)path; return hostNewString("", 0); }
   874→static TclObj *hostFileExtension(const char *path) { (void)path; return hostNewString("", 0); }
   875→static TclObj *hostFileRootname(const char *path) { (void)path; return hostNewString("", 0); }
   876→static TclObj *hostFileJoin(TclObj **parts, size_t count) { (void)parts; (void)count; return hostNewString("", 0); }
   877→static TclObj *hostFileNormalize(const char *path) { (void)path; return hostNewString("", 0); }
   878→static TclObj *hostFileSplit(const char *path) { (void)path; return hostNewString("", 0); }
   879→static TclObj *hostFileType(const char *path) { (void)path; return hostNewString("", 0); }
   880→static TclObj *hostGlob(const char *pattern, int types, const char *dir) {
   881→    (void)pattern; (void)types; (void)dir; return hostNewString("", 0);
   882→}
   883→
   884→static int hostChdir(const char *path) { (void)path; return -1; }
   885→static TclObj *hostGetcwd(void) { return hostNewString("", 0); }
   886→static TclObj *hostSysHostname(void) { return hostNewString("", 0); }
   887→static TclObj *hostSysExecutable(void) { return hostNewString("", 0); }
   888→static int hostSysPid(void) { return 0; }
   889→
   890→static TclObj *hostRegexMatch(const char *pat, size_t patLen, TclObj *str, int flags) {
   891→    (void)pat; (void)patLen; (void)str; (void)flags; return NULL;
   892→}
   893→static TclObj *hostRegexSubst(const char *pat, size_t patLen, TclObj *str, TclObj *rep, int flags) {
   894→    (void)pat; (void)patLen; (void)str; (void)rep; (void)flags; return NULL;
   895→}
   896→
   897→static int64_t hostClockSeconds(void) { return 0; }
   898→static int64_t hostClockMillis(void) { return 0; }
   899→static int64_t hostClockMicros(void) { return 0; }
   900→static TclObj *hostClockFormat(int64_t time, const char *fmt, const char *tz) {
   901→    (void)time; (void)fmt; (void)tz; return hostNewString("", 0);
   902→}
   903→static int64_t hostClockScan(const char *str, const char *fmt, const char *tz) {
   904→    (void)str; (void)fmt; (void)tz; return 0;
   905→}
   906→
   907→static TclObj *hostEncodingConvertTo(const char *enc, TclObj *str) {
   908→    (void)enc; (void)str; return NULL;
   909→}
   910→static TclObj *hostEncodingConvertFrom(const char *enc, TclObj *bytes) {
   911→    (void)enc; (void)bytes; return NULL;
   912→}
   913→static TclObj *hostEncodingNames(void) { return hostNewString("", 0); }
   914→static const char *hostEncodingSystem(void) { return "utf-8"; }
   915→
   916→/* ========================================================================
   917→ * The TclHost Callback Table
   918→ * ======================================================================== */
   919→
   920→const TclHost cHost = {
   921→    /* Context */
   922→    .interpContextNew = hostInterpContextNew,
   923→    .interpContextFree = hostInterpContextFree,
   924→
   925→    /* Frames */
   926→    .frameAlloc = hostFrameAlloc,
   927→    .frameFree = hostFrameFree,
   928→
   929→    /* Objects */
   930→    .newString = hostNewString,
   931→    .newInt = hostNewInt,
   932→    .newDouble = hostNewDouble,
   933→    .newBool = hostNewBool,
   934→    .newList = hostNewList,
   935→    .newDict = hostNewDict,
   936→    .dup = hostDup,
   937→    .getStringPtr = hostGetStringPtr,
   938→    .asInt = hostAsInt,
   939→    .asDouble = hostAsDouble,
   940→    .asBool = hostAsBool,
   941→    .asList = hostAsList,
   942→
   943→    /* Lists */
   944→    .listLength = hostListLength,
   945→    .listIndex = hostListIndex,
   946→    .listRange = hostListRange,
   947→    .listSet = hostListSet,
   948→    .listAppend = hostListAppend,
   949→    .listConcat = hostListConcat,
   950→    .listInsert = hostListInsert,
   951→    .listSort = hostListSort,
   952→
   953→    /* Dicts */
   954→    .dictGet = hostDictGet,
   955→    .dictSet = hostDictSet,
   956→    .dictExists = hostDictExists,
   957→    .dictKeys = hostDictKeys,
   958→    .dictValues = hostDictValues,
   959→    .dictRemove = hostDictRemove,
   960→    .dictSize = hostDictSize,
   961→
   962→    /* Strings */
   963→    .stringLength = hostStringLength,
   964→    .stringIndex = hostStringIndex,
   965→    .stringRange = hostStringRange,
   966→    .stringConcat = hostStringConcat,
   967→    .stringCompare = hostStringCompare,
   968→    .stringCompareNocase = hostStringCompareNocase,
   969→    .stringMatch = hostStringMatch,
   970→    .stringToLower = hostStringToLower,
   971→    .stringToUpper = hostStringToUpper,
   972→    .stringTrim = hostStringTrim,
   973→    .stringReplace = hostStringReplace,
   974→    .stringFirst = hostStringFirst,
   975→    .stringLast = hostStringLast,
   976→
   977→    /* Arena */
   978→    .arenaPush = hostArenaPush,
   979→    .arenaPop = hostArenaPop,
   980→    .arenaAlloc = hostArenaAlloc,
   981→    .arenaStrdup = hostArenaStrdup,
   982→    .arenaMark = hostArenaMark,
   983→    .arenaReset = hostArenaReset,
   984→
   985→    /* Variables */
   986→    .varsNew = hostVarsNew,
   987→    .varsFree = hostVarsFree,
   988→    .varGet = hostVarGet,
   989→    .varSet = hostVarSet,
   990→    .varUnset = hostVarUnset,
   991→    .varExists = hostVarExists,
   992→    .varNames = hostVarNames,
   993→    .varLink = hostVarLink,
   994→
   995→    /* Arrays */
   996→    .arraySet = hostArraySet,
   997→    .arrayGet = hostArrayGet,
   998→    .arrayExists = hostArrayExists,
   999→    .arrayNames = hostArrayNames,
  1000→    .arrayUnset = hostArrayUnset,
  1001→    .arraySize = hostArraySize,
  1002→
  1003→    /* Traces */
  1004→    .traceVarAdd = hostTraceVarAdd,
  1005→    .traceVarRemove = hostTraceVarRemove,
  1006→
  1007→    /* Commands */
  1008→    .cmdLookup = hostCmdLookup,
  1009→    .procRegister = hostProcRegister,
  1010→    .procGetDef = hostProcGetDef,
  1011→    .extInvoke = hostExtInvoke,
  1012→    .cmdRename = hostCmdRename,
  1013→    .cmdDelete = hostCmdDelete,
  1014→    .cmdExists = hostCmdExists,
  1015→    .cmdList = hostCmdList,
  1016→    .cmdHide = hostCmdHide,
  1017→    .cmdExpose = hostCmdExpose,
  1018→
  1019→    /* Channels */
  1020→    .chanOpen = hostChanOpen,
  1021→    .chanClose = hostChanClose,
  1022→    .chanStdin = hostChanStdin,
  1023→    .chanStdout = hostChanStdout,
  1024→    .chanStderr = hostChanStderr,
  1025→    .chanRead = hostChanRead,
  1026→    .chanWrite = hostChanWrite,
  1027→    .chanGets = hostChanGets,
  1028→    .chanFlush = hostChanFlush,
  1029→    .chanSeek = hostChanSeek,
  1030→    .chanTell = hostChanTell,
  1031→    .chanEof = hostChanEof,
  1032→    .chanBlocked = hostChanBlocked,
  1033→    .chanConfigure = hostChanConfigure,
  1034→    .chanCget = hostChanCget,
  1035→    .chanNames = hostChanNames,
  1036→    .chanShare = hostChanShare,
  1037→    .chanTransfer = hostChanTransfer,
  1038→
  1039→    /* Event loop */
  1040→    .afterMs = hostAfterMs,
  1041→    .afterIdle = hostAfterIdle,
  1042→    .afterCancel = hostAfterCancel,
  1043→    .afterInfo = hostAfterInfo,
  1044→    .fileeventSet = hostFileeventSet,
  1045→    .fileeventGet = hostFileeventGet,
  1046→    .doOneEvent = hostDoOneEvent,
  1047→
  1048→    /* Process */
  1049→    .processSpawn = hostProcessSpawn,
  1050→    .processWait = hostProcessWait,
  1051→    .processPid = hostProcessPid,
  1052→    .processKill = hostProcessKill,
  1053→
  1054→    /* Sockets */
  1055→    .socketOpen = hostSocketOpen,
  1056→    .socketListen = hostSocketListen,
  1057→    .socketListenClose = hostSocketListenClose,
  1058→
  1059→    /* Filesystem */
  1060→    .fileExists = hostFileExists,
  1061→    .fileIsFile = hostFileIsFile,
  1062→    .fileIsDir = hostFileIsDir,
  1063→    .fileReadable = hostFileReadable,
  1064→    .fileWritable = hostFileWritable,
  1065→    .fileExecutable = hostFileExecutable,
  1066→    .fileSize = hostFileSize,
  1067→    .fileMtime = hostFileMtime,
  1068→    .fileAtime = hostFileAtime,
  1069→    .fileDelete = hostFileDelete,
  1070→    .fileRename = hostFileRename,
  1071→    .fileMkdir = hostFileMkdir,
  1072→    .fileCopy = hostFileCopy,
  1073→    .fileDirname = hostFileDirname,
  1074→    .fileTail = hostFileTail,
  1075→    .fileExtension = hostFileExtension,
  1076→    .fileRootname = hostFileRootname,
  1077→    .fileJoin = hostFileJoin,
  1078→    .fileNormalize = hostFileNormalize,
  1079→    .fileSplit = hostFileSplit,
  1080→    .fileType = hostFileType,
  1081→    .glob = hostGlob,
  1082→
  1083→    /* System */
  1084→    .chdir = hostChdir,
  1085→    .getcwd = hostGetcwd,
  1086→    .sysHostname = hostSysHostname,
  1087→    .sysExecutable = hostSysExecutable,
  1088→    .sysPid = hostSysPid,
  1089→
  1090→    /* Regex */
  1091→    .regexMatch = hostRegexMatch,
  1092→    .regexSubst = hostRegexSubst,
  1093→
  1094→    /* Clock */
  1095→    .clockSeconds = hostClockSeconds,
  1096→    .clockMillis = hostClockMillis,
  1097→    .clockMicros = hostClockMicros,
  1098→    .clockFormat = hostClockFormat,
  1099→    .clockScan = hostClockScan,
  1100→
  1101→    /* Encoding */
  1102→    .encodingConvertTo = hostEncodingConvertTo,
  1103→    .encodingConvertFrom = hostEncodingConvertFrom,
  1104→    .encodingNames = hostEncodingNames,
  1105→    .encodingSystem = hostEncodingSystem,
  1106→};
  1107→
  1108→/* Export the host table */
  1109→const TclHost *tclGetCHost(void) {
  1110→    return &cHost;
  1111→}
  1112→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
