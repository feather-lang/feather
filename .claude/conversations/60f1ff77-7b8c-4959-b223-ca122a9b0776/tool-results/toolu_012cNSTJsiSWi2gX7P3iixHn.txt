The file /Users/dhamidi/projects/tclc/core/builtins.c has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
  1158→    tclSetError(interp, "unknown or ambiguous subcommand", -1);
  1159→    return TCL_ERROR;
  1160→}
  1161→
  1162→/* ========================================================================
  1163→ * info Command
  1164→ * ======================================================================== */
  1165→
  1166→/* Helper: look up procedure and get argList/body, returns 0 on success */
  1167→static int infoProcLookup(TclInterp *interp, TclObj *nameObj, TclObj **argListOut, TclObj **bodyOut) {
  1168→    const TclHost *host = interp->host;
  1169→    size_t nameLen;
  1170→    const char *name = host->getStringPtr(nameObj, &nameLen);
  1171→
  1172→    TclCmdInfo info;
  1173→    if (!host->cmdLookup(interp->hostCtx, name, nameLen, &info)) {
  1174→        return -1;
  1175→    }
  1176→    if (info.type != TCL_CMD_PROC) {
  1177→        return -1;
  1178→    }
  1179→    if (host->procGetDef(info.u.procHandle, argListOut, bodyOut) != 0) {
  1180→        return -1;
  1181→    }
  1182→    return 0;
  1183→}
  1184→
  1185→/* Helper: match a glob pattern against a string */
  1186→static int infoGlobMatch(const char *pattern, const char *str, size_t strLen) {
  1187→    /* Simple glob matching - only supports * at start/end */
  1188→    if (!pattern) return 1;  /* NULL pattern matches all */
  1189→
  1190→    size_t patLen = 0;
  1191→    const char *p = pattern;
  1192→    while (*p) { patLen++; p++; }
  1193→
  1194→    if (patLen == 0) return 1;  /* Empty pattern matches all */
  1195→
  1196→    /* Check for wildcard at end */
  1197→    if (pattern[patLen - 1] == '*') {
  1198→        /* Prefix match */
  1199→        size_t prefixLen = patLen - 1;
  1200→        if (strLen < prefixLen) return 0;
  1201→        for (size_t i = 0; i < prefixLen; i++) {
  1202→            if (pattern[i] != str[i]) return 0;
  1203→        }
  1204→        return 1;
  1205→    }
  1206→
  1207→    /* Exact match */
  1208→    if (strLen != patLen) return 0;
  1209→    for (size_t i = 0; i < patLen; i++) {
  1210→        if (pattern[i] != str[i]) return 0;
  1211→    }
  1212→    return 1;
  1213→}
  1214→
  1215→TclResult tclCmdInfo(TclInterp *interp, int objc, TclObj **objv) {
  1216→    const TclHost *host = interp->host;
  1217→
  1218→    if (objc < 2) {
  1219→        tclSetError(interp, "wrong # args: should be \"info subcommand ?arg ...?\"", -1);
  1220→        return TCL_ERROR;
  1221→    }
  1222→
  1223→    size_t subcmdLen;
  1224→    const char *subcmd = host->getStringPtr(objv[1], &subcmdLen);
  1225→
  1226→    /* info exists varName */
  1227→    if (subcmdLen == 6 && tclStrncmp(subcmd, "exists", 6) == 0) {
  1228→        if (objc != 3) {
  1229→            tclSetError(interp, "wrong # args: should be \"info exists varName\"", -1);
  1230→            return TCL_ERROR;
  1231→        }
  1232→        size_t nameLen;
  1233→        const char *name = host->getStringPtr(objv[2], &nameLen);
  1234→
  1235→        /* Handle :: prefix for global variables */
  1236→        int forceGlobal = 0;
  1237→        if (nameLen >= 2 && name[0] == ':' && name[1] == ':') {
  1238→            name += 2;
  1239→            nameLen -= 2;
  1240→            forceGlobal = 1;
  1241→        }
  1242→
  1243→        void *vars = forceGlobal ? interp->globalFrame->varsHandle : interp->currentFrame->varsHandle;
  1244→
  1245→        /* Check for scalar variable */
  1246→        int exists = host->varExists(vars, name, nameLen);
  1247→
  1248→        /* Also check for array (without subscript) */
  1249→        if (!exists) {
  1250→            size_t arrayCount = host->arraySize(vars, name, nameLen);
  1251→            exists = (arrayCount > 0);
  1252→        }
  1253→
  1254→        /* Check global frame if not found and not already forced global */
  1255→        if (!exists && !forceGlobal && interp->currentFrame != interp->globalFrame) {
  1256→            exists = host->varExists(interp->globalFrame->varsHandle, name, nameLen);
  1257→            if (!exists) {
  1258→                size_t arrayCount = host->arraySize(interp->globalFrame->varsHandle, name, nameLen);
  1259→                exists = (arrayCount > 0);
  1260→            }
  1261→        }
  1262→
  1263→        tclSetResult(interp, host->newInt(exists ? 1 : 0));
  1264→        return TCL_OK;
  1265→    }
  1266→
  1267→    /* info args procName */
  1268→    if (subcmdLen == 4 && tclStrncmp(subcmd, "args", 4) == 0) {
  1269→        if (objc != 3) {
  1270→            tclSetError(interp, "wrong # args: should be \"info args procname\"", -1);
  1271→            return TCL_ERROR;
  1272→        }
  1273→
  1274→        TclObj *argList, *body;
  1275→        if (infoProcLookup(interp, objv[2], &argList, &body) != 0) {
  1276→            /* Build error message: "procname" isn't a procedure */
  1277→            size_t nameLen;
  1278→            const char *name = host->getStringPtr(objv[2], &nameLen);
  1279→            void *arena = host->arenaPush(interp->hostCtx);
  1280→            char *msg = host->arenaAlloc(arena, nameLen + 30, 1);
  1281→            char *p = msg;
  1282→            *p++ = '"';
  1283→            for (size_t i = 0; i < nameLen; i++) *p++ = name[i];
  1284→            *p++ = '"';
  1285→            const char *suffix = " isn't a procedure";
  1286→            while (*suffix) *p++ = *suffix++;
  1287→            *p = '\0';
  1288→            tclSetError(interp, msg, p - msg);
  1289→            host->arenaPop(interp->hostCtx, arena);
  1290→            return TCL_ERROR;
  1291→        }
  1292→
  1293→        /* Parse argList and extract just the argument names */
  1294→        TclObj **args;
  1295→        size_t argCount;
  1296→        if (host->asList(argList, &args, &argCount) != 0) {
  1297→            tclSetResult(interp, host->newString("", 0));
  1298→            return TCL_OK;
  1299→        }
  1300→
  1301→        /* Build result list with just argument names */
  1302→        void *arena = host->arenaPush(interp->hostCtx);
  1303→        TclObj **names = host->arenaAlloc(arena, argCount * sizeof(TclObj*), sizeof(void*));
  1304→
  1305→        for (size_t i = 0; i < argCount; i++) {
  1306→            /* Each arg might be a list {name default} or just a name */
  1307→            TclObj **argParts;
  1308→            size_t partCount;
  1309→            if (host->asList(args[i], &argParts, &partCount) == 0 && partCount >= 1) {
  1310→                names[i] = argParts[0];  /* First element is the name */
  1311→            } else {
  1312→                names[i] = args[i];  /* Use whole thing as name */
  1313→            }
  1314→        }
  1315→
  1316→        TclObj *result = host->newList(names, argCount);
  1317→        host->arenaPop(interp->hostCtx, arena);
  1318→
  1319→        /* Convert list to space-separated string for output */
  1320→        size_t resultLen;
  1321→        const char *resultStr = host->getStringPtr(result, &resultLen);
  1322→        tclSetResult(interp, host->newString(resultStr, resultLen));
  1323→        return TCL_OK;
  1324→    }
  1325→
  1326→    /* info body procName */
  1327→    if (subcmdLen == 4 && tclStrncmp(subcmd, "body", 4) == 0) {
  1328→        if (objc != 3) {
  1329→            tclSetError(interp, "wrong # args: should be \"info body procname\"", -1);
  1330→            return TCL_ERROR;
  1331→        }
  1332→
  1333→        TclObj *argList, *body;
  1334→        if (infoProcLookup(interp, objv[2], &argList, &body) != 0) {
  1335→            /* Build error message: "procname" isn't a procedure */
  1336→            size_t nameLen;
  1337→            const char *name = host->getStringPtr(objv[2], &nameLen);
  1338→            void *arena = host->arenaPush(interp->hostCtx);
  1339→            char *msg = host->arenaAlloc(arena, nameLen + 30, 1);
  1340→            char *p = msg;
  1341→            *p++ = '"';
  1342→            for (size_t i = 0; i < nameLen; i++) *p++ = name[i];
  1343→            *p++ = '"';
  1344→            const char *suffix = " isn't a procedure";
  1345→            while (*suffix) *p++ = *suffix++;
  1346→            *p = '\0';
  1347→            tclSetError(interp, msg, p - msg);
  1348→            host->arenaPop(interp->hostCtx, arena);
  1349→            return TCL_ERROR;
  1350→        }
  1351→
  1352→        tclSetResult(interp, host->dup(body));
  1353→        return TCL_OK;
  1354→    }
  1355→
  1356→    /* info commands ?pattern? */
  1357→    if (subcmdLen == 8 && tclStrncmp(subcmd, "commands", 8) == 0) {
  1358→        if (objc > 3) {
  1359→            tclSetError(interp, "wrong # args: should be \"info commands ?pattern?\"", -1);
  1360→            return TCL_ERROR;
  1361→        }
  1362→
  1363→        const char *pattern = NULL;
  1364→        if (objc == 3) {
  1365→            size_t patLen;
  1366→            pattern = host->getStringPtr(objv[2], &patLen);
  1367→        }
  1368→
  1369→        TclObj *cmdList = host->cmdList(interp->hostCtx, pattern);
  1370→        tclSetResult(interp, cmdList ? cmdList : host->newString("", 0));
  1371→        return TCL_OK;
  1372→    }
  1373→
  1374→    /* info complete string */
  1375→    if (subcmdLen == 8 && tclStrncmp(subcmd, "complete", 8) == 0) {
  1376→        if (objc != 3) {
  1377→            tclSetError(interp, "wrong # args: should be \"info complete command\"", -1);
  1378→            return TCL_ERROR;
  1379→        }
  1380→
  1381→        size_t strLen;
  1382→        const char *str = host->getStringPtr(objv[2], &strLen);
  1383→
  1384→        /* Check if the string is a complete TCL command */
  1385→        /* A command is complete if all braces, brackets, and quotes are balanced */
  1386→        int braceDepth = 0;
  1387→        int bracketDepth = 0;
  1388→        int inQuote = 0;
  1389→        int complete = 1;
  1390→
  1391→        const char *p = str;
  1392→        const char *end = str + strLen;
  1393→
  1394→        while (p < end) {
  1395→            if (*p == '\\' && p + 1 < end) {
  1396→                p += 2;  /* Skip escaped character */
  1397→                continue;
  1398→            }
  1399→
  1400→            if (inQuote) {
  1401→                if (*p == '"') {
  1402→                    inQuote = 0;
  1403→                }
  1404→            } else if (braceDepth > 0) {
  1405→                if (*p == '{') {
  1406→                    braceDepth++;
  1407→                } else if (*p == '}') {
  1408→                    braceDepth--;
  1409→                }
  1410→            } else {
  1411→                if (*p == '"') {
  1412→                    inQuote = 1;
  1413→                } else if (*p == '{') {
  1414→                    braceDepth++;
  1415→                } else if (*p == '[') {
  1416→                    bracketDepth++;
  1417→                } else if (*p == ']') {
  1418→                    if (bracketDepth > 0) {
  1419→                        bracketDepth--;
  1420→                    }
  1421→                }
  1422→            }
  1423→            p++;
  1424→        }
  1425→
  1426→        /* Complete if all are balanced */
  1427→        complete = (braceDepth == 0 && bracketDepth == 0 && !inQuote);
  1428→
  1429→        tclSetResult(interp, host->newInt(complete ? 1 : 0));
  1430→        return TCL_OK;
  1431→    }
  1432→
  1433→    /* info default procName arg varName */
  1434→    if (subcmdLen == 7 && tclStrncmp(subcmd, "default", 7) == 0) {
  1435→        if (objc != 5) {
  1436→            tclSetError(interp, "wrong # args: should be \"info default procname arg varname\"", -1);
  1437→            return TCL_ERROR;
  1438→        }
  1439→
  1440→        TclObj *argList, *body;
  1441→        if (infoProcLookup(interp, objv[2], &argList, &body) != 0) {
  1442→            /* Build error message: "procname" isn't a procedure */
  1443→            size_t nameLen;
  1444→            const char *name = host->getStringPtr(objv[2], &nameLen);
  1445→            void *arena = host->arenaPush(interp->hostCtx);
  1446→            char *msg = host->arenaAlloc(arena, nameLen + 30, 1);
  1447→            char *p = msg;
  1448→            *p++ = '"';
  1449→            for (size_t i = 0; i < nameLen; i++) *p++ = name[i];
  1450→            *p++ = '"';
  1451→            const char *suffix = " isn't a procedure";
  1452→            while (*suffix) *p++ = *suffix++;
  1453→            *p = '\0';
  1454→            tclSetError(interp, msg, p - msg);
  1455→            host->arenaPop(interp->hostCtx, arena);
  1456→            return TCL_ERROR;
  1457→        }
  1458→
  1459→        /* Get the argument name we're looking for */
  1460→        size_t targetArgLen;
  1461→        const char *targetArg = host->getStringPtr(objv[3], &targetArgLen);
  1462→
  1463→        /* Get the variable name to store the default */
  1464→        size_t varNameLen;
  1465→        const char *varName = host->getStringPtr(objv[4], &varNameLen);
  1466→
  1467→        /* Parse argList */
  1468→        TclObj **args;
  1469→        size_t argCount;
  1470→        if (host->asList(argList, &args, &argCount) != 0) {
  1471→            /* Build error message */
  1472→            void *arena = host->arenaPush(interp->hostCtx);
  1473→            size_t procNameLen;
  1474→            const char *procName = host->getStringPtr(objv[2], &procNameLen);
  1475→            char *msg = host->arenaAlloc(arena, procNameLen + targetArgLen + 60, 1);
  1476→            char *mp = msg;
  1477→            const char *pre = "procedure \"";
  1478→            while (*pre) *mp++ = *pre++;
  1479→            for (size_t i = 0; i < procNameLen; i++) *mp++ = procName[i];
  1480→            const char *mid = "\" doesn't have an argument \"";
  1481→            while (*mid) *mp++ = *mid++;
  1482→            for (size_t i = 0; i < targetArgLen; i++) *mp++ = targetArg[i];
  1483→            *mp++ = '"';
  1484→            *mp = '\0';
  1485→            tclSetError(interp, msg, mp - msg);
  1486→            host->arenaPop(interp->hostCtx, arena);
  1487→            return TCL_ERROR;
  1488→        }
  1489→
  1490→        /* Find the argument */
  1491→        int found = 0;
  1492→        int hasDefault = 0;
  1493→        TclObj *defaultValue = NULL;
  1494→
  1495→        for (size_t i = 0; i < argCount; i++) {
  1496→            TclObj **argParts;
  1497→            size_t partCount;
  1498→            const char *argName;
  1499→            size_t argNameLen;
  1500→
  1501→            if (host->asList(args[i], &argParts, &partCount) == 0 && partCount >= 1) {
  1502→                argName = host->getStringPtr(argParts[0], &argNameLen);
  1503→                if (argNameLen == targetArgLen && tclStrncmp(argName, targetArg, targetArgLen) == 0) {
  1504→                    found = 1;
  1505→                    if (partCount >= 2) {
  1506→                        hasDefault = 1;
  1507→                        defaultValue = argParts[1];
  1508→                    }
  1509→                    break;
  1510→                }
  1511→            } else {
  1512→                argName = host->getStringPtr(args[i], &argNameLen);
  1513→                if (argNameLen == targetArgLen && tclStrncmp(argName, targetArg, targetArgLen) == 0) {
  1514→                    found = 1;
  1515→                    break;
  1516→                }
  1517→            }
  1518→        }
  1519→
  1520→        if (!found) {
  1521→            /* Build error message */
  1522→            void *arena = host->arenaPush(interp->hostCtx);
  1523→            size_t procNameLen;
  1524→            const char *procName = host->getStringPtr(objv[2], &procNameLen);
  1525→            char *msg = host->arenaAlloc(arena, procNameLen + targetArgLen + 60, 1);
  1526→            char *mp = msg;
  1527→            const char *pre = "procedure \"";
  1528→            while (*pre) *mp++ = *pre++;
  1529→            for (size_t i = 0; i < procNameLen; i++) *mp++ = procName[i];
  1530→            const char *mid = "\" doesn't have an argument \"";
  1531→            while (*mid) *mp++ = *mid++;
  1532→            for (size_t i = 0; i < targetArgLen; i++) *mp++ = targetArg[i];
  1533→            *mp++ = '"';
  1534→            *mp = '\0';
  1535→            tclSetError(interp, msg, mp - msg);
  1536→            host->arenaPop(interp->hostCtx, arena);
  1537→            return TCL_ERROR;
  1538→        }
  1539→
  1540→        /* Set the variable with the default value if there is one */
  1541→        if (hasDefault) {
  1542→            void *vars = interp->currentFrame->varsHandle;
  1543→            host->varSet(vars, varName, varNameLen, host->dup(defaultValue));
  1544→            tclSetResult(interp, host->newInt(1));
  1545→        } else {
  1546→            tclSetResult(interp, host->newInt(0));
  1547→        }
  1548→        return TCL_OK;
  1549→    }
  1550→
  1551→    /* info globals ?pattern? */
  1552→    if (subcmdLen == 7 && tclStrncmp(subcmd, "globals", 7) == 0) {
  1553→        if (objc > 3) {
  1554→            tclSetError(interp, "wrong # args: should be \"info globals ?pattern?\"", -1);
  1555→            return TCL_ERROR;
  1556→        }
  1557→
  1558→        const char *pattern = NULL;
  1559→        if (objc == 3) {
  1560→            size_t patLen;
  1561→            pattern = host->getStringPtr(objv[2], &patLen);
  1562→        }
  1563→
  1564→        TclObj *names = host->varNames(interp->globalFrame->varsHandle, pattern);
  1565→        tclSetResult(interp, names ? names : host->newString("", 0));
  1566→        return TCL_OK;
  1567→    }
  1568→
  1569→    /* info level ?number? */
  1570→    if (subcmdLen == 5 && tclStrncmp(subcmd, "level", 5) == 0) {
  1571→        if (objc > 3) {
  1572→            tclSetError(interp, "wrong # args: should be \"info level ?number?\"", -1);
  1573→            return TCL_ERROR;
  1574→        }
  1575→
  1576→        if (objc == 2) {
  1577→            /* Return current level */
  1578→            tclSetResult(interp, host->newInt((int64_t)interp->currentFrame->level));
  1579→            return TCL_OK;
  1580→        }
  1581→
  1582→        /* Get information about a specific level */
  1583→        int64_t levelNum;
  1584→        if (host->asInt(objv[2], &levelNum) != 0) {
  1585→            tclSetError(interp, "expected integer but got non-integer value", -1);
  1586→            return TCL_ERROR;
  1587→        }
  1588→
  1589→        /* Handle negative levels (relative) */
  1590→        int targetLevel;
  1591→        if (levelNum < 0) {
  1592→            targetLevel = (int)interp->currentFrame->level + (int)levelNum;
  1593→        } else {
  1594→            targetLevel = (int)levelNum;
  1595→        }
  1596→
  1597→        if (targetLevel < 0 || targetLevel > (int)interp->currentFrame->level) {
  1598→            tclSetError(interp, "bad level", -1);
  1599→            return TCL_ERROR;
  1600→        }
  1601→
  1602→        /* Find the frame at the target level */
  1603→        TclFrame *frame = interp->currentFrame;
  1604→        while (frame && (int)frame->level > targetLevel) {
  1605→            frame = frame->parent;
  1606→        }
  1607→
  1608→        if (!frame || (int)frame->level != targetLevel) {
  1609→            tclSetError(interp, "bad level", -1);
  1610→            return TCL_ERROR;
  1611→        }
  1612→
  1613→        /* Return the proc name (command invocation) at that level */
  1614→        if (frame->procName) {
  1615→            tclSetResult(interp, host->newString(frame->procName, tclStrlen(frame->procName)));
  1616→        } else {
  1617→            tclSetResult(interp, host->newString("", 0));
  1618→        }
  1619→        return TCL_OK;
  1620→    }
  1621→
  1622→    /* info locals ?pattern? */
  1623→    if (subcmdLen == 6 && tclStrncmp(subcmd, "locals", 6) == 0) {
  1624→        if (objc > 3) {
  1625→            tclSetError(interp, "wrong # args: should be \"info locals ?pattern?\"", -1);
  1626→            return TCL_ERROR;
  1627→        }
  1628→
  1629→        /* At global level, return empty */
  1630→        if (interp->currentFrame == interp->globalFrame) {
  1631→            tclSetResult(interp, host->newString("", 0));
  1632→            return TCL_OK;
  1633→        }
  1634→
  1635→        const char *pattern = NULL;
  1636→        if (objc == 3) {
  1637→            size_t patLen;
  1638→            pattern = host->getStringPtr(objv[2], &patLen);
  1639→        }
  1640→
  1641→        TclObj *names = host->varNames(interp->currentFrame->varsHandle, pattern);
  1642→        tclSetResult(interp, names ? names : host->newString("", 0));
  1643→        return TCL_OK;
  1644→    }
  1645→
  1646→    /* info procs ?pattern? */
  1647→    if (subcmdLen == 5 && tclStrncmp(subcmd, "procs", 5) == 0) {
  1648→        if (objc > 3) {
  1649→            tclSetError(interp, "wrong # args: should be \"info procs ?pattern?\"", -1);
  1650→            return TCL_ERROR;
  1651→        }
  1652→
  1653→        const char *pattern = NULL;
  1654→        if (objc == 3) {
  1655→            size_t patLen;
  1656→            pattern = host->getStringPtr(objv[2], &patLen);
  1657→        }
  1658→
  1659→        /* Get all commands, then filter for procs */
  1660→        TclObj *allCmds = host->cmdList(interp->hostCtx, pattern);
  1661→        if (!allCmds) {
  1662→            tclSetResult(interp, host->newString("", 0));
  1663→            return TCL_OK;
  1664→        }
  1665→
  1666→        TclObj **cmds;
  1667→        size_t cmdCount;
  1668→        if (host->asList(allCmds, &cmds, &cmdCount) != 0 || cmdCount == 0) {
  1669→            tclSetResult(interp, host->newString("", 0));
  1670→            return TCL_OK;
  1671→        }
  1672→
  1673→        /* Filter for procs only */
  1674→        void *arena = host->arenaPush(interp->hostCtx);
  1675→        TclObj **procs = host->arenaAlloc(arena, cmdCount * sizeof(TclObj*), sizeof(void*));
  1676→        size_t procCount = 0;
  1677→
  1678→        for (size_t i = 0; i < cmdCount; i++) {
  1679→            size_t nameLen;
  1680→            const char *name = host->getStringPtr(cmds[i], &nameLen);
  1681→            TclCmdInfo info;
  1682→            if (host->cmdLookup(interp->hostCtx, name, nameLen, &info) && info.type == TCL_CMD_PROC) {
  1683→                procs[procCount++] = cmds[i];
  1684→            }
  1685→        }
  1686→
  1687→        TclObj *result = host->newList(procs, procCount);
  1688→        host->arenaPop(interp->hostCtx, arena);
  1689→        tclSetResult(interp, result);
  1690→        return TCL_OK;
  1691→    }
  1692→
  1693→    /* info vars ?pattern? */
  1694→    if (subcmdLen == 4 && tclStrncmp(subcmd, "vars", 4) == 0) {
  1695→        if (objc > 3) {
  1696→            tclSetError(interp, "wrong # args: should be \"info vars ?pattern?\"", -1);
  1697→            return TCL_ERROR;
  1698→        }
  1699→
  1700→        const char *pattern = NULL;
  1701→        if (objc == 3) {
  1702→            size_t patLen;
  1703→            pattern = host->getStringPtr(objv[2], &patLen);
  1704→        }
  1705→
  1706→        TclObj *names = host->varNames(interp->currentFrame->varsHandle, pattern);
  1707→        tclSetResult(interp, names ? names : host->newString("", 0));
  1708→        return TCL_OK;
  1709→    }
  1710→
  1711→    tclSetError(interp, "unknown or ambiguous subcommand \"unknown\": must be args, body, class, cmdcount, cmdtype, commands, complete, constant, consts, coroutine, default, errorstack, exists, frame, functions, globals, hostname, level, library, loaded, locals, nameofexecutable, object, patchlevel, procs, script, sharedlibextension, tclversion, or vars", -1);
  1712→    return TCL_ERROR;
  1713→}
  1714→
  1715→/* ========================================================================
  1716→ * error Command
  1717→ * ======================================================================== */