     1→package interp
     2→
     3→/*
     4→#cgo CFLAGS: -I${SRCDIR}/../src
     5→#cgo LDFLAGS: -L${SRCDIR}/../build -ltclc -Wl,-rpath,${SRCDIR}/../build
     6→#include "tclc.h"
     7→
     8→// Implemented in callbacks.c
     9→extern TclResult call_tcl_eval_obj(TclInterp interp, TclObj script, TclEvalFlags flags);
    10→extern TclParseStatus call_tcl_parse(TclInterp interp, TclObj script);
    11→extern void call_tcl_interp_init(TclInterp interp);
    12→*/
    13→import "C"
    14→
    15→import "sort"
    16→
    17→// Go callback implementations - these are called from C via the wrappers in callbacks.c
    18→
    19→//export goBindUnknown
    20→func goBindUnknown(interp C.TclInterp, cmd C.TclObj, args C.TclObj, value *C.TclObj) C.TclResult {
    21→	i := getInterp(interp)
    22→	if i == nil {
    23→		return C.TCL_ERROR
    24→	}
    25→
    26→	if i.UnknownHandler != nil {
    27→		// Convert args TclObj (list) to []TclObj slice
    28→		var argSlice []TclObj
    29→		if args != 0 {
    30→			o := i.getObject(TclObj(args))
    31→			if o != nil && o.isList {
    32→				argSlice = make([]TclObj, len(o.listItems))
    33→				copy(argSlice, o.listItems)
    34→			}
    35→		}
    36→		result := i.UnknownHandler(i, TclObj(cmd), argSlice)
    37→		*value = C.TclObj(i.result)
    38→		return C.TclResult(result)
    39→	}
    40→
    41→	return C.TCL_ERROR
    42→}
    43→
    44→//export goStringIntern
    45→func goStringIntern(interp C.TclInterp, s *C.char, length C.size_t) C.TclObj {
    46→	i := getInterp(interp)
    47→	if i == nil {
    48→		return 0
    49→	}
    50→	goStr := C.GoStringN(s, C.int(length))
    51→	return C.TclObj(i.internString(goStr))
    52→}
    53→
    54→//export goStringGet
    55→func goStringGet(interp C.TclInterp, obj C.TclObj, length *C.size_t) *C.char {
    56→	i := getInterp(interp)
    57→	if i == nil {
    58→		*length = 0
    59→		return nil
    60→	}
    61→	// Use GetString for shimmering (int/list → string)
    62→	str := i.GetString(TclObj(obj))
    63→	if str == "" {
    64→		// Check if object exists but has empty string
    65→		o := i.getObject(TclObj(obj))
    66→		if o == nil {
    67→			*length = 0
    68→			return nil
    69→		}
    70→	}
    71→	// Cache the C string in the object to avoid memory issues
    72→	o := i.getObject(TclObj(obj))
    73→	if o.cstr == nil {
    74→		o.cstr = C.CString(str)
    75→	}
    76→	*length = C.size_t(len(str))
    77→	return o.cstr
    78→}
    79→
    80→//export goStringConcat
    81→func goStringConcat(interp C.TclInterp, a C.TclObj, b C.TclObj) C.TclObj {
    82→	i := getInterp(interp)
    83→	if i == nil {
    84→		return 0
    85→	}
    86→	// Use GetString for shimmering (int/list → string)
    87→	strA := i.GetString(TclObj(a))
    88→	strB := i.GetString(TclObj(b))
    89→	return C.TclObj(i.internString(strA + strB))
    90→}
    91→
    92→//export goStringCompare
    93→func goStringCompare(interp C.TclInterp, a C.TclObj, b C.TclObj) C.int {
    94→	i := getInterp(interp)
    95→	if i == nil {
    96→		return 0
    97→	}
    98→	// Use GetString for shimmering (int/list → string)
    99→	strA := i.GetString(TclObj(a))
   100→	strB := i.GetString(TclObj(b))
   101→	// Go's string comparison is already Unicode-aware (UTF-8)
   102→	if strA < strB {
   103→		return -1
   104→	}
   105→	if strA > strB {
   106→		return 1
   107→	}
   108→	return 0
   109→}
   110→
   111→//export goInterpSetResult
   112→func goInterpSetResult(interp C.TclInterp, result C.TclObj) C.TclResult {
   113→	i := getInterp(interp)
   114→	if i == nil {
   115→		return C.TCL_ERROR
   116→	}
   117→	i.result = TclObj(result)
   118→	return C.TCL_OK
   119→}
   120→
   121→//export goInterpGetResult
   122→func goInterpGetResult(interp C.TclInterp) C.TclObj {
   123→	i := getInterp(interp)
   124→	if i == nil {
   125→		return 0
   126→	}
   127→	return C.TclObj(i.result)
   128→}
   129→
   130→//export goInterpResetResult
   131→func goInterpResetResult(interp C.TclInterp, result C.TclObj) C.TclResult {
   132→	i := getInterp(interp)
   133→	if i == nil {
   134→		return C.TCL_ERROR
   135→	}
   136→	i.result = 0
   137→	return C.TCL_OK
   138→}
   139→
   140→//export goInterpSetReturnOptions
   141→func goInterpSetReturnOptions(interp C.TclInterp, options C.TclObj) C.TclResult {
   142→	i := getInterp(interp)
   143→	if i == nil {
   144→		return C.TCL_ERROR
   145→	}
   146→	i.returnOptions = TclObj(options)
   147→	return C.TCL_OK
   148→}
   149→
   150→//export goInterpGetReturnOptions
   151→func goInterpGetReturnOptions(interp C.TclInterp, code C.TclResult) C.TclObj {
   152→	i := getInterp(interp)
   153→	if i == nil {
   154→		return 0
   155→	}
   156→	return C.TclObj(i.returnOptions)
   157→}
   158→
   159→//export goListCreate
   160→func goListCreate(interp C.TclInterp) C.TclObj {
   161→	i := getInterp(interp)
   162→	if i == nil {
   163→		return 0
   164→	}
   165→	i.mu.Lock()
   166→	defer i.mu.Unlock()
   167→	id := i.nextID
   168→	i.nextID++
   169→	i.objects[id] = &Object{isList: true, listItems: []TclObj{}}
   170→	return C.TclObj(id)
   171→}
   172→
   173→//export goListIsNil
   174→func goListIsNil(interp C.TclInterp, obj C.TclObj) C.int {
   175→	if obj == 0 {
   176→		return 1
   177→	}
   178→	return 0
   179→}
   180→
   181→//export goListFrom
   182→func goListFrom(interp C.TclInterp, obj C.TclObj) C.TclObj {
   183→	i := getInterp(interp)
   184→	if i == nil {
   185→		return 0
   186→	}
   187→	// Get the list items (with shimmering)
   188→	items, err := i.GetList(TclObj(obj))
   189→	if err != nil {
   190→		return 0
   191→	}
   192→	// Create a new list with copied items
   193→	i.mu.Lock()
   194→	defer i.mu.Unlock()
   195→	id := i.nextID
   196→	i.nextID++
   197→	// Make a copy of the items slice
   198→	copiedItems := make([]TclObj, len(items))
   199→	copy(copiedItems, items)
   200→	i.objects[id] = &Object{isList: true, listItems: copiedItems}
   201→	return C.TclObj(id)
   202→}
   203→
   204→//export goListPush
   205→func goListPush(interp C.TclInterp, list C.TclObj, item C.TclObj) C.TclObj {
   206→	i := getInterp(interp)
   207→	if i == nil {
   208→		return list
   209→	}
   210→	o := i.getObject(TclObj(list))
   211→	if o == nil || !o.isList {
   212→		return list
   213→	}
   214→	i.mu.Lock()
   215→	defer i.mu.Unlock()
   216→	o.listItems = append(o.listItems, TclObj(item))
   217→	return list
   218→}
   219→
   220→//export goListPop
   221→func goListPop(interp C.TclInterp, list C.TclObj) C.TclObj {
   222→	return 0
   223→}
   224→
   225→//export goListUnshift
   226→func goListUnshift(interp C.TclInterp, list C.TclObj, item C.TclObj) C.TclObj {
   227→	return list
   228→}
   229→
   230→//export goListShift
   231→func goListShift(interp C.TclInterp, list C.TclObj) C.TclObj {
   232→	i := getInterp(interp)
   233→	if i == nil {
   234→		return 0
   235→	}
   236→	// Use GetList for shimmering (string → list)
   237→	items, err := i.GetList(TclObj(list))
   238→	if err != nil || len(items) == 0 {
   239→		return 0
   240→	}
   241→	o := i.getObject(TclObj(list))
   242→	if o == nil {
   243→		return 0
   244→	}
   245→	i.mu.Lock()
   246→	defer i.mu.Unlock()
   247→	first := o.listItems[0]
   248→	o.listItems = o.listItems[1:]
   249→	return C.TclObj(first)
   250→}
   251→
   252→//export goListLength
   253→func goListLength(interp C.TclInterp, list C.TclObj) C.size_t {
   254→	i := getInterp(interp)
   255→	if i == nil {
   256→		return 0
   257→	}
   258→	// Use GetList for shimmering (string → list)
   259→	items, err := i.GetList(TclObj(list))
   260→	if err != nil {
   261→		return 0
   262→	}
   263→	return C.size_t(len(items))
   264→}
   265→
   266→//export goListAt
   267→func goListAt(interp C.TclInterp, list C.TclObj, index C.size_t) C.TclObj {
   268→	i := getInterp(interp)
   269→	if i == nil {
   270→		return 0
   271→	}
   272→	items, err := i.GetList(TclObj(list))
   273→	if err != nil {
   274→		return 0
   275→	}
   276→	idx := int(index)
   277→	if idx < 0 || idx >= len(items) {
   278→		return 0
   279→	}
   280→	return C.TclObj(items[idx])
   281→}
   282→
   283→//export goIntCreate
   284→func goIntCreate(interp C.TclInterp, val C.int64_t) C.TclObj {
   285→	i := getInterp(interp)
   286→	if i == nil {
   287→		return 0
   288→	}
   289→	i.mu.Lock()
   290→	defer i.mu.Unlock()
   291→	id := i.nextID
   292→	i.nextID++
   293→	i.objects[id] = &Object{intVal: int64(val), isInt: true}
   294→	return C.TclObj(id)
   295→}
   296→
   297→//export goIntGet
   298→func goIntGet(interp C.TclInterp, obj C.TclObj, out *C.int64_t) C.TclResult {
   299→	i := getInterp(interp)
   300→	if i == nil {
   301→		return C.TCL_ERROR
   302→	}
   303→	val, err := i.GetInt(TclObj(obj))
   304→	if err != nil {
   305→		return C.TCL_ERROR
   306→	}
   307→	*out = C.int64_t(val)
   308→	return C.TCL_OK
   309→}
   310→
   311→//export goDoubleCreate
   312→func goDoubleCreate(interp C.TclInterp, val C.double) C.TclObj {
   313→	i := getInterp(interp)
   314→	if i == nil {
   315→		return 0
   316→	}
   317→	i.mu.Lock()
   318→	defer i.mu.Unlock()
   319→	id := i.nextID
   320→	i.nextID++
   321→	i.objects[id] = &Object{dblVal: float64(val), isDouble: true}
   322→	return C.TclObj(id)
   323→}
   324→
   325→//export goDoubleGet
   326→func goDoubleGet(interp C.TclInterp, obj C.TclObj, out *C.double) C.TclResult {
   327→	i := getInterp(interp)
   328→	if i == nil {
   329→		return C.TCL_ERROR
   330→	}
   331→	val, err := i.GetDouble(TclObj(obj))
   332→	if err != nil {
   333→		return C.TCL_ERROR
   334→	}
   335→	*out = C.double(val)
   336→	return C.TCL_OK
   337→}
   338→
   339→//export goFramePush
   340→func goFramePush(interp C.TclInterp, cmd C.TclObj, args C.TclObj) C.TclResult {
   341→	i := getInterp(interp)
   342→	if i == nil {
   343→		return C.TCL_ERROR
   344→	}
   345→	i.mu.Lock()
   346→	defer i.mu.Unlock()
   347→	newLevel := len(i.frames)
   348→	// Check recursion limit
   349→	limit := i.recursionLimit
   350→	if limit <= 0 {
   351→		limit = DefaultRecursionLimit
   352→	}
   353→	if newLevel >= limit {
   354→		// Set error message and return error
   355→		errMsg := "too many nested evaluations (infinite loop?)"
   356→		id := i.nextID
   357→		i.nextID++
   358→		i.objects[id] = &Object{stringVal: errMsg}
   359→		i.result = id
   360→		return C.TCL_ERROR
   361→	}
   362→	frame := &CallFrame{
   363→		cmd:   TclObj(cmd),
   364→		args:  TclObj(args),
   365→		vars:  make(map[string]TclObj),
   366→		links: make(map[string]varLink),
   367→		level: newLevel,
   368→	}
   369→	i.frames = append(i.frames, frame)
   370→	i.active = newLevel
   371→	return C.TCL_OK
   372→}
   373→
   374→//export goFramePop
   375→func goFramePop(interp C.TclInterp) C.TclResult {
   376→	i := getInterp(interp)
   377→	if i == nil {
   378→		return C.TCL_ERROR
   379→	}
   380→	i.mu.Lock()
   381→	defer i.mu.Unlock()
   382→	// Cannot pop the global frame (frame 0)
   383→	if len(i.frames) <= 1 {
   384→		return C.TCL_ERROR
   385→	}
   386→	i.frames = i.frames[:len(i.frames)-1]
   387→	i.active = len(i.frames) - 1
   388→	return C.TCL_OK
   389→}
   390→
   391→//export goFrameLevel
   392→func goFrameLevel(interp C.TclInterp) C.size_t {
   393→	i := getInterp(interp)
   394→	if i == nil {
   395→		return 0
   396→	}
   397→	i.mu.Lock()
   398→	defer i.mu.Unlock()
   399→	return C.size_t(i.active)
   400→}
   401→
   402→//export goFrameSetActive
   403→func goFrameSetActive(interp C.TclInterp, level C.size_t) C.TclResult {
   404→	i := getInterp(interp)
   405→	if i == nil {
   406→		return C.TCL_ERROR
   407→	}
   408→	i.mu.Lock()
   409→	defer i.mu.Unlock()
   410→	lvl := int(level)
   411→	if lvl < 0 || lvl >= len(i.frames) {
   412→		return C.TCL_ERROR
   413→	}
   414→	i.active = lvl
   415→	return C.TCL_OK
   416→}
   417→
   418→//export goFrameSize
   419→func goFrameSize(interp C.TclInterp) C.size_t {
   420→	i := getInterp(interp)
   421→	if i == nil {
   422→		return 0
   423→	}
   424→	i.mu.Lock()
   425→	defer i.mu.Unlock()
   426→	return C.size_t(len(i.frames))
   427→}
   428→
   429→//export goFrameInfo
   430→func goFrameInfo(interp C.TclInterp, level C.size_t, cmd *C.TclObj, args *C.TclObj) C.TclResult {
   431→	i := getInterp(interp)
   432→	if i == nil {
   433→		return C.TCL_ERROR
   434→	}
   435→	i.mu.Lock()
   436→	defer i.mu.Unlock()
   437→	lvl := int(level)
   438→	if lvl < 0 || lvl >= len(i.frames) {
   439→		return C.TCL_ERROR
   440→	}
   441→	frame := i.frames[lvl]
   442→	*cmd = C.TclObj(frame.cmd)
   443→	*args = C.TclObj(frame.args)
   444→	return C.TCL_OK
   445→}
   446→
   447→//export goVarGet
   448→func goVarGet(interp C.TclInterp, name C.TclObj) C.TclObj {
   449→	i := getInterp(interp)
   450→	if i == nil {
   451→		return 0
   452→	}
   453→	nameObj := i.getObject(TclObj(name))
   454→	if nameObj == nil {
   455→		return 0
   456→	}
   457→	i.mu.Lock()
   458→	defer i.mu.Unlock()
   459→	frame := i.frames[i.active]
   460→	varName := nameObj.stringVal
   461→	// Follow links to find the actual variable location
   462→	for {
   463→		if link, ok := frame.links[varName]; ok {
   464→			if link.targetLevel >= 0 && link.targetLevel < len(i.frames) {
   465→				frame = i.frames[link.targetLevel]
   466→				varName = link.targetName
   467→			} else {
   468→				return 0
   469→			}
   470→		} else {
   471→			break
   472→		}
   473→	}
   474→	if val, ok := frame.vars[varName]; ok {
   475→		return C.TclObj(val)
   476→	}
   477→	return 0
   478→}
   479→
   480→//export goVarSet
   481→func goVarSet(interp C.TclInterp, name C.TclObj, value C.TclObj) {
   482→	i := getInterp(interp)
   483→	if i == nil {
   484→		return
   485→	}
   486→	nameObj := i.getObject(TclObj(name))
   487→	if nameObj == nil {
   488→		return
   489→	}
   490→	i.mu.Lock()
   491→	defer i.mu.Unlock()
   492→	frame := i.frames[i.active]
   493→	varName := nameObj.stringVal
   494→	// Follow links to find the actual variable location
   495→	for {
   496→		if link, ok := frame.links[varName]; ok {
   497→			if link.targetLevel >= 0 && link.targetLevel < len(i.frames) {
   498→				frame = i.frames[link.targetLevel]
   499→				varName = link.targetName
   500→			} else {
   501→				return
   502→			}
   503→		} else {
   504→			break
   505→		}
   506→	}
   507→	frame.vars[varName] = TclObj(value)
   508→}
   509→
   510→//export goVarUnset
   511→func goVarUnset(interp C.TclInterp, name C.TclObj) {
   512→	i := getInterp(interp)
   513→	if i == nil {
   514→		return
   515→	}
   516→	nameObj := i.getObject(TclObj(name))
   517→	if nameObj == nil {
   518→		return
   519→	}
   520→	i.mu.Lock()
   521→	defer i.mu.Unlock()
   522→	frame := i.frames[i.active]
   523→	varName := nameObj.stringVal
   524→	// Follow links to find the actual variable location
   525→	for {
   526→		if link, ok := frame.links[varName]; ok {
   527→			if link.targetLevel >= 0 && link.targetLevel < len(i.frames) {
   528→				frame = i.frames[link.targetLevel]
   529→				varName = link.targetName
   530→			} else {
   531→				return
   532→			}
   533→		} else {
   534→			break
   535→		}
   536→	}
   537→	delete(frame.vars, varName)
   538→}
   539→
   540→//export goVarExists
   541→func goVarExists(interp C.TclInterp, name C.TclObj) C.TclResult {
   542→	i := getInterp(interp)
   543→	if i == nil {
   544→		return C.TCL_ERROR
   545→	}
   546→	nameObj := i.getObject(TclObj(name))
   547→	if nameObj == nil {
   548→		return C.TCL_ERROR
   549→	}
   550→	i.mu.Lock()
   551→	defer i.mu.Unlock()
   552→	frame := i.frames[i.active]
   553→	varName := nameObj.stringVal
   554→	// Follow links to find the actual variable location
   555→	for {
   556→		if link, ok := frame.links[varName]; ok {
   557→			if link.targetLevel >= 0 && link.targetLevel < len(i.frames) {
   558→				frame = i.frames[link.targetLevel]
   559→				varName = link.targetName
   560→			} else {
   561→				return C.TCL_ERROR
   562→			}
   563→		} else {
   564→			break
   565→		}
   566→	}
   567→	if _, ok := frame.vars[varName]; ok {
   568→		return C.TCL_OK
   569→	}
   570→	return C.TCL_ERROR
   571→}
   572→
   573→//export goVarLink
   574→func goVarLink(interp C.TclInterp, local C.TclObj, target_level C.size_t, target C.TclObj) {
   575→	i := getInterp(interp)
   576→	if i == nil {
   577→		return
   578→	}
   579→	localObj := i.getObject(TclObj(local))
   580→	targetObj := i.getObject(TclObj(target))
   581→	if localObj == nil || targetObj == nil {
   582→		return
   583→	}
   584→	i.mu.Lock()
   585→	defer i.mu.Unlock()
   586→	frame := i.frames[i.active]
   587→	frame.links[localObj.stringVal] = varLink{
   588→		targetLevel: int(target_level),
   589→		targetName:  targetObj.stringVal,
   590→	}
   591→}
   592→
   593→//export goProcDefine
   594→func goProcDefine(interp C.TclInterp, name C.TclObj, params C.TclObj, body C.TclObj) {
   595→	i := getInterp(interp)
   596→	if i == nil {
   597→		return
   598→	}
   599→	nameStr := i.GetString(TclObj(name))
   600→	i.mu.Lock()
   601→	defer i.mu.Unlock()
   602→	proc := &Procedure{
   603→		name:   TclObj(name),
   604→		params: TclObj(params),
   605→		body:   TclObj(body),
   606→	}
   607→	i.commands[nameStr] = &Command{
   608→		cmdType: CmdProc,
   609→		proc:    proc,
   610→	}
   611→}
   612→
   613→//export goProcExists
   614→func goProcExists(interp C.TclInterp, name C.TclObj) C.int {
   615→	i := getInterp(interp)
   616→	if i == nil {
   617→		return 0
   618→	}
   619→	nameStr := i.GetString(TclObj(name))
   620→	i.mu.Lock()
   621→	defer i.mu.Unlock()
   622→	if cmd, ok := i.commands[nameStr]; ok && cmd.cmdType == CmdProc {
   623→		return 1
   624→	}
   625→	return 0
   626→}
   627→
   628→//export goProcParams
   629→func goProcParams(interp C.TclInterp, name C.TclObj, result *C.TclObj) C.TclResult {
   630→	i := getInterp(interp)
   631→	if i == nil {
   632→		return C.TCL_ERROR
   633→	}
   634→	nameStr := i.GetString(TclObj(name))
   635→	i.mu.Lock()
   636→	cmd, ok := i.commands[nameStr]
   637→	i.mu.Unlock()
   638→	if !ok || cmd.cmdType != CmdProc || cmd.proc == nil {
   639→		return C.TCL_ERROR
   640→	}
   641→	*result = C.TclObj(cmd.proc.params)
   642→	return C.TCL_OK
   643→}
   644→
   645→//export goProcBody
   646→func goProcBody(interp C.TclInterp, name C.TclObj, result *C.TclObj) C.TclResult {
   647→	i := getInterp(interp)
   648→	if i == nil {
   649→		return C.TCL_ERROR
   650→	}
   651→	nameStr := i.GetString(TclObj(name))
   652→	i.mu.Lock()
   653→	cmd, ok := i.commands[nameStr]
   654→	i.mu.Unlock()
   655→	if !ok || cmd.cmdType != CmdProc || cmd.proc == nil {
   656→		return C.TCL_ERROR
   657→	}
   658→	*result = C.TclObj(cmd.proc.body)
   659→	return C.TCL_OK
   660→}
   661→
   662→// callCEval invokes the C interpreter
   663→func callCEval(interpHandle TclInterp, scriptHandle TclObj) C.TclResult {
   664→	return C.call_tcl_eval_obj(C.TclInterp(interpHandle), C.TclObj(scriptHandle), C.TCL_EVAL_LOCAL)
   665→}
   666→
   667→// callCParse invokes the C parser
   668→func callCParse(interpHandle TclInterp, scriptHandle TclObj) C.TclParseStatus {
   669→	return C.call_tcl_parse(C.TclInterp(interpHandle), C.TclObj(scriptHandle))
   670→}
   671→
   672→// callCInterpInit invokes the C interpreter initialization
   673→func callCInterpInit(interpHandle TclInterp) {
   674→	C.call_tcl_interp_init(C.TclInterp(interpHandle))
   675→}
   676→
   677→//export goProcNames
   678→func goProcNames(interp C.TclInterp, namespace C.TclObj) C.TclObj {
   679→	i := getInterp(interp)
   680→	if i == nil {
   681→		return 0
   682→	}
   683→	// For now, ignore namespace parameter (only global namespace exists)
   684→	// Collect all command names
   685→	i.mu.Lock()
   686→	names := make([]string, 0, len(i.commands))
   687→	for name := range i.commands {
   688→		names = append(names, name)
   689→	}
   690→	i.mu.Unlock()
   691→
   692→	// Sort for consistent ordering
   693→	sort.Strings(names)
   694→
   695→	// Create a list object with all names
   696→	i.mu.Lock()
   697→	defer i.mu.Unlock()
   698→	id := i.nextID
   699→	i.nextID++
   700→	items := make([]TclObj, len(names))
   701→	for idx, name := range names {
   702→		itemID := i.nextID
   703→		i.nextID++
   704→		i.objects[itemID] = &Object{stringVal: name}
   705→		items[idx] = itemID
   706→	}
   707→	i.objects[id] = &Object{isList: true, listItems: items}
   708→	return C.TclObj(id)
   709→}
   710→
   711→//export goProcResolveNamespace
   712→func goProcResolveNamespace(interp C.TclInterp, path C.TclObj, result *C.TclObj) C.TclResult {
   713→	i := getInterp(interp)
   714→	if i == nil {
   715→		return C.TCL_ERROR
   716→	}
   717→	// For now, only the global namespace "::" exists
   718→	// If path is nil, empty, or "::", return global namespace
   719→	if path == 0 {
   720→		*result = C.TclObj(i.globalNS)
   721→		return C.TCL_OK
   722→	}
   723→	pathStr := i.GetString(TclObj(path))
   724→	if pathStr == "" || pathStr == "::" {
   725→		*result = C.TclObj(i.globalNS)
   726→		return C.TCL_OK
   727→	}
   728→	// Any other namespace doesn't exist yet
   729→	i.SetErrorString("namespace \"" + pathStr + "\" not found")
   730→	return C.TCL_ERROR
   731→}
   732→
   733→//export goProcRegisterBuiltin
   734→func goProcRegisterBuiltin(interp C.TclInterp, name C.TclObj, fn C.TclBuiltinCmd) {
   735→	i := getInterp(interp)
   736→	if i == nil {
   737→		return
   738→	}
   739→	nameStr := i.GetString(TclObj(name))
   740→	i.mu.Lock()
   741→	defer i.mu.Unlock()
   742→	// Register builtin with its function pointer
   743→	i.commands[nameStr] = &Command{
   744→		cmdType: CmdBuiltin,
   745→		builtin: fn,
   746→	}
   747→}
   748→
   749→//export goProcLookup
   750→func goProcLookup(interp C.TclInterp, name C.TclObj, fn *C.TclBuiltinCmd) C.TclCommandType {
   751→	i := getInterp(interp)
   752→	if i == nil {
   753→		*fn = nil
   754→		return C.TCL_CMD_NONE
   755→	}
   756→	nameStr := i.GetString(TclObj(name))
   757→	i.mu.Lock()
   758→	cmd, ok := i.commands[nameStr]
   759→	i.mu.Unlock()
   760→	if !ok {
   761→		*fn = nil
   762→		return C.TCL_CMD_NONE
   763→	}
   764→	switch cmd.cmdType {
   765→	case CmdBuiltin:
   766→		*fn = cmd.builtin
   767→		return C.TCL_CMD_BUILTIN
   768→	case CmdProc:
   769→		*fn = nil
   770→		return C.TCL_CMD_PROC
   771→	default:
   772→		*fn = nil
   773→		return C.TCL_CMD_NONE
   774→	}
   775→}
   776→
   777→//export goProcRename
   778→func goProcRename(interp C.TclInterp, oldName C.TclObj, newName C.TclObj) C.TclResult {
   779→	i := getInterp(interp)
   780→	if i == nil {
   781→		return C.TCL_ERROR
   782→	}
   783→	oldNameStr := i.GetString(TclObj(oldName))
   784→	newNameStr := i.GetString(TclObj(newName))
   785→
   786→	i.mu.Lock()
   787→
   788→	// Check if old command exists
   789→	cmd, ok := i.commands[oldNameStr]
   790→	if !ok {
   791→		i.mu.Unlock()
   792→		i.SetErrorString("can't rename \"" + oldNameStr + "\": command doesn't exist")
   793→		return C.TCL_ERROR
   794→	}
   795→
   796→	// If newName is empty, delete the command
   797→	if newNameStr == "" {
   798→		delete(i.commands, oldNameStr)
   799→		i.mu.Unlock()
   800→		return C.TCL_OK
   801→	}
   802→
   803→	// Check if new name already exists
   804→	if _, exists := i.commands[newNameStr]; exists {
   805→		i.mu.Unlock()
   806→		i.SetErrorString("can't rename to \"" + newNameStr + "\": command already exists")
   807→		return C.TCL_ERROR
   808→	}
   809→
   810→	// Simply move the entry to the new key
   811→	// For builtins: function pointer comes along
   812→	// For procs: procedure data comes along
   813→	i.commands[newNameStr] = cmd
   814→	delete(i.commands, oldNameStr)
   815→	i.mu.Unlock()
   816→
   817→	return C.TCL_OK
   818→}
   819→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
