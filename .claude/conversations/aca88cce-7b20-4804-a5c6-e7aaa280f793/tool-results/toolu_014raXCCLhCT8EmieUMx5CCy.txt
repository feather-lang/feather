chan(n)                      Tcl Built-In Commands                     chan(n)

______________________________________________________________________________

NNAAMMEE
       chan - Read, write and manipulate channels

SSYYNNOOPPSSIISS
       cchhaann _o_p_t_i_o_n ?_a_r_g _a_r_g _._._.?
______________________________________________________________________________

DDEESSCCRRIIPPTTIIOONN
       This command provides several operations for reading from, writing to
       and otherwise manipulating open channels (such as have been created
       with the ooppeenn and ssoocckkeett commands, or the default named channels ssttddiinn,
       ssttddoouutt or ssttddeerrrr which correspond to the process's standard input,
       output and error streams respectively).  _O_p_t_i_o_n indicates what to do
       with the channel; any unique abbreviation for _o_p_t_i_o_n is acceptable.
       Valid options are:

       cchhaann bblloocckkeedd _c_h_a_n_n_e_l
              This tests whether the last input operation on the channel
              called _c_h_a_n_n_e_l failed because it would have otherwise caused the
              process to block, and returns 1 if that was the case. It returns
              0 otherwise. Note that this only ever returns 1 when the channel
              has been configured to be non-blocking; all Tcl channels have
              blocking turned on by default.

       cchhaann cclloossee _c_h_a_n_n_e_l ?_d_i_r_e_c_t_i_o_n?
              Close and destroy the channel called _c_h_a_n_n_e_l. Note that this
              deletes all existing file-events registered on the channel.  If
              the _d_i_r_e_c_t_i_o_n argument (which must be rreeaadd or wwrriittee or any
              unique abbreviation of them) is present, the channel will only
              be half-closed, so that it can go from being read-write to
              write-only or read-only respectively. If a read-only channel is
              closed for reading, it is the same as if the channel is fully
              closed, and respectively similar for write-only channels.
              Without the _d_i_r_e_c_t_i_o_n argument, the channel is closed for both
              reading and writing (but only if those directions are currently
              open). It is an error to close a read-only channel for writing,
              or a write-only channel for reading.

              As part of closing the channel, all buffered output is flushed
              to the channel's output device (only if the channel is ceasing
              to be writable), any buffered input is discarded (only if the
              channel is ceasing to be readable), the underlying operating
              system resource is closed and _c_h_a_n_n_e_l becomes unavailable for
              future use (both only if the channel is being completely
              closed).

              If the channel is blocking and the channel is ceasing to be
              writable, the command does not return until all output is
              flushed.  If the channel is non-blocking and there is unflushed
              output, the channel remains open and the command returns
              immediately; output will be flushed in the background and the
              channel will be closed when all the flushing is complete.

              If _c_h_a_n_n_e_l is a blocking channel for a command pipeline then
              cchhaann cclloossee waits for the child processes to complete.

              If the channel is shared between interpreters, then cchhaann cclloossee
              makes _c_h_a_n_n_e_l unavailable in the invoking interpreter but has no
              other effect until all of the sharing interpreters have closed
              the channel. When the last interpreter in which the channel is
              registered invokes cchhaann cclloossee (or cclloossee), the cleanup actions
              described above occur. With half-closing, the half-close of the
              channel only applies to the current interpreter's view of the
              channel until all channels have closed it in that direction (or
              completely).  See the iinntteerrpp command for a description of
              channel sharing.

              Channels are automatically fully closed when an interpreter is
              destroyed and when the process exits.  Channels are switched to
              blocking mode, to ensure that all output is correctly flushed
              before the process exits.

              The command returns an empty string, and may generate an error
              if an error occurs while flushing output.  If a command in a
              command pipeline created with ooppeenn returns an error, cchhaann cclloossee
              generates an error (similar to the eexxeecc command.)

              Note that half-closes of sockets and command pipelines can have
              important side effects because they result in a shutdown() or
              close() of the underlying system resource, which can change how
              other processes or systems respond to the Tcl program.

              Channels are automatically closed when an interpreter is
              destroyed and when the process exits.  Nonblocking channels are
              not switched to blocking mode when exiting; this guarantees a
              timely exit even when the peer or a communication channel is
              stalled. To ensure proper flushing of stalled nonblocking
              channels on exit, one must either (a) actively switch them back
              to blocking or (b) use the environment variable
              TTCCLL__FFLLUUSSHH__NNOONNBBLLOOCCKKIINNGG__OONN__EEXXIITT.

       cchhaann ccoonnffiigguurree _c_h_a_n_n_e_l ?_o_p_t_i_o_n_N_a_m_e? ?_v_a_l_u_e? ?_o_p_t_i_o_n_N_a_m_e _v_a_l_u_e?...
              Query or set the configuration options of the channel named
              _c_h_a_n_n_e_l.

              If no _o_p_t_i_o_n_N_a_m_e or _v_a_l_u_e arguments are supplied, the command
              returns a list containing alternating option names and values
              for the channel.  If _o_p_t_i_o_n_N_a_m_e is supplied but no _v_a_l_u_e then
              the command returns the current value of the given option.  If
              one or more pairs of _o_p_t_i_o_n_N_a_m_e and _v_a_l_u_e are supplied, the
              command sets each of the named options to the corresponding
              _v_a_l_u_e; in this case the return value is an empty string.

              The options described below are supported for all channels. In
              addition, each channel type may add options that only it
              supports. See the manual entry for the command that creates each
              type of channel for the options supported by that specific type
              of channel. For example, see the manual entry for the ssoocckkeett
              command for additional options for sockets, and the ooppeenn command
              for additional options for serial devices.

       --bblloocckkiinngg _b_o_o_l_e_a_n
              The --bblloocckkiinngg option determines whether I/O operations on the
              channel can cause the process to block indefinitely.  The value
              of the option must be a proper boolean value.  Channels are
              normally in blocking mode; if a channel is placed into non-
              blocking mode it will affect the operation of the cchhaann ggeettss,
              cchhaann rreeaadd, cchhaann ppuuttss, cchhaann fflluusshh, and cchhaann cclloossee commands; see
              the documentation for those commands for details.  For non-
              blocking mode to work correctly, the application must be using
              the Tcl event loop (e.g. by calling TTccll__DDooOOnneeEEvveenntt or invoking
              the vvwwaaiitt command).

       --bbuuffffeerriinngg _n_e_w_V_a_l_u_e
              If _n_e_w_V_a_l_u_e is ffuullll then the I/O system will buffer output until
              its internal buffer is full or until the cchhaann fflluusshh command is
              invoked. If _n_e_w_V_a_l_u_e is lliinnee, then the I/O system will
              automatically flush output for the channel whenever a newline
              character is output. If _n_e_w_V_a_l_u_e is nnoonnee, the I/O system will
              flush automatically after every output operation.  The default
              is for --bbuuffffeerriinngg to be set to ffuullll except for channels that
              connect to terminal-like devices; for these channels the initial
              setting is lliinnee.  Additionally, ssttddiinn and ssttddoouutt are initially
              set to lliinnee, and ssttddeerrrr is set to nnoonnee.

       --bbuuffffeerrssiizzee _n_e_w_S_i_z_e
              _n_e_w_S_i_z_e must be an integer; its value is used to set the size of
              buffers, in bytes, subsequently allocated for this channel to
              store input or output. _n_e_w_S_i_z_e must be a number of no more than
              one million, allowing buffers of up to one million bytes in
              size.

       --eennccooddiinngg _n_a_m_e
              This option is used to specify the encoding of the channel as
              one of the named encodings returned by eennccooddiinngg nnaammeess, so that
              the data can be converted to and from Unicode for use in Tcl.
              For instance, in order for Tcl to read characters from a
              Japanese file in sshhiiffttjjiiss and properly process and display the
              contents, the encoding would be set to sshhiiffttjjiiss.  Thereafter,
              when reading from the channel, the bytes in the Japanese file
              would be converted to Unicode as they are read.  Writing is also
              supported - as Tcl strings are written to the channel they will
              automatically be converted to the specified encoding on output.

              If a file contains pure binary data (for instance, a JPEG
              image), the encoding for the channel should be configured to be
              iissoo88885599--11.  Tcl will then assign no interpretation to the data
              in the file and simply read or write raw bytes.  The Tcl bbiinnaarryy
              command can be used to manipulate this byte-oriented data.  It
              is usually better to set the --ttrraannssllaattiioonn option to bbiinnaarryy when
              you want to transfer binary data, as this turns off the other
              automatic interpretations of the bytes in the stream as well.

              The default encoding for newly opened channels is the same
              platform- and locale-dependent system encoding used for
              interfacing with the operating system, as returned by eennccooddiinngg
              ssyysstteemm.

       --eeooffcchhaarr _c_h_a_r
              This option supports DOS file systems that use Control-z (\x1A)
              as an end of file marker.  If _c_h_a_r is not an empty string, then
              this character signals end-of-file when it is encountered during
              input.  Otherwise (the default) there is no special end of file
              character marker.  The acceptable range for --eeooffcchhaarr values is
              \x01 - \x7f; attempting to set --eeooffcchhaarr to a value outside of
              this range will generate an error.                               │

       --pprrooffiillee _p_r_o_f_i_l_e                                                        │
              Specifies the encoding profile to be used on the channel. The    │
              encoding transforms in use for the channel's input and output    │
              will then be subject to the rules of that profile. Any failures  │
              will result in a channel error. See PPRROOFFIILLEESS in the eennccooddiinngg((nn))  │
              documentation for details about encoding profiles.

       --ttrraannssllaattiioonn _t_r_a_n_s_l_a_t_i_o_n

       --ttrraannssllaattiioonn {{_i_n_T_r_a_n_s_l_a_t_i_o_n _o_u_t_T_r_a_n_s_l_a_t_i_o_n}}
              In Tcl scripts the end of a line is always represented using a
              single newline character (\n).  However, in actual files and
              devices the end of a line may be represented differently on
              different platforms, or even for different devices on the same
              platform.  For example, under UNIX newlines are used in files,
              whereas carriage-return-linefeed sequences are normally used in
              network connections.  On input (i.e., with cchhaann ggeettss and cchhaann
              rreeaadd) the Tcl I/O system automatically translates the external
              end-of-line representation into newline characters.  Upon output
              (i.e., with cchhaann ppuuttss), the I/O system translates newlines to
              the external end-of-line representation.  The default
              translation mode, aauuttoo, handles all the common cases
              automatically, but the --ttrraannssllaattiioonn option provides explicit
              control over the end of line translations.

              The value associated with --ttrraannssllaattiioonn is a single item for
              read-only and write-only channels.  The value is a two-element
              list for read-write channels; the read translation mode is the
              first element of the list, and the write translation mode is the
              second element.  As a convenience, when setting the translation
              mode for a read-write channel you can specify a single value
              that will apply to both reading and writing.  When querying the
              translation mode of a read-write channel, a two-element list
              will always be returned.  The following values are currently
              supported:

              aauuttoo   As the input translation mode, aauuttoo treats any of newline
                     (llff), carriage return (ccrr), or carriage return followed
                     by a newline (ccrrllff) as the end of line representation.
                     The end of line representation can even change from line-
                     to-line, and all cases are translated to a newline.  As
                     the output translation mode, aauuttoo chooses a platform
                     specific representation; for sockets on all platforms Tcl
                     chooses ccrrllff, for all Unix flavors, it chooses llff, and
                     for the various flavors of Windows it chooses ccrrllff.  The
                     default setting for --ttrraannssllaattiioonn is aauuttoo for both input
                     and output.

              bbiinnaarryy Like llff, no end-of-line translation is performed, but in
                     addition, sets --eeooffcchhaarr to the empty string to disable
                     it, and sets --eennccooddiinngg to iissoo88885599--11.  With this one
                     setting, a channel is fully configured for binary input
                     and output:  Each byte read from the channel becomes the
                     Unicode character having the same value as that byte, and
                     each character written to the channel becomes a single
                     byte in the output.  This makes it possible to work
                     seamlessly with binary data as long as each character in
                     the data remains in the range of 0 to 255 so that there
                     is no distinction between binary data and text.  For
                     example, A JPEG image can be read from a such a channel,
                     manipulated, and then written back to such a channel.

              ccrr     The end of a line in the underlying file or device is
                     represented by a single carriage return character.  As
                     the input translation mode, ccrr mode converts carriage
                     returns to newline characters.  As the output translation
                     mode, ccrr mode translates newline characters to carriage
                     returns.

              ccrrllff   The end of a line in the underlying file or device is
                     represented by a carriage return character followed by a
                     linefeed character.  As the input translation mode, ccrrllff
                     mode converts carriage-return-linefeed sequences to
                     newline characters.  As the output translation mode, ccrrllff
                     mode translates newline characters to carriage-return-
                     linefeed sequences.  This mode is typically used on
                     Windows platforms and for network connections.

              llff     The end of a line in the underlying file or device is
                     represented by a single newline (linefeed) character.  In
                     this mode no translations occur during either input or
                     output.  This mode is typically used on UNIX platforms.

       cchhaann ccooppyy _i_n_p_u_t_C_h_a_n _o_u_t_p_u_t_C_h_a_n ?--ssiizzee _s_i_z_e? ?--ccoommmmaanndd _c_a_l_l_b_a_c_k?
              Reads characters from _i_n_p_u_t_C_h_a_n and writes them to _o_u_t_p_u_t_C_h_a_n
              until all characters are copied, blocking until the copy is
              complete and returning the number of characters copied.
              Leverages internal buffers to avoid extra copies and to avoid
              buffering too much data in main memory when copying large files
              to slow destinations like network sockets.

              --ssiizzee limits the number of characters copied.

              If --ccoommmmaanndd is given, cchhaann ccooppyy returns immediately, works in
              the background, and calls _c_a_l_l_b_a_c_k when the copy completes,
              providing as an additional argument the number of characters
              written to _o_u_t_p_u_t_C_h_a_n.  If an error occurs during the background
              copy, another argument provides message for the error.
              _i_n_p_u_t_C_h_a_n and _o_u_t_p_u_t_C_h_a_n are automatically configured for non-
              blocking mode if needed.  Background copying only works
              correctly if events are being processed, e.g. via vvwwaaiitt or Tk.

              During a background copy no other read operation may be
              performed on _i_n_p_u_t_C_h_a_n, and no write operation may be performed
              on _o_u_t_p_u_t_C_h_a_n.  However, write operations may by performed on
              _i_n_p_u_t_C_h_a_n and read operations may be performed on _o_u_t_p_u_t_C_h_a_n, as
              exhibited by the bidirectional copy example below.

              If either _i_n_p_u_t_C_h_a_n or _o_u_t_p_u_t_C_h_a_n is closed while the copy is in
              progress, copying ceases and nnoo callback is made.  If _i_n_p_u_t_C_h_a_n
              is closed all data already queued is written to _o_u_t_p_u_t_C_h_a_n.

              There should be no event handler established for _i_n_p_u_t_C_h_a_n
              because it may become readable during a background copy.  An
              attempt to read or write from within an event handler results
              result in the error,  "channel busy".  Any wrong-sided I/O
              attempted (by a cchhaann eevveenntt handler or otherwise) results in a
              “channel busy” error.

       cchhaann ccrreeaattee _m_o_d_e _c_m_d_P_r_e_f_i_x
              This subcommand creates a new script level channel using the
              command prefix _c_m_d_P_r_e_f_i_x as its handler. Any such channel is
              called a rreefflleecctteedd channel. The specified command prefix,
              ccmmddPPrreeffiixx, must be a non-empty list, and should provide the API
              described in the rreeffcchhaann manual page. The handle of the new
              channel is returned as the result of the cchhaann ccrreeaattee command,
              and the channel is open. Use either cclloossee or cchhaann cclloossee to
              remove the channel.

              The argument _m_o_d_e specifies if the new channel is opened for
              reading, writing, or both. It has to be a list containing any of
              the strings “rreeaadd” or “wwrriittee”, The list must have at least one
              element, as a channel you can neither write to nor read from
              makes no sense. The handler command for the new channel must
              support the chosen mode, or an error is thrown.

              The command prefix is executed in the global namespace, at the
              top of call stack, following the appending of arguments as
              described in the rreeffcchhaann manual page. Command resolution happens
              at the time of the call. Renaming the command, or destroying it
              means that the next call of a handler method may fail, causing
              the channel command invoking the handler to fail as well.
              Depending on the subcommand being invoked, the error message may
              not be able to explain the reason for that failure.

              Every channel created with this subcommand knows which
              interpreter it was created in, and only ever executes its
              handler command in that interpreter, even if the channel was
              shared with and/or was moved into a different interpreter. Each
              reflected channel also knows the thread it was created in, and
              executes its handler command only in that thread, even if the
              channel was moved into a different thread. To this end all
              invocations of the handler are forwarded to the original thread
              by posting special events to it. This means that the original
              thread (i.e. the thread that executed the cchhaann ccrreeaattee command)
              must have an active event loop, i.e. it must be able to process
              such events. Otherwise the thread sending them will _b_l_o_c_k
              _i_n_d_e_f_i_n_i_t_e_l_y. Deadlock may occur.

              Note that this permits the creation of a channel whose two
              endpoints live in two different threads, providing a stream-
              oriented bridge between these threads. In other words, we can
              provide a way for regular stream communication between threads
              instead of having to send commands.

              When a thread or interpreter is deleted, all channels created
              with this subcommand and using this thread/interpreter as their
              computing base are deleted as well, in all interpreters they
              have been shared with or moved into, and in whatever thread they
              have been transferred to. While this pulls the rug out under the
              other thread(s) and/or interpreter(s), this cannot be avoided.
              Trying to use such a channel will cause the generation of a
              regular error about unknown channel handles.

              This subcommand is ssaaffee and made accessible to safe
              interpreters.  While it arranges for the execution of arbitrary
              Tcl code the system also makes sure that the code is always
              executed within the safe interpreter.

       cchhaann eeooff _c_h_a_n_n_e_l
              Test whether the last input operation on the channel called
              _c_h_a_n_n_e_l failed because the end of the data stream was reached,
              returning 1 if end-of-file was reached, and 0 otherwise.

       cchhaann eevveenntt _c_h_a_n_n_e_l _e_v_e_n_t ?_s_c_r_i_p_t?
              Arrange for the Tcl script _s_c_r_i_p_t to be installed as a _f_i_l_e
              _e_v_e_n_t _h_a_n_d_l_e_r to be called whenever the channel called _c_h_a_n_n_e_l
              enters the state described by _e_v_e_n_t (which must be either
              rreeaaddaabbllee or wwrriittaabbllee); only one such handler may be installed
              per event per channel at a time.  If _s_c_r_i_p_t is the empty string,
              the current handler is deleted (this also happens if the channel
              is closed or the interpreter deleted).  If _s_c_r_i_p_t is omitted,
              the currently installed script is returned (or an empty string
              if no such handler is installed).  The callback is only
              performed if the event loop is being serviced (e.g. via vvwwaaiitt or
              uuppddaattee).

              A file event handler is a binding between a channel and a
              script, such that the script is evaluated whenever the channel
              becomes readable or writable.  File event handlers are most
              commonly used to allow data to be received from another process
              on an event-driven basis, so that the receiver can continue to
              interact with the user or with other channels while waiting for
              the data to arrive.  If an application invokes cchhaann ggeettss or cchhaann
              rreeaadd on a blocking channel when there is no input data
              available, the process will block; until the input data arrives,
              it will not be able to service other events, so it will appear
              to the user to “freeze up” .  With cchhaann eevveenntt, the process can
              tell when data is present and only invoke cchhaann ggeettss or cchhaann rreeaadd
              when they will not block.

              A channel is considered to be readable if there is unread data
              available on the underlying device.  A channel is also
              considered to be readable if there is unread data in an input
              buffer, except in the special case where the most recent attempt
              to read from the channel was a cchhaann ggeettss call that could not
              find a complete line in the input buffer.  This feature allows a
              file to be read a line at a time in non-blocking mode using
              events.  A channel is also considered to be readable if an end
              of file or error condition is present on the underlying file or
              device.  It is important for _s_c_r_i_p_t to check for these
              conditions and handle them appropriately; for example, if there
              is no special check for end of file, an infinite loop may occur
              where _s_c_r_i_p_t reads no data, returns, and is immediately invoked
              again.

              A channel is considered to be writable if at least one byte of
              data can be written to the underlying file or device without
              blocking, or if an error condition is present on the underlying
              file or device.  Note that client sockets opened in asynchronous
              mode become writable when they become connected or if the
              connection fails.

              Event-driven I/O works best for channels that have been placed
              into non-blocking mode with the cchhaann ccoonnffiigguurree command.  In
              blocking mode, a cchhaann ppuuttss command may block if you give it more
              data than the underlying file or device can accept, and a cchhaann
              ggeettss or cchhaann rreeaadd command will block if you attempt to read more
              data than is ready; no events will be processed while the
              commands block.  In non-blocking mode cchhaann ppuuttss, cchhaann rreeaadd, and
              cchhaann ggeettss never block.

              The script for a file event is executed at global level (outside
              the context of any Tcl procedure) in the interpreter in which
              the cchhaann eevveenntt command was invoked.  If an error occurs while
              executing the script then the command registered with iinntteerrpp
              bbggeerrrroorr is used to report the error.  In addition, the file
              event handler is deleted if it ever returns an error; this is
              done in order to prevent infinite loops due to buggy handlers.

       cchhaann fflluusshh _c_h_a_n_n_e_l
              Ensures that all pending 

... [653 lines truncated] ...