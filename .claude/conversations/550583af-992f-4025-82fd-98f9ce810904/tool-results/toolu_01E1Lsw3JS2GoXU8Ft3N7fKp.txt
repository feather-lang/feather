     1→/*
     2→ * eval.c - TCL Evaluation Trampoline
     3→ *
     4→ * Non-recursive command evaluation state machine.
     5→ * Supports suspend/resume for coroutines.
     6→ */
     7→
     8→#include "internal.h"
     9→
    10→/* ========================================================================
    11→ * Interpreter Creation and Destruction
    12→ * ======================================================================== */
    13→
    14→TclInterp *tclInterpNew(const TclHost *host, void *hostCtx) {
    15→    /* Allocate interpreter struct using host arena temporarily */
    16→    void *arena = host->arenaPush(hostCtx);
    17→    TclInterp *interp = host->arenaAlloc(arena, sizeof(TclInterp), sizeof(void*));
    18→    if (!interp) {
    19→        host->arenaPop(hostCtx, arena);
    20→        return NULL;
    21→    }
    22→
    23→    /* Copy to permanent storage (we need interp to outlive arena) */
    24→    /* For now, use a simple static pool approach */
    25→    static TclInterp interpPool[8];
    26→    static int interpCount = 0;
    27→    if (interpCount >= 8) {
    28→        host->arenaPop(hostCtx, arena);
    29→        return NULL;
    30→    }
    31→
    32→    host->arenaPop(hostCtx, arena);
    33→    interp = &interpPool[interpCount++];
    34→
    35→    /* Initialize */
    36→    interp->host = host;
    37→    interp->hostCtx = hostCtx;
    38→    interp->result = NULL;
    39→    interp->resultCode = TCL_OK;
    40→    interp->errorInfo = NULL;
    41→    interp->errorCode = NULL;
    42→    interp->errorLine = 0;
    43→    interp->returnCode = TCL_OK;
    44→    interp->returnLevel = 1;
    45→    interp->currentCoro = NULL;
    46→    interp->scriptFile = NULL;
    47→    interp->scriptLine = 0;
    48→    interp->parent = NULL;
    49→    interp->isSafe = 0;
    50→
    51→    /* Create global frame */
    52→    interp->globalFrame = host->frameAlloc(hostCtx);
    53→    if (!interp->globalFrame) {
    54→        return NULL;
    55→    }
    56→    interp->globalFrame->parent = NULL;
    57→    interp->globalFrame->level = 0;
    58→    interp->globalFrame->flags = TCL_FRAME_GLOBAL;
    59→    interp->globalFrame->procName = NULL;
    60→    interp->globalFrame->invocationObjs = NULL;
    61→    interp->globalFrame->invocationCount = 0;
    62→
    63→    interp->currentFrame = interp->globalFrame;
    64→
    65→    return interp;
    66→}
    67→
    68→void tclInterpFree(TclInterp *interp) {
    69→    if (!interp) return;
    70→
    71→    const TclHost *host = interp->host;
    72→    void *ctx = interp->hostCtx;
    73→
    74→    /* Free global frame */
    75→    if (interp->globalFrame) {
    76→        host->frameFree(ctx, interp->globalFrame);
    77→    }
    78→
    79→    /* Note: interp itself is from static pool, not freed */
    80→}
    81→
    82→/* ========================================================================
    83→ * Result and Error Handling
    84→ * ======================================================================== */
    85→
    86→TclObj *tclGetResult(TclInterp *interp) {
    87→    return interp->result;
    88→}
    89→
    90→void tclSetResult(TclInterp *interp, TclObj *result) {
    91→    interp->result = result;
    92→    interp->resultCode = TCL_OK;
    93→}
    94→
    95→void tclSetResultStr(TclInterp *interp, const char *s, size_t len) {
    96→    if (len == (size_t)-1) {
    97→        len = tclStrlen(s);
    98→    }
    99→    interp->result = interp->host->newString(s, len);
   100→    interp->resultCode = TCL_OK;
   101→}
   102→
   103→void tclSetError(TclInterp *interp, const char *msg, size_t len) {
   104→    if (len == (size_t)-1) {
   105→        len = tclStrlen(msg);
   106→    }
   107→    interp->result = interp->host->newString(msg, len);
   108→    interp->resultCode = TCL_ERROR;
   109→}
   110→
   111→void tclSetErrorCode(TclInterp *interp, TclObj *code) {
   112→    interp->errorCode = code;
   113→}
   114→
   115→void tclAddErrorInfo(TclInterp *interp, const char *info, size_t len) {
   116→    if (len == (size_t)-1) {
   117→        len = tclStrlen(info);
   118→    }
   119→
   120→    const TclHost *host = interp->host;
   121→
   122→    if (!interp->errorInfo) {
   123→        interp->errorInfo = host->newString(info, len);
   124→    } else {
   125→        /* Append to existing error info */
   126→        size_t existingLen;
   127→        const char *existing = host->getStringPtr(interp->errorInfo, &existingLen);
   128→
   129→        void *arena = host->arenaPush(interp->hostCtx);
   130→        char *buf = host->arenaAlloc(arena, existingLen + len + 1, 1);
   131→
   132→        for (size_t i = 0; i < existingLen; i++) {
   133→            buf[i] = existing[i];
   134→        }
   135→        for (size_t i = 0; i < len; i++) {
   136→            buf[existingLen + i] = info[i];
   137→        }
   138→        buf[existingLen + len] = '\0';
   139→
   140→        interp->errorInfo = host->newString(buf, existingLen + len);
   141→        host->arenaPop(interp->hostCtx, arena);
   142→    }
   143→}
   144→
   145→/* ========================================================================
   146→ * Legacy Eval State Management (kept for API compatibility)
   147→ *
   148→ * These functions are no longer used internally since evaluation now
   149→ * goes through the tree-walking evaluator. They are kept as stubs in
   150→ * case external code references them.
   151→ * ======================================================================== */
   152→
   153→void tclEvalStateInit(TclEvalState *state, TclInterp *interp,
   154→                      const char *script, size_t len) {
   155→    (void)state;
   156→    (void)interp;
   157→    (void)script;
   158→    (void)len;
   159→}
   160→
   161→void tclEvalStateCleanup(TclEvalState *state, TclInterp *interp) {
   162→    (void)state;
   163→    (void)interp;
   164→}
   165→
   166→TclEvalStatus tclEvalStep(TclInterp *interp, TclEvalState *state) {
   167→    (void)interp;
   168→    (void)state;
   169→    return EVAL_DONE;
   170→}
   171→
   172→/* ========================================================================
   173→ * High-Level Eval Functions
   174→ *
   175→ * Uses the tree-walking evaluator (tree_eval.c) instead of the old
   176→ * text-based trampoline. The tree evaluator parses the script into an AST
   177→ * and evaluates by walking the tree, enabling proper coroutine support.
   178→ * ======================================================================== */
   179→
   180→TclResult tclEvalScript(TclInterp *interp, const char *script, size_t len) {
   181→    return tclTreeEvalStr(interp, script, len);
   182→}
   183→
   184→TclResult tclEvalBracketed(TclInterp *interp, const char *cmd, size_t len) {
   185→    /* Save current result */
   186→    TclObj *savedResult = interp->result;
   187→    TclResult savedCode = interp->resultCode;
   188→
   189→    /* Evaluate bracketed command */
   190→    TclResult result = tclEvalScript(interp, cmd, len);
   191→
   192→    if (result != TCL_OK) {
   193→        /* Keep error result */
   194→        return result;
   195→    }
   196→
   197→    /* Command succeeded - result is in interp->result */
   198→    /* Restore saved code but keep new result */
   199→    (void)savedResult;
   200→    (void)savedCode;
   201→
   202→    return TCL_OK;
   203→}
   204→
   205→/* ========================================================================
   206→ * Public API (from tclc.h)
   207→ * ======================================================================== */
   208→
   209→TclResult tclEval(TclInterp *interp, TclObj *script) {
   210→    size_t len;
   211→    const char *str = interp->host->getStringPtr(script, &len);
   212→    return tclEvalScript(interp, str, len);
   213→}
   214→
   215→TclResult tclEvalStr(TclInterp *interp, const char *script, size_t len) {
   216→    if (len == (size_t)-1) {
   217→        len = tclStrlen(script);
   218→    }
   219→    return tclEvalScript(interp, script, len);
   220→}
   221→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
