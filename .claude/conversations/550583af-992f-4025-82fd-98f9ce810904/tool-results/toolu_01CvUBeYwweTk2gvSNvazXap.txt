     1→/*
     2→ * internal.h - TCL Core Internal Declarations
     3→ *
     4→ * This header defines types and functions shared between TCL core modules.
     5→ * It is NOT part of the public API - use tclc.h for the host interface.
     6→ */
     7→
     8→#ifndef TCLC_INTERNAL_H
     9→#define TCLC_INTERNAL_H
    10→
    11→#include "tclc.h"
    12→
    13→/* ========================================================================
    14→ * Word Types and Token Representation
    15→ * ======================================================================== */
    16→
    17→typedef enum TclWordType {
    18→    TCL_WORD_BARE,      /* Unquoted word */
    19→    TCL_WORD_BRACES,    /* {braced} - no substitution */
    20→    TCL_WORD_QUOTES,    /* "quoted" - substitution enabled */
    21→} TclWordType;
    22→
    23→/* A single word/token in a command */
    24→typedef struct TclWord {
    25→    const char  *start;     /* Pointer into source buffer */
    26→    size_t       len;       /* Length in bytes */
    27→    TclWordType  type;      /* Quoting type */
    28→    int          line;      /* Source line number */
    29→} TclWord;
    30→
    31→/* A parsed command (array of words) */
    32→typedef struct TclParsedCmd {
    33→    TclWord    *words;      /* Array of words (arena-allocated) */
    34→    int         wordCount;  /* Number of words */
    35→    int         lineStart;  /* Line where command starts */
    36→    int         lineEnd;    /* Line where command ends */
    37→} TclParsedCmd;
    38→
    39→/* ========================================================================
    40→ * Lexer State
    41→ * ======================================================================== */
    42→
    43→typedef struct TclLexer {
    44→    const char *script;     /* Full script being parsed */
    45→    const char *pos;        /* Current position */
    46→    const char *end;        /* End of script */
    47→    int         line;       /* Current line number */
    48→} TclLexer;
    49→
    50→/* ========================================================================
    51→ * Parser State
    52→ * ======================================================================== */
    53→
    54→typedef struct TclParser {
    55→    TclLexer    lex;        /* Embedded lexer */
    56→    TclInterp  *interp;     /* Interpreter for error reporting */
    57→    void       *arena;      /* Arena for temporary allocations */
    58→    size_t      arenaMark;  /* Mark for resetting arena */
    59→} TclParser;
    60→
    61→/* ========================================================================
    62→ * Substitution Flags (use values from tclc.h)
    63→ * ======================================================================== */
    64→
    65→/* Use the TclSubstFlag enum from tclc.h:
    66→ * TCL_SUBST_COMMANDS  (1 << 0)
    67→ * TCL_SUBST_VARIABLES (1 << 1)
    68→ * TCL_SUBST_BACKSLASH (1 << 2)
    69→ * TCL_SUBST_ALL       (TCL_SUBST_COMMANDS | TCL_SUBST_VARIABLES | TCL_SUBST_BACKSLASH)
    70→ */
    71→
    72→/* ========================================================================
    73→ * Eval State Machine (Trampoline)
    74→ * ======================================================================== */
    75→
    76→typedef enum TclEvalPhase {
    77→    EVAL_PHASE_PARSE,       /* Get next command */
    78→    EVAL_PHASE_SUBST,       /* Substitute words */
    79→    EVAL_PHASE_LOOKUP,      /* Find command */
    80→    EVAL_PHASE_DISPATCH,    /* Call command */
    81→    EVAL_PHASE_RESULT,      /* Handle return code */
    82→    EVAL_PHASE_DONE,        /* Script complete */
    83→} TclEvalPhase;
    84→
    85→typedef enum TclEvalStatus {
    86→    EVAL_CONTINUE,          /* More work to do */
    87→    EVAL_DONE,              /* Result ready */
    88→    EVAL_YIELD,             /* Coroutine yielding */
    89→} TclEvalStatus;
    90→
    91→typedef struct TclEvalState {
    92→    TclParser       parser;         /* Parser state */
    93→    TclParsedCmd    currentCmd;     /* Current command being executed */
    94→    TclObj        **substWords;     /* Substituted word values */
    95→    int             substCount;     /* Number of substituted words */
    96→    TclEvalPhase    phase;          /* Current phase */
    97→    TclCmdInfo      cmdInfo;        /* Looked-up command info */
    98→    int             wordIndex;      /* Current word being substituted */
    99→} TclEvalState;
   100→
   101→/* ========================================================================
   102→ * Builtin Command Entry
   103→ * ======================================================================== */
   104→
   105→typedef TclResult (*TclBuiltinProc)(TclInterp *interp, int objc, TclObj **objv);
   106→
   107→typedef struct TclBuiltinEntry {
   108→    const char     *name;
   109→    TclBuiltinProc  proc;
   110→} TclBuiltinEntry;
   111→
   112→/* ========================================================================
   113→ * Lexer Functions (lexer.c)
   114→ * ======================================================================== */
   115→
   116→/* Initialize lexer state */
   117→void tclLexerInit(TclLexer *lex, const char *script, size_t len);
   118→
   119→/* Skip whitespace (not newlines), handle backslash-newline */
   120→void tclLexerSkipSpace(TclLexer *lex);
   121→
   122→/* Skip to end of line (for comments) */
   123→void tclLexerSkipLine(TclLexer *lex);
   124→
   125→/* Check if at command terminator (newline, semicolon, EOF) */
   126→int tclLexerAtCommandEnd(TclLexer *lex);
   127→
   128→/* Check if at comment start (# at command start) */
   129→int tclLexerAtComment(TclLexer *lex);
   130→
   131→/* Check if at end of input */
   132→int tclLexerAtEnd(TclLexer *lex);
   133→
   134→/* Parse a single word, returns 0 on success, -1 on error */
   135→int tclLexerNextWord(TclLexer *lex, TclWord *word, TclInterp *interp);
   136→
   137→/* ========================================================================
   138→ * Parser Functions (parser.c)
   139→ * ======================================================================== */
   140→
   141→/* Initialize parser state */
   142→void tclParserInit(TclParser *parser, TclInterp *interp,
   143→                   const char *script, size_t len);
   144→
   145→/* Clean up parser state */
   146→void tclParserCleanup(TclParser *parser);
   147→
   148→/* Parse next command, returns 0 on success, -1 on error, 1 on EOF */
   149→int tclParserNextCommand(TclParser *parser, TclParsedCmd *cmd);
   150→
   151→/* ========================================================================
   152→ * Substitution Functions (subst.c)
   153→ * ======================================================================== */
   154→
   155→/* Perform substitution on a word, returns substituted TclObj */
   156→TclObj *tclSubstWord(TclInterp *interp, TclWord *word, int flags);
   157→
   158→/* Perform substitution on raw string */
   159→TclObj *tclSubstString(TclInterp *interp, const char *str, size_t len, int flags);
   160→
   161→/* Process backslash escape, returns number of input chars consumed */
   162→int tclSubstBackslashChar(const char *src, const char *end, char *out);
   163→
   164→/* ========================================================================
   165→ * Eval Functions (eval.c)
   166→ * ======================================================================== */
   167→
   168→/* Initialize eval state for a script */
   169→void tclEvalStateInit(TclEvalState *state, TclInterp *interp,
   170→                      const char *script, size_t len);
   171→
   172→/* Clean up eval state */
   173→void tclEvalStateCleanup(TclEvalState *state, TclInterp *interp);
   174→
   175→/* Execute one step of evaluation */
   176→TclEvalStatus tclEvalStep(TclInterp *interp, TclEvalState *state);
   177→
   178→/* Execute a complete script (wrapper around trampoline) */
   179→TclResult tclEvalScript(TclInterp *interp, const char *script, size_t len);
   180→
   181→/* Execute command substitution [cmd] */
   182→TclResult tclEvalBracketed(TclInterp *interp, const char *cmd, size_t len);
   183→
   184→/* ========================================================================
   185→ * Tree-Walking Eval Functions (tree_eval.c)
   186→ * ======================================================================== */
   187→
   188→/* Forward declare AST node type */
   189→struct TclAstNode;
   190→
   191→/* Evaluate an AST (tree-walking) */
   192→TclResult tclTreeEvalAst(TclInterp *interp, struct TclAstNode *ast);
   193→
   194→/* Parse and evaluate a script string using tree-walking */
   195→TclResult tclTreeEvalStr(TclInterp *interp, const char *script, size_t len);
   196→
   197→/* ========================================================================
   198→ * Builtin Functions (builtins.c)
   199→ * ======================================================================== */
   200→
   201→/* Look up builtin command by name, returns index or -1 */
   202→int tclBuiltinLookup(const char *name, size_t len);
   203→
   204→/* Get builtin table entry */
   205→const TclBuiltinEntry *tclBuiltinGet(int index);
   206→
   207→/* Get number of builtins */
   208→int tclBuiltinCount(void);
   209→
   210→/* I/O commands (builtin_chan.c) */
   211→TclResult tclCmdPuts(TclInterp *interp, int objc, TclObj **objv);
   212→TclResult tclCmdOpen(TclInterp *interp, int objc, TclObj **objv);
   213→TclResult tclCmdClose(TclInterp *interp, int objc, TclObj **objv);
   214→TclResult tclCmdGets(TclInterp *interp, int objc, TclObj **objv);
   215→TclResult tclCmdRead(TclInterp *interp, int objc, TclObj **objv);
   216→TclResult tclCmdChan(TclInterp *interp, int objc, TclObj **objv);
   217→
   218→TclResult tclCmdString(TclInterp *interp, int objc, TclObj **objv);
   219→TclResult tclCmdExpr(TclInterp *interp, int objc, TclObj **objv);
   220→TclResult tclCmdSubst(TclInterp *interp, int objc, TclObj **objv);
   221→
   222→/* Scope commands (builtin_global.c, builtin_upvar.c, builtin_uplevel.c) */
   223→TclResult tclCmdGlobal(TclInterp *interp, int objc, TclObj **objv);
   224→TclResult tclCmdUpvar(TclInterp *interp, int objc, TclObj **objv);
   225→TclResult tclCmdUplevel(TclInterp *interp, int objc, TclObj **objv);
   226→
   227→/* Dict command (builtin_dict.c) */
   228→TclResult tclCmdDict(TclInterp *interp, int objc, TclObj **objv);
   229→
   230→/* Exec command (builtin_exec.c) */
   231→TclResult tclCmdExec(TclInterp *interp, int objc, TclObj **objv);
   232→
   233→/* File command (builtin_file.c) */
   234→TclResult tclCmdFile(TclInterp *interp, int objc, TclObj **objv);
   235→
   236→/* Break/continue commands (builtin_break.c) */
   237→TclResult tclCmdBreak(TclInterp *interp, int objc, TclObj **objv);
   238→TclResult tclCmdContinue(TclInterp *interp, int objc, TclObj **objv);
   239→
   240→/* List commands (builtin_list.c) */
   241→TclResult tclCmdList(TclInterp *interp, int objc, TclObj **objv);
   242→TclResult tclCmdLlength(TclInterp *interp, int objc, TclObj **objv);
   243→TclResult tclCmdLindex(TclInterp *interp, int objc, TclObj **objv);
   244→TclResult tclCmdLrange(TclInterp *interp, int objc, TclObj **objv);
   245→TclResult tclCmdLappend(TclInterp *interp, int objc, TclObj **objv);
   246→TclResult tclCmdLassign(TclInterp *interp, int objc, TclObj **objv);
   247→TclResult tclCmdLedit(TclInterp *interp, int objc, TclObj **objv);
   248→TclResult tclCmdLinsert(TclInterp *interp, int objc, TclObj **objv);
   249→TclResult tclCmdLpop(TclInterp *interp, int objc, TclObj **objv);
   250→TclResult tclCmdLremove(TclInterp *interp, int objc, TclObj **objv);
   251→TclResult tclCmdLrepeat(TclInterp *interp, int objc, TclObj **objv);
   252→TclResult tclCmdLreplace(TclInterp *interp, int objc, TclObj **objv);
   253→TclResult tclCmdLseq(TclInterp *interp, int objc, TclObj **objv);
   254→TclResult tclCmdLset(TclInterp *interp, int objc, TclObj **objv);
   255→TclResult tclCmdJoin(TclInterp *interp, int objc, TclObj **objv);
   256→TclResult tclCmdSplit(TclInterp *interp, int objc, TclObj **objv);
   257→TclResult tclCmdLsort(TclInterp *interp, int objc, TclObj **objv);
   258→TclResult tclCmdLreverse(TclInterp *interp, int objc, TclObj **objv);
   259→TclResult tclCmdLsearch(TclInterp *interp, int objc, TclObj **objv);
   260→
   261→/* Error handling commands (builtin_error.c) */
   262→TclResult tclCmdError(TclInterp *interp, int objc, TclObj **objv);
   263→TclResult tclCmdCatch(TclInterp *interp, int objc, TclObj **objv);
   264→TclResult tclCmdThrow(TclInterp *interp, int objc, TclObj **objv);
   265→TclResult tclCmdTry(TclInterp *interp, int objc, TclObj **objv);
   266→
   267→/* Procedure commands (builtin_proc.c) */
   268→TclResult tclCmdApply(TclInterp *interp, int objc, TclObj **objv);
   269→TclResult tclCmdProc(TclInterp *interp, int objc, TclObj **objv);
   270→TclResult tclCmdRename(TclInterp *interp, int objc, TclObj **objv);
   271→TclResult tclCmdReturn(TclInterp *interp, int objc, TclObj **objv);
   272→
   273→/* Variable commands (builtin_var.c) */
   274→TclResult tclCmdSet(TclInterp *interp, int objc, TclObj **objv);
   275→TclResult tclCmdIncr(TclInterp *interp, int objc, TclObj **objv);
   276→TclResult tclCmdAppend(TclInterp *interp, int objc, TclObj **objv);
   277→TclResult tclCmdUnset(TclInterp *interp, int objc, TclObj **objv);
   278→
   279→/* Array command (builtin_array.c) */
   280→TclResult tclCmdArray(TclInterp *interp, int objc, TclObj **objv);
   281→
   282→/* Info command (builtin_info.c) */
   283→TclResult tclCmdInfo(TclInterp *interp, int objc, TclObj **objv);
   284→
   285→/* Control flow commands (builtin_control.c) */
   286→TclResult tclCmdIf(TclInterp *interp, int objc, TclObj **objv);
   287→TclResult tclCmdWhile(TclInterp *interp, int objc, TclObj **objv);
   288→TclResult tclCmdFor(TclInterp *interp, int objc, TclObj **objv);
   289→TclResult tclCmdForeach(TclInterp *interp, int objc, TclObj **objv);
   290→TclResult tclCmdLmap(TclInterp *interp, int objc, TclObj **objv);
   291→
   292→/* Event loop commands (builtin_event.c) */
   293→TclResult tclCmdAfter(TclInterp *interp, int objc, TclObj **objv);
   294→TclResult tclCmdVwait(TclInterp *interp, int objc, TclObj **objv);
   295→TclResult tclCmdUpdate(TclInterp *interp, int objc, TclObj **objv);
   296→TclResult tclCmdFileevent(TclInterp *interp, int objc, TclObj **objv);
   297→
   298→/* Regexp commands (builtin_regexp.c) */
   299→TclResult tclCmdRegexp(TclInterp *interp, int objc, TclObj **objv);
   300→TclResult tclCmdRegsub(TclInterp *interp, int objc, TclObj **objv);
   301→
   302→/* Coroutine commands (builtin_coroutine.c) */
   303→TclResult tclCmdCoroutine(TclInterp *interp, int objc, TclObj **objv);
   304→TclResult tclCmdYield(TclInterp *interp, int objc, TclObj **objv);
   305→TclResult tclCmdYieldto(TclInterp *interp, int objc, TclObj **objv);
   306→
   307→/* ========================================================================
   308→ * Loop State for Coroutine Suspend/Resume
   309→ * ======================================================================== */
   310→
   311→typedef enum {
   312→    LOOP_PHASE_TEST,      /* Evaluating condition */
   313→    LOOP_PHASE_BODY,      /* Executing body */
   314→    LOOP_PHASE_NEXT,      /* Executing increment (for) */
   315→    LOOP_PHASE_DONE       /* Loop complete */
   316→} TclLoopPhase;
   317→
   318→typedef enum {
   319→    LOOP_TYPE_WHILE,
   320→    LOOP_TYPE_FOR,
   321→    LOOP_TYPE_FOREACH
   322→} TclLoopType;
   323→
   324→typedef struct TclLoopState {
   325→    TclLoopType     type;
   326→    TclLoopPhase    phase;
   327→
   328→    /* Common fields */
   329→    const char     *bodyStr;
   330→    size_t          bodyLen;
   331→    size_t          bodyResumeOffset;  /* Offset into body to resume from after yield */
   332→
   333→    /* For while/for: condition */
   334→    const char     *testStr;
   335→    size_t          testLen;
   336→
   337→    /* For for: next clause */
   338→    const char     *nextStr;
   339→    size_t          nextLen;
   340→
   341→    /* For foreach: iteration state */
   342→    TclObj        **elems;        /* List elements */
   343→    size_t          elemCount;
   344→    size_t          currentIndex; /* Which element we're on */
   345→    const char     *varName;      /* Variable name */
   346→    size_t          varNameLen;
   347→
   348→    /* Link to parent loop (for nested loops) */
   349→    struct TclLoopState *parent;
   350→} TclLoopState;
   351→
   352→/* Coroutine support */
   353→typedef struct TclCoroutine TclCoroutine;
   354→TclCoroutine *tclCoroLookup(const char *name, size_t len);
   355→TclResult tclCoroInvoke(TclInterp *interp, TclCoroutine *coro, int objc, TclObj **objv);
   356→const char *tclCoroCurrentName(size_t *lenOut);
   357→int tclCoroYieldPending(void);
   358→void tclCoroClearYield(void);
   359→TclCoroutine *tclCoroGetCurrent(void);
   360→
   361→/* Loop state management for coroutines */
   362→TclLoopState *tclCoroLoopPush(TclLoopType type);
   363→void tclCoroLoopPop(void);
   364→TclLoopState *tclCoroLoopCurrent(void);
   365→
   366→/* Yield offset tracking for resuming within loop body */
   367→void tclCoroSetYieldOffset(size_t offset);
   368→size_t tclCoroGetYieldOffset(void);
   369→
   370→/* ========================================================================
   371→ * Interpreter Functions (from tclc.h, implemented in eval.c)
   372→ * ======================================================================== */
   373→
   374→/* These are declared in tclc.h but we note them here for reference:
   375→ *
   376→ * TclInterp* tclInterpNew(const TclHost *host, void *hostCtx);
   377→ * void tclInterpFree(TclInterp *interp);
   378→ * TclResult tclEval(TclInterp *interp, TclObj *script);
   379→ * TclResult tclEvalStr(TclInterp *interp, const char *script, size_t len);
   380→ * TclObj* tclGetResult(TclInterp *interp);
   381→ * void tclSetResult(TclInterp *interp, TclObj *result);
   382→ */
   383→
   384→/* ========================================================================
   385→ * Helper Macros
   386→ * ======================================================================== */
   387→
   388→/* String comparison helpers for command lookup */
   389→#define TCL_STREQ(a, alen, b) \
   390→    ((alen) == sizeof(b) - 1 && tclStrncmp((a), (b), (alen)) == 0)
   391→
   392→/* Internal string comparison (no libc) */
   393→int tclStrncmp(const char *a, const char *b, size_t n);
   394→size_t tclStrlen(const char *s);
   395→
   396→#endif /* TCLC_INTERNAL_H */
   397→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
