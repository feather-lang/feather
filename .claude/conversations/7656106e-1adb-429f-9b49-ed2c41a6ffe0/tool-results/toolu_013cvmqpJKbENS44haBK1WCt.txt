coroutine(n)                 Tcl Built-In Commands                coroutine(n)

______________________________________________________________________________

NNAAMMEE
       coroutine, yield, yieldto, coroinject, coroprobe - Create and produce
       values from coroutines

SSYYNNOOPPSSIISS
       ccoorroouuttiinnee _n_a_m_e _c_o_m_m_a_n_d ?_a_r_g_._._.?

       yyiieelldd ?_v_a_l_u_e?
       yyiieellddttoo _c_o_m_m_a_n_d ?_a_r_g_._._.?
       _n_a_m_e ?_v_a_l_u_e_._._.?

       ccoorrooiinnjjeecctt _c_o_r_o_N_a_m_e _c_o_m_m_a_n_d ?_a_r_g_._._.?                                    │
       ccoorroopprroobbee _c_o_r_o_N_a_m_e _c_o_m_m_a_n_d ?_a_r_g_._._.?                                     │
______________________________________________________________________________

DDEESSCCRRIIPPTTIIOONN
       The ccoorroouuttiinnee command creates a new coroutine context (with associated
       command) named _n_a_m_e and executes that context by calling _c_o_m_m_a_n_d,
       passing in the other remaining arguments without further
       interpretation. Once _c_o_m_m_a_n_d returns normally or with an exception
       (e.g., an error) the coroutine context _n_a_m_e is deleted.

       Within the context, values may be generated as results by using the
       yyiieelldd command; if no _v_a_l_u_e is supplied, the empty string is used.  When
       that is called, the context will suspend execution and the ccoorroouuttiinnee
       command will return the argument to yyiieelldd. The execution of the context
       can then be resumed by calling the context command, optionally passing
       in the _s_i_n_g_l_e value to use as the result of the yyiieelldd call that caused
       the context to be suspended. If the coroutine context never yields and
       instead returns conventionally, the result of the ccoorroouuttiinnee command
       will be the result of the evaluation of the context.

       The coroutine may also suspend its execution by use of the yyiieellddttoo
       command, which instead of returning, cedes execution to some command
       called _c_o_m_m_a_n_d (resolved in the context of the coroutine) and to which
       _a_n_y _n_u_m_b_e_r of arguments may be passed. Since every coroutine has a
       context command, yyiieellddttoo can be used to transfer control directly from
       one coroutine to another (this is only advisable if the two coroutines
       are expecting this to happen) but _a_n_y command may be the target. If a
       coroutine is suspended by this mechanism, the coroutine processing can
       be resumed by calling the context command optionally passing in an
       arbitrary number of arguments. The return value of the yyiieellddttoo call
       will be the list of arguments passed to the context command; it is up
       to the caller to decide what to do with those values.

       The recommended way of writing a version of yyiieelldd that allows
       resumption with multiple arguments is by using yyiieellddttoo and the rreettuurrnn
       command, like this:

              proc yieldMultiple {value} {
                  tailcall yyiieellddttoo string cat $value
              }

       The coroutine can also be deleted by destroying the command _n_a_m_e, and
       the name of the current coroutine can be retrieved by using iinnffoo
       ccoorroouuttiinnee.  If there are deletion traces on variables in the
       coroutine's implementation, they will fire at the point when the
       coroutine is explicitly deleted (or, naturally, if the command returns
       conventionally).

       At the point when _c_o_m_m_a_n_d is called, the current namespace will be the
       global namespace and there will be no stack frames above it (in the
       sense of uuppvvaarr and uupplleevveell). However, which command to call will be
       determined in the namespace that the ccoorroouuttiinnee command was called from.

       A suspended coroutine (i.e., one that has yyiieelldded or yyiieellddttoo-d) may     │
       have its state inspected (or modified) at that point by using ccoorroopprroobbee │
       to run a command at the point where the coroutine is at. The command    │
       takes the name of the coroutine to run the command in, _c_o_r_o_N_a_m_e, and    │
       the name of a command (any any arguments it requires) to immediately    │
       run at that point. The result of that command is the result of the      │
       ccoorroopprroobbee command, and the gross state of the coroutine remains the     │
       same afterwards (i.e., the coroutine is still expecting the results of  │
       a yyiieelldd or yyiieellddttoo as before) though variables may have been changed.   │

       Similarly, the ccoorrooiinnjjeecctt command may be used to place a command to be  │
       run inside a suspended coroutine (when it is resumed) to process        │
       arguments, with quite a bit of similarity to ccoorroopprroobbee. However, with   │
       ccoorrooiinnjjeecctt there are several key differences:

       •      The coroutine is not immediately resumed after the injection has │
              been done.  A consequence of this is that multiple injections    │
              may be done before the coroutine is resumed. The injected        │
              commands are performed in _r_e_v_e_r_s_e _o_r_d_e_r _o_f _d_e_f_i_n_i_t_i_o_n (that is,  │
              they are internally stored on a stack).

       •      An additional two arguments are appended to the list of          │
              arguments to be run (that is, the _c_o_m_m_a_n_d and its _a_r_g_s are       │
              extended by two elements).  The first is the name of the command │
              that suspended the coroutine (yyiieelldd or yyiieellddttoo), and the second  │
              is the argument (or list of arguments, in the case of yyiieellddttoo)   │
              that is the current resumption value.

       •      The result of the injected command is used as the result of the  │
              yyiieelldd or yyiieellddttoo that caused the coroutine to become suspended.  │
              Where there are multiple injected commands, the result of one    │
              becomes the resumption value processed by the next.              │

       The injection is a one-off. It is not retained once it has been         │
       executed. It may yyiieelldd or yyiieellddttoo as part of its execution.             │

       Note that running coroutines may be neither probed nor injected; the    │
       operations may only be applied to coroutines that are suspended. (If a  │
       coroutine is running then any introspection code would be merely        │
       inspecting the state of where it is currently running;                  │
       ccoorrooiinnjjeecctt/ccoorroopprroobbee are unnecessary in that case.)

EEXXAAMMPPLLEESS
       This example shows a coroutine that will produce an infinite sequence
       of even values, and a loop that consumes the first ten of them.

              proc allNumbers {} {
                  yyiieelldd
                  set i 0
                  while 1 {
                      yyiieelldd $i
                      incr i 2
                  }
              }
              ccoorroouuttiinnee nextNumber allNumbers
              for {set i 0} {$i < 10} {incr i} {
                  puts "received [_n_e_x_t_N_u_m_b_e_r]"
              }
              rename nextNumber {}

       In this example, the coroutine acts to add up the arguments passed to
       it.

              ccoorroouuttiinnee accumulator apply {{} {
                  set x 0
                  while 1 {
                      incr x [yyiieelldd $x]
                  }
              }}
              for {set i 0} {$i < 10} {incr i} {
                  puts "$i -> [_a_c_c_u_m_u_l_a_t_o_r $i]"
              }

       This example demonstrates the use of coroutines to implement the
       classic Sieve of Eratosthenes algorithm for finding prime numbers. Note
       the creation of coroutines inside a coroutine.

              proc filterByFactor {source n} {
                  yyiieelldd [info coroutine]
                  while 1 {
                      set x [_$_s_o_u_r_c_e]
                      if {$x % $n} {
                          yyiieelldd $x
                      }
                  }
              }
              ccoorroouuttiinnee allNumbers apply {{} {while 1 {yyiieelldd [incr x]}}}
              ccoorroouuttiinnee eratosthenes apply {c {
                  yyiieelldd
                  while 1 {
                      set n [_$_c]
                      yyiieelldd $n
                      set c [ccoorroouuttiinnee prime$n filterByFactor $c $n]
                  }
              }} allNumbers
              for {set i 1} {$i <= 20} {incr i} {
                  puts "prime#$i = [_e_r_a_t_o_s_t_h_e_n_e_s]"
              }

       This example shows how a value can be passed around a group of three
       coroutines that yield to each other:

              proc juggler {name target {value ""}} {
                  if {$value eq ""} {
                      set value [yyiieelldd [info coroutine]]
                  }
                  while {$value ne ""} {
                      puts "$name : $value"
                      set value [string range $value 0 end-1]
                      lassign [yyiieellddttoo _$_t_a_r_g_e_t $value] value
                  }
              }
              ccoorroouuttiinnee j1 juggler Larry [
                  ccoorroouuttiinnee j2 juggler Curly [
                      ccoorroouuttiinnee j3 juggler Moe j1]] "Nyuck!Nyuck!Nyuck!"

       This example shows a simple coroutine that collects non-empty values    │
       and returns a list of them when not given an argument. It also shows    │
       how we can look inside the coroutine to find out what it is doing, and  │
       how we can modify the input on a one-off basis.                         │

              proc collectorImpl {} {                                          │
                  set me [info coroutine]                                      │
                  set accumulator {}                                           │
                  for {set val [yyiieelldd $me]} {$val ne ""} {set val [yyiieelldd]} {   │
                      lappend accumulator $val                                 │
                  }                                                            │
                  return $accumulator                                          │
              }                                                                │

              ccoorroouuttiinnee collect collectorImpl                                  │
              _c_o_l_l_e_c_t 123                                                      │
              _c_o_l_l_e_c_t "abc def"                                                │
              _c_o_l_l_e_c_t 456                                                      │

              puts [ccoorroopprroobbee _c_o_l_l_e_c_t set accumulator]                         │
              # ==> 123 {abc def} 456                                          │

              _c_o_l_l_e_c_t "pqr"                                                    │

              ccoorrooiinnjjeecctt _c_o_l_l_e_c_t apply {{type value} {                         │
                  puts "Received '$value' at a $type in [info coroutine]"      │
                  return [string toupper $value]                               │
              }}                                                               │

              _c_o_l_l_e_c_t rst                                                      │
              # ==> Received 'rst' at a yield in ::collect                     │
              _c_o_l_l_e_c_t xyz                                                      │

              puts [_c_o_l_l_e_c_t]                                                   │
              # ==> 123 {abc def} 456 pqr RST xyz                              │

   DDEETTAAIILLEEDD SSEEMMAANNTTIICCSS
       This example demonstrates that coroutines start from the global
       namespace, and that _c_o_m_m_a_n_d resolution happens before the coroutine
       stack is created.

              proc report {where level} {
                  # Where was the caller called from?
                  set ns [uplevel 2 {namespace current}]
                  yyiieelldd "made $where $level context=$ns name=[info coroutine]"
              }
              proc example {} {
                  report outer [info level]
              }
              namespace eval demo {
                  proc example {} {
                      report inner [info level]
                  }
                  proc makeExample {} {
                      puts "making from [info level]"
                      puts [ccoorroouuttiinnee coroEg example]
                  }
                  makeExample
              }

       Which produces the output below. In particular, we can see that stack
       manipulation has occurred (comparing the levels from the first and
       second line) and that the parent level in the coroutine is the global
       namespace. We can also see that coroutine names are local to the
       current namespace if not qualified, and that coroutines may yield at
       depth (e.g., in called procedures).

              making from 2
              made inner 1 context=:: name=::demo::coroEg

SSEEEE AALLSSOO
       apply(n), info(n), proc(n), return(n)

KKEEYYWWOORRDDSS
       coroutine, generator

Tcl                                   8.6                         coroutine(n)