     1→/*
     2→ * host.c - TclHost Callback Table for C Host (GLib version)
     3→ *
     4→ * Assembles all host callbacks into the TclHost structure using GLib.
     5→ */
     6→
     7→#include "../../core/tclc.h"
     8→#include <glib.h>
     9→#include <glib/gstdio.h>
    10→#include <string.h>
    11→#include <unistd.h>
    12→#include <sys/stat.h>
    13→#include <sys/wait.h>
    14→#include <signal.h>
    15→
    16→/* External functions from object.c */
    17→extern TclObj *hostNewString(const char *s, size_t len);
    18→extern TclObj *hostNewInt(int64_t val);
    19→extern TclObj *hostNewDouble(double val);
    20→extern TclObj *hostNewBool(int val);
    21→extern TclObj *hostNewList(TclObj **elems, size_t count);
    22→extern TclObj *hostNewDict(void);
    23→extern TclObj *hostDup(TclObj *obj);
    24→extern void hostFreeObj(TclObj *obj);
    25→extern const char *hostGetStringPtr(TclObj *obj, size_t *lenOut);
    26→extern int hostAsInt(TclObj *obj, int64_t *out);
    27→extern int hostAsDouble(TclObj *obj, double *out);
    28→extern int hostAsBool(TclObj *obj, int *out);
    29→extern int hostAsList(TclObj *obj, TclObj ***elemsOut, size_t *countOut);
    30→extern size_t hostStringLength(TclObj *str);
    31→extern int hostStringCompare(TclObj *a, TclObj *b);
    32→extern size_t hostListLengthImpl(TclObj *list);
    33→extern TclObj *hostListIndexImpl(TclObj *list, size_t idx);
    34→
    35→/* External functions from vars.c */
    36→extern void *hostVarsNew(void *ctx);
    37→extern void hostVarsFree(void *ctx, void *vars);
    38→extern TclObj *hostVarGet(void *vars, const char *name, size_t len);
    39→extern void hostVarSet(void *vars, const char *name, size_t len, TclObj *val);
    40→extern void hostVarUnset(void *vars, const char *name, size_t len);
    41→extern int hostVarExists(void *vars, const char *name, size_t len);
    42→extern TclObj *hostVarNames(void *vars, const char *pattern);
    43→extern TclObj *hostVarNamesLocal(void *vars, const char *pattern);
    44→extern void hostVarLink(void *localVars, const char *localName, size_t localLen,
    45→                        void *targetVars, const char *targetName, size_t targetLen);
    46→extern void hostArraySet(void *vars, const char *arr, size_t arrLen,
    47→                         const char *key, size_t keyLen, TclObj *val);
    48→extern TclObj *hostArrayGet(void *vars, const char *arr, size_t arrLen,
    49→                            const char *key, size_t keyLen);
    50→extern int hostArrayExists(void *vars, const char *arr, size_t arrLen,
    51→                           const char *key, size_t keyLen);
    52→extern TclObj *hostArrayNames(void *vars, const char *arr, size_t arrLen,
    53→                              const char *pattern);
    54→extern void hostArrayUnset(void *vars, const char *arr, size_t arrLen,
    55→                           const char *key, size_t keyLen);
    56→extern size_t hostArraySize(void *vars, const char *arr, size_t arrLen);
    57→
    58→/* Array search functions */
    59→extern TclObj *hostArrayStartSearch(void *vars, const char *arr, size_t arrLen);
    60→extern int hostArrayAnymore(const char *searchId);
    61→extern TclObj *hostArrayNextElement(const char *searchId);
    62→extern void hostArrayDoneSearch(const char *searchId);
    63→
    64→/* External functions from arena.c */
    65→extern void *hostArenaPush(void *ctx);
    66→extern void hostArenaPop(void *ctx, void *arena);
    67→extern void *hostArenaAlloc(void *arena, size_t size, size_t align);
    68→extern char *hostArenaStrdup(void *arena, const char *s, size_t len);
    69→extern size_t hostArenaMark(void *arena);
    70→extern void hostArenaReset(void *arena, size_t mark);
    71→
    72→/* External functions from channel.c */
    73→extern TclChannel *hostChanOpen(void *ctx, const char *name, const char *mode);
    74→extern void hostChanClose(void *ctx, TclChannel *chan);
    75→extern TclChannel *hostChanStdin(void *ctx);
    76→extern TclChannel *hostChanStdout(void *ctx);
    77→extern TclChannel *hostChanStderr(void *ctx);
    78→extern int hostChanRead(TclChannel *chan, char *buf, size_t len);
    79→extern int hostChanWrite(TclChannel *chan, const char *buf, size_t len);
    80→extern TclObj *hostChanGets(TclChannel *chan, int *eofOut);
    81→extern int hostChanFlush(TclChannel *chan);
    82→extern int hostChanSeek(TclChannel *chan, int64_t offset, int whence);
    83→extern int64_t hostChanTell(TclChannel *chan);
    84→extern int hostChanEof(TclChannel *chan);
    85→extern int hostChanBlocked(TclChannel *chan);
    86→extern int hostChanConfigure(TclChannel *chan, const char *opt, TclObj *val);
    87→extern TclObj *hostChanCget(TclChannel *chan, const char *opt);
    88→extern TclObj *hostChanNames(void *ctx, const char *pattern);
    89→extern void hostChanShare(void *fromCtx, void *toCtx, TclChannel *chan);
    90→extern void hostChanTransfer(void *fromCtx, void *toCtx, TclChannel *chan);
    91→extern int hostChanTruncate(TclChannel *chan, int64_t length);
    92→extern int64_t hostChanCopy(TclChannel *src, TclChannel *dst, int64_t size);
    93→extern int64_t hostChanPending(TclChannel *chan, int input);
    94→extern int hostChanPipe(void *ctx, TclChannel **readChan, TclChannel **writeChan);
    95→extern TclChannel *hostChanLookup(void *ctx, const char *name);
    96→extern const char *hostChanGetName(TclChannel *chan);
    97→
    98→/* ========================================================================
    99→ * Proc Storage
   100→ * ======================================================================== */
   101→
   102→typedef struct ProcDef {
   103→    gchar   *name;      /* Procedure name */
   104→    gsize    nameLen;   /* Name length */
   105→    TclObj  *argList;   /* Argument list */
   106→    TclObj  *body;      /* Procedure body */
   107→} ProcDef;
   108→
   109→/* ========================================================================
   110→ * Interpreter Context
   111→ * ======================================================================== */
   112→
   113→typedef struct HostContext {
   114→    void       *globalVars;   /* Global variable table */
   115→    GHashTable *procs;        /* Procedure definitions: name -> ProcDef* */
   116→} HostContext;
   117→
   118→/* Free a proc definition */
   119→static void procDefFree(gpointer data) {
   120→    ProcDef *proc = data;
   121→    if (proc) {
   122→        g_free(proc->name);
   123→        hostFreeObj(proc->argList);
   124→        hostFreeObj(proc->body);
   125→        g_free(proc);
   126→    }
   127→}
   128→
   129→static void *hostInterpContextNew(void *parentCtx, int safe) {
   130→    (void)parentCtx;
   131→    (void)safe;
   132→
   133→    HostContext *ctx = g_new0(HostContext, 1);
   134→    if (!ctx) return NULL;
   135→
   136→    ctx->globalVars = hostVarsNew(ctx);
   137→    ctx->procs = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, procDefFree);
   138→    return ctx;
   139→}
   140→
   141→static void hostInterpContextFree(void *ctxPtr) {
   142→    HostContext *ctx = ctxPtr;
   143→    if (!ctx) return;
   144→
   145→    g_hash_table_destroy(ctx->procs);
   146→    hostVarsFree(ctx, ctx->globalVars);
   147→    g_free(ctx);
   148→}
   149→
   150→/* ========================================================================
   151→ * Frame Allocation
   152→ * ======================================================================== */
   153→
   154→static TclFrame *hostFrameAlloc(void *ctx) {
   155→    TclFrame *frame = g_new0(TclFrame, 1);
   156→    if (frame) {
   157→        frame->varsHandle = hostVarsNew(ctx);
   158→    }
   159→    return frame;
   160→}
   161→
   162→static void hostFrameFree(void *ctx, TclFrame *frame) {
   163→    if (frame) {
   164→        hostVarsFree(ctx, frame->varsHandle);
   165→        g_free(frame);
   166→    }
   167→}
   168→
   169→/* ========================================================================
   170→ * Command Lookup - finds procedures registered via proc command
   171→ * ======================================================================== */
   172→
   173→static int hostCmdLookup(void *ctxPtr, const char *name, size_t len, TclCmdInfo *out) {
   174→    HostContext *ctx = ctxPtr;
   175→
   176→    gchar *key = g_strndup(name, len);
   177→    ProcDef *proc = g_hash_table_lookup(ctx->procs, key);
   178→    g_free(key);
   179→
   180→    if (proc) {
   181→        out->type = TCL_CMD_PROC;
   182→        out->u.procHandle = proc;
   183→        return 0;
   184→    }
   185→
   186→    out->type = TCL_CMD_NOT_FOUND;
   187→    return 0;
   188→}
   189→
   190→static void *hostProcRegister(void *ctxPtr, const char *name, size_t len,
   191→                              TclObj *argList, TclObj *body) {
   192→    HostContext *ctx = ctxPtr;
   193→
   194→    gchar *key = g_strndup(name, len);
   195→    ProcDef *existing = g_hash_table_lookup(ctx->procs, key);
   196→
   197→    if (existing) {
   198→        /* Replace the existing definition */
   199→        hostFreeObj(existing->argList);
   200→        hostFreeObj(existing->body);
   201→        existing->argList = hostDup(argList);
   202→        existing->body = hostDup(body);
   203→        g_free(key);
   204→        return existing;
   205→    }
   206→
   207→    /* Create new proc definition */
   208→    ProcDef *proc = g_new0(ProcDef, 1);
   209→    proc->name = g_strndup(name, len);
   210→    proc->nameLen = len;
   211→    proc->argList = hostDup(argList);
   212→    proc->body = hostDup(body);
   213→
   214→    g_hash_table_insert(ctx->procs, key, proc);
   215→    return proc;
   216→}
   217→
   218→static int hostProcGetDef(void *handle, TclObj **argListOut, TclObj **bodyOut) {
   219→    ProcDef *proc = handle;
   220→    if (!proc) return -1;
   221→
   222→    *argListOut = proc->argList;
   223→    *bodyOut = proc->body;
   224→    return 0;
   225→}
   226→
   227→static TclResult hostExtInvoke(TclInterp *interp, void *handle,
   228→                               int objc, TclObj **objv) {
   229→    (void)interp;
   230→    (void)handle;
   231→    (void)objc;
   232→    (void)objv;
   233→    return TCL_ERROR;
   234→}
   235→
   236→static int hostCmdRename(void *ctx, const char *oldName, size_t oldLen,
   237→                         const char *newName, size_t newLen) {
   238→    (void)ctx;
   239→    (void)oldName;
   240→    (void)oldLen;
   241→    (void)newName;
   242→    (void)newLen;
   243→    return -1;
   244→}
   245→
   246→static int hostCmdDelete(void *ctx, const char *name, size_t len) {
   247→    (void)ctx;
   248→    (void)name;
   249→    (void)len;
   250→    return -1;
   251→}
   252→
   253→static int hostCmdExists(void *ctx, const char *name, size_t len) {
   254→    (void)ctx;
   255→    (void)name;
   256→    (void)len;
   257→    return 0;
   258→}
   259→
   260→/* Helper struct for command collection */
   261→typedef struct {
   262→    GPtrArray *cmds;
   263→    const gchar *pattern;
   264→    gsize patLen;
   265→} CmdCollectData;
   266→
   267→/* Helper for pattern matching (simple glob with * at end) */
   268→static gboolean patternMatch(const gchar *pattern, gsize patLen, const gchar *name) {
   269→    if (!pattern || patLen == 0) return TRUE;  /* NULL/empty matches all */
   270→
   271→    /* Check for wildcard at end */
   272→    if (pattern[patLen - 1] == '*') {
   273→        gsize prefixLen = patLen - 1;
   274→        return strncmp(name, pattern, prefixLen) == 0;
   275→    }
   276→
   277→    /* Exact match */
   278→    return strcmp(name, pattern) == 0;
   279→}
   280→
   281→/* Callback to collect proc names */
   282→static void collectProcName(gpointer key, gpointer value, gpointer userData) {
   283→    (void)value;
   284→    CmdCollectData *data = userData;
   285→    const gchar *name = key;
   286→
   287→    if (patternMatch(data->pattern, data->patLen, name)) {
   288→        g_ptr_array_add(data->cmds, hostNewString(name, strlen(name)));
   289→    }
   290→}
   291→
   292→static TclObj *hostCmdList(void *ctxPtr, const char *pattern) {
   293→    HostContext *ctx = ctxPtr;
   294→
   295→    GPtrArray *cmds = g_ptr_array_new();
   296→    gsize patLen = pattern ? strlen(pattern) : 0;
   297→
   298→    /* Add all registered procedures that match pattern */
   299→    CmdCollectData collectData = { cmds, pattern, patLen };
   300→    g_hash_table_foreach(ctx->procs, collectProcName, &collectData);
   301→
   302→    /* Add all built-in commands that match pattern */
   303→    int count = tclBuiltinCount();
   304→    for (int i = 0; i < count; i++) {
   305→        const char *name = tclBuiltinName(i);
   306→        if (name && patternMatch(pattern, patLen, name)) {
   307→            g_ptr_array_add(cmds, hostNewString(name, strlen(name)));
   308→        }
   309→    }
   310→
   311→    /* Build result list */
   312→    TclObj *result;
   313→    if (cmds->len == 0) {
   314→        result = hostNewString("", 0);
   315→    } else {
   316→        result = hostNewList((TclObj**)cmds->pdata, cmds->len);
   317→    }
   318→
   319→    /* Free array (not elements, they're in the result list) */
   320→    g_ptr_array_free(cmds, TRUE);
   321→    return result;
   322→}
   323→
   324→static void hostCmdHide(void *ctx, const char *name, size_t len) {
   325→    (void)ctx;
   326→    (void)name;
   327→    (void)len;
   328→}
   329→
   330→static void hostCmdExpose(void *ctx, const char *name, size_t len) {
   331→    (void)ctx;
   332→    (void)name;
   333→    (void)len;
   334→}
   335→
   336→/* ========================================================================
   337→ * List Operations
   338→ * ======================================================================== */
   339→
   340→static size_t hostListLength(TclObj *list) {
   341→    return hostListLengthImpl(list);
   342→}
   343→
   344→static TclObj *hostListIndex(TclObj *list, size_t idx) {
   345→    return hostListIndexImpl(list, idx);
   346→}
   347→
   348→static TclObj *hostListRange(TclObj *list, size_t first, size_t last) {
   349→    if (!list || first > last) {
   350→        return hostNewString("", 0);
   351→    }
   352→
   353→    size_t listLen = hostListLengthImpl(list);
   354→    if (first >= listLen) {
   355→        return hostNewString("", 0);
   356→    }
   357→    if (last >= listLen) {
   358→        last = listLen - 1;
   359→    }
   360→
   361→    size_t count = last - first + 1;
   362→    TclObj **elems = g_new(TclObj*, count);
   363→    if (!elems) return hostNewString("", 0);
   364→
   365→    for (size_t i = 0; i < count; i++) {
   366→        elems[i] = hostListIndexImpl(list, first + i);
   367→    }
   368→
   369→    TclObj *result = hostNewList(elems, count);
   370→    g_free(elems);
   371→    return result;
   372→}
   373→
   374→static TclObj *hostListSet(TclObj *list, size_t idx, TclObj *val) {
   375→    (void)list;
   376→    (void)idx;
   377→    (void)val;
   378→    return NULL;
   379→}
   380→
   381→static TclObj *hostListAppend(TclObj *list, TclObj *elem) {
   382→    if (!elem) return list ? hostDup(list) : hostNewString("", 0);
   383→
   384→    size_t listLen = list ? hostListLengthImpl(list) : 0;
   385→    size_t newCount = listLen + 1;
   386→
   387→    TclObj **elems = g_new(TclObj*, newCount);
   388→    if (!elems) return list ? hostDup(list) : hostNewString("", 0);
   389→
   390→    /* Copy existing elements */
   391→    for (size_t i = 0; i < listLen; i++) {
   392→        elems[i] = hostListIndexImpl(list, i);
   393→    }
   394→    /* Add new element */
   395→    elems[listLen] = elem;
   396→
   397→    TclObj *result = hostNewList(elems, newCount);
   398→    g_free(elems);
   399→    return result;
   400→}
   401→
   402→static TclObj *hostListConcat(TclObj *a, TclObj *b) {
   403→    (void)a;
   404→    (void)b;
   405→    return NULL;
   406→}
   407→
   408→static TclObj *hostListInsert(TclObj *list, size_t idx, TclObj **elems, size_t count) {
   409→    (void)list;
   410→    (void)idx;
   411→    (void)elems;
   412→    (void)count;
   413→    return NULL;
   414→}
   415→
   416→/* Compare function for qsort - ascending string */
   417→static gint cmpStrAsc(gconstpointer a, gconstpointer b) {
   418→    TclObj *oa = *(TclObj **)a;
   419→    TclObj *ob = *(TclObj **)b;
   420→    return hostStringCompare(oa, ob);
   421→}
   422→
   423→/* Compare function for qsort - descending string */
   424→static gint cmpStrDesc(gconstpointer a, gconstpointer b) {
   425→    return -cmpStrAsc(a, b);
   426→}
   427→
   428→/* Compare function for qsort - ascending string nocase */
   429→static gint cmpStrNocaseAsc(gconstpointer a, gconstpointer b) {
   430→    TclObj *oa = *(TclObj **)a;
   431→    TclObj *ob = *(TclObj **)b;
   432→    size_t lenA, lenB;
   433→    const char *sa = hostGetStringPtr(oa, &lenA);
   434→    const char *sb = hostGetStringPtr(ob, &lenB);
   435→    return g_ascii_strcasecmp(sa, sb);
   436→}
   437→
   438→/* Compare function for qsort - descending string nocase */
   439→static gint cmpStrNocaseDesc(gconstpointer a, gconstpointer b) {
   440→    return -cmpStrNocaseAsc(a, b);
   441→}
   442→
   443→/* Compare function for qsort - ascending integer */
   444→static gint cmpIntAsc(gconstpointer a, gconstpointer b) {
   445→    TclObj *oa = *(TclObj **)a;
   446→    TclObj *ob = *(TclObj **)b;
   447→    int64_t ia, ib;
   448→    hostAsInt(oa, &ia);
   449→    hostAsInt(ob, &ib);
   450→    if (ia < ib) return -1;
   451→    if (ia > ib) return 1;
   452→    return 0;
   453→}
   454→
   455→/* Compare function for qsort - descending integer */
   456→static gint cmpIntDesc(gconstpointer a, gconstpointer b) {
   457→    return -cmpIntAsc(a, b);
   458→}
   459→
   460→/* Compare function for qsort - ascending real */
   461→static gint cmpRealAsc(gconstpointer a, gconstpointer b) {
   462→    TclObj *oa = *(TclObj **)a;
   463→    TclObj *ob = *(TclObj **)b;
   464→    double da, db;
   465→    hostAsDouble(oa, &da);
   466→    hostAsDouble(ob, &db);
   467→    if (da < db) return -1;
   468→    if (da > db) return 1;
   469→    return 0;
   470→}
   471→
   472→/* Compare function for qsort - descending real */
   473→static gint cmpRealDesc(gconstpointer a, gconstpointer b) {
   474→    return -cmpRealAsc(a, b);
   475→}
   476→
   477→/* Dictionary comparison - case insensitive with embedded numbers */
   478→static gint dictcmp(const gchar *a, const gchar *b) {
   479→    while (*a && *b) {
   480→        /* Check if both are digits */
   481→        if (g_ascii_isdigit(*a) && g_ascii_isdigit(*b)) {
   482→            /* Compare as numbers */
   483→            glong na = 0, nb = 0;
   484→            while (g_ascii_isdigit(*a)) { na = na * 10 + (*a - '0'); a++; }
   485→            while (g_ascii_isdigit(*b)) { nb = nb * 10 + (*b - '0'); b++; }
   486→            if (na != nb) return (na < nb) ? -1 : 1;
   487→        } else {
   488→            /* Compare as case-insensitive chars */
   489→            gchar ca = g_ascii_tolower(*a);
   490→            gchar cb = g_ascii_tolower(*b);
   491→            if (ca != cb) return (guchar)ca - (guchar)cb;
   492→            a++; b++;
   493→        }
   494→    }
   495→    return (guchar)*a - (guchar)*b;
   496→}
   497→
   498→/* Compare function for qsort - ascending dictionary */
   499→static gint cmpDictAsc(gconstpointer a, gconstpointer b) {
   500→    TclObj *oa = *(TclObj **)a;
   501→    TclObj *ob = *(TclObj **)b;
   502→    size_t lenA, lenB;
   503→    const char *sa = hostGetStringPtr(oa, &lenA);
   504→    const char *sb = hostGetStringPtr(ob, &lenB);
   505→    return dictcmp(sa, sb);
   506→}
   507→
   508→/* Compare function for qsort - descending dictionary */
   509→static gint cmpDictDesc(gconstpointer a, gconstpointer b) {
   510→    return -cmpDictAsc(a, b);
   511→}
   512→
   513→static TclObj *hostListSort(TclObj *list, int flags) {
   514→    if (!list) return hostNewString("", 0);
   515→
   516→    size_t listLen = hostListLengthImpl(list);
   517→    if (listLen == 0) return hostNewString("", 0);
   518→    if (listLen == 1) return hostDup(list);
   519→
   520→    /* Get all elements */
   521→    TclObj **elems = g_new(TclObj*, listLen);
   522→    if (!elems) return hostDup(list);
   523→
   524→    for (size_t i = 0; i < listLen; i++) {
   525→        elems[i] = hostListIndexImpl(list, i);
   526→    }
   527→
   528→    /* flags: 1=decreasing, 2=integer, 4=nocase, 8=unique, 16=dictionary, 32=real */
   529→    gboolean decreasing = flags & 1;
   530→    gboolean integer = flags & 2;
   531→    gboolean nocase = flags & 4;
   532→    gboolean unique = flags & 8;
   533→    gboolean dictionary = flags & 16;
   534→    gboolean real = flags & 32;
   535→
   536→    /* Select comparison function */
   537→    GCompareFunc cmpfn;
   538→    if (integer) {
   539→        cmpfn = decreasing ? cmpIntDesc : cmpIntAsc;
   540→    } else if (real) {
   541→        cmpfn = decreasing ? cmpRealDesc : cmpRealAsc;
   542→    } else if (dictionary) {
   543→        cmpfn = decreasing ? cmpDictDesc : cmpDictAsc;
   544→    } else if (nocase) {
   545→        cmpfn = decreasing ? cmpStrNocaseDesc : cmpStrNocaseAsc;
   546→    } else {
   547→        cmpfn = decreasing ? cmpStrDesc : cmpStrAsc;
   548→    }
   549→
   550→    qsort(elems, listLen, sizeof(TclObj*), cmpfn);
   551→
   552→    /* Apply -unique if requested */
   553→    size_t resultLen = listLen;
   554→    if (unique && listLen > 1) {
   555→        /* Remove duplicates in-place - use same comparison for equality */
   556→        size_t writeIdx = 1;
   557→        for (size_t i = 1; i < listLen; i++) {
   558→            gboolean same = FALSE;
   559→            if (integer) {
   560→                int64_t a, b;
   561→                hostAsInt(elems[writeIdx-1], &a);
   562→                hostAsInt(elems[i], &b);
   563→                same = (a == b);
   564→            } else if (real) {
   565→                double a, b;
   566→                hostAsDouble(elems[writeIdx-1], &a);
   567→                hostAsDouble(elems[i], &b);
   568→                same = (a == b);
   569→            } else if (dictionary || nocase) {
   570→                size_t lenA, lenB;
   571→                const char *sa = hostGetStringPtr(elems[writeIdx-1], &lenA);
   572→                const char *sb = hostGetStringPtr(elems[i], &lenB);
   573→                same = (g_ascii_strcasecmp(sa, sb) == 0);
   574→            } else {
   575→                same = (hostStringCompare(elems[writeIdx-1], elems[i]) == 0);
   576→            }
   577→            if (!same) {
   578→                if (writeIdx != i) {
   579→                    hostFreeObj(elems[writeIdx]);
   580→                    elems[writeIdx] = elems[i];
   581→                    elems[i] = NULL;
   582→                }
   583→                writeIdx++;
   584→            } else {
   585→                hostFreeObj(elems[i]);
   586→                elems[i] = NULL;
   587→            }
   588→        }
   589→        resultLen = writeIdx;
   590→    }
   591→
   592→    TclObj *result = hostNewList(elems, resultLen);
   593→
   594→    /* Free remaining elements */
   595→    for (size_t i = 0; i < listLen; i++) {
   596→        if (elems[i]) hostFreeObj(elems[i]);
   597→    }
   598→    g_free(elems);
   599→    return result;
   600→}
   601→
   602→/* ========================================================================
   603→ * Dict Operations (stubs)
   604→ * ======================================================================== */
   605→
   606→static TclObj *hostDictGet(TclObj *dict, TclObj *key) {
   607→    (void)dict;
   608→    (void)key;
   609→    return NULL;
   610→}
   611→
   612→static TclObj *hostDictSet(TclObj *dict, TclObj *key, TclObj *val) {
   613→    (void)dict;
   614→    (void)key;
   615→    (void)val;
   616→    return NULL;
   617→}
   618→
   619→static int hostDictExists(TclObj *dict, TclObj *key) {
   620→    (void)dict;
   621→    (void)key;
   622→    return 0;
   623→}
   624→
   625→static TclObj *hostDictKeys(TclObj *dict, const char *pattern) {
   626→    (void)dict;
   627→    (void)pattern;
   628→    return hostNewString("", 0);
   629→}
   630→
   631→static TclObj *hostDictValues(TclObj *dict, const char *pattern) {
   632→    (void)dict;
   633→    (void)pattern;
   634→    return hostNewString("", 0);
   635→}
   636→
   637→static TclObj *hostDictRemove(TclObj *dict, TclObj *key) {
   638→    (void)dict;
   639→    (void)key;
   640→    return NULL;
   641→}
   642→
   643→static size_t hostDictSize(TclObj *dict) {
   644→    (void)dict;
   645→    return 0;
   646→}
   647→
   648→/* ========================================================================
   649→ * More String Operations (stubs)
   650→ * ======================================================================== */
   651→
   652→static TclObj *hostStringIndex(TclObj *str, size_t idx) {
   653→    (void)str;
   654→    (void)idx;
   655→    return hostNewString("", 0);
   656→}
   657→
   658→static TclObj *hostStringRange(TclObj *str, size_t first, size_t last) {
   659→    (void)str;
   660→    (void)first;
   661→    (void)last;
   662→    return hostNewString("", 0);
   663→}
   664→
   665→static TclObj *hostStringConcat(TclObj **parts, size_t count) {
   666→    if (count == 0) return hostNewString("", 0);
   667→
   668→    GString *result = g_string_new("");
   669→    for (size_t i = 0; i < count; i++) {
   670→        if (parts[i]) {
   671→            size_t len;
   672→            const char *s = hostGetStringPtr(parts[i], &len);
   673→            g_string_append_len(result, s, len);
   674→        }
   675→    }
   676→
   677→    TclObj *obj = hostNewString(result->str, result->len);
   678→    g_string_free(result, TRUE);
   679→    return obj;
   680→}
   681→
   682→static int hostStringCompareNocase(TclObj *a, TclObj *b) {
   683→    if (!a && !b) return 0;
   684→    if (!a) return -1;
   685→    if (!b) return 1;
   686→    size_t lenA, lenB;
   687→    const char *sa = hostGetStringPtr(a, &lenA);
   688→    const char *sb = hostGetStringPtr(b, &lenB);
   689→    return g_ascii_strcasecmp(sa, sb);
   690→}
   691→
   692→/* Helper for glob pattern matching */
   693→static gboolean globMatch(const gchar *pat, gsize patLen, const gchar *str, gsize strLen, gboolean nocase) {
   694→    gsize p = 0, s = 0;
   695→    gsize starP = (gsize)-1, starS = (gsize)-1;
   696→
   697→    while (s < strLen) {
   698→        if (p < patLen && pat[p] == '*') {
   699→            /* Remember position for backtracking */
   700→            starP = p++;
   701→            starS = s;
   702→        } else if (p < patLen && pat[p] == '?') {
   703→            /* Match any single character */
   704→            p++;
   705→            s++;
   706→        } else if (p < patLen && pat[p] == '[') {
   707→            /* Character class */
   708→            p++;
   709→            gboolean invert = FALSE;
   710→            if (p < patLen && pat[p] == '!') {
   711→                invert = TRUE;
   712→                p++;
   713→            }
   714→            gboolean matched = FALSE;
   715→            gchar sc = nocase ? g_ascii_tolower(str[s]) : str[s];
   716→            while (p < patLen && pat[p] != ']') {
   717→                gchar c1 = nocase ? g_ascii_tolower(pat[p]) : pat[p];
   718→                if (p + 2 < patLen && pat[p + 1] == '-' && pat[p + 2] != ']') {
   719→                    gchar c2 = nocase ? g_ascii_tolower(pat[p + 2]) : pat[p + 2];
   720→                    if (sc >= c1 && sc <= c2) matched = TRUE;
   721→                    p += 3;
   722→                } else {
   723→                    if (sc == c1) matched = TRUE;
   724→                    p++;
   725→                }
   726→            }
   727→            if (p < patLen) p++; /* skip ] */
   728→            if (matched == invert) {
   729→                /* No match, try backtracking */
   730→                if (starP == (gsize)-1) return FALSE;
   731→                p = starP + 1;
   732→                s = ++starS;
   733→            } else {
   734→                s++;
   735→            }
   736→        } else if (p < patLen && pat[p] == '\\' && p + 1 < patLen) {
   737→            /* Escaped character */
   738→            p++;
   739→            gchar pc = pat[p];
   740→            gchar sc = str[s];
   741→            if (nocase) {
   742→                pc = g_ascii_tolower(pc);
   743→                sc = g_ascii_tolower(sc);
   744→            }
   745→            if (pc == sc) {
   746→                p++;
   747→                s++;
   748→            } else if (starP != (gsize)-1) {
   749→                p = starP + 1;
   750→                s = ++starS;
   751→            } else {
   752→                return FALSE;
   753→            }
   754→        } else if (p < patLen) {
   755→            /* Literal character */
   756→            gchar pc = pat[p];
   757→            gchar sc = str[s];
   758→            if (nocase) {
   759→                pc = g_ascii_tolower(pc);
   760→                sc = g_ascii_tolower(sc);
   761→            }
   762→            if (pc == sc) {
   763→                p++;
   764→                s++;
   765→            } else if (starP != (gsize)-1) {
   766→                p = starP + 1;
   767→                s = ++starS;
   768→            } else {
   769→                return FALSE;
   770→            }
   771→        } else if (starP != (gsize)-1) {
   772→            p = starP + 1;
   773→            s = ++starS;
   774→        } else {
   775→            return FALSE;
   776→        }
   777→    }
   778→
   779→    /* Skip trailing stars */
   780→    while (p < patLen && pat[p] == '*') p++;
   781→
   782→    return p == patLen;
   783→}
   784→
   785→static int hostStringMatch(const char *pattern, TclObj *str, int nocase) {
   786→    size_t strLen;
   787→    const char *strPtr = hostGetStringPtr(str, &strLen);
   788→    gsize patLen = strlen(pattern);
   789→    return globMatch(pattern, patLen, strPtr, strLen, nocase);
   790→}
   791→
   792→static TclObj *hostStringToLower(TclObj *str) {
   793→    (void)str;
   794→    return hostNewString("", 0);
   795→}
   796→
   797→static TclObj *hostStringToUpper(TclObj *str) {
   798→    (void)str;
   799→    return hostNewString("", 0);
   800→}
   801→
   802→static TclObj *hostStringTrim(TclObj *str, const char *chars) {
   803→    (void)str;
   804→    (void)chars;
   805→    return hostNewString("", 0);
   806→}
   807→
   808→static TclObj *hostStringReplace(TclObj *str, size_t first, size_t last, TclObj *rep) {
   809→    (void)str;
   810→    (void)first;
   811→    (void)last;
   812→    (void)rep;
   813→    return hostNewString("", 0);
   814→}
   815→
   816→static int hostStringFirst(TclObj *needle, TclObj *haystack, size_t start) {
   817→    (void)needle;
   818→    (void)haystack;
   819→    (void)start;
   820→    return -1;
   821→}
   822→
   823→static int hostStringLast(TclObj *needle, TclObj *haystack, size_t start) {
   824→    (void)needle;
   825→    (void)haystack;
   826→    (void)start;
   827→    return -1;
   828→}
   829→
   830→/* ========================================================================
   831→ * Trace Operations
   832→ * ======================================================================== */
   833→
   834→/* External trace functions from vars.c */
   835→extern void hostVarTraceAdd(void *vars, const char *name, size_t len, int ops,
   836→                            TclTraceProc callback, void *clientData);
   837→extern void hostVarTraceRemove(void *vars, const char *name, size_t len,
   838→                               TclTraceProc callback, void *clientData);
   839→
   840→static void hostTraceVarAdd(void *vars, const char *name, size_t len, int ops,
   841→                            TclTraceProc callback, void *clientData) {
   842→    hostVarTraceAdd(vars, name, len, ops, callback, clientData);
   843→}
   844→
   845→static void hostTraceVarRemove(void *vars, const char *name, size_t len,
   846→                               TclTraceProc callback, void *clientData) {
   847→    hostVarTraceRemove(vars, name, len, callback, clientData);
   848→}
   849→
   850→/* ========================================================================
   851→ * Event Loop Implementation using GLib
   852→ * ======================================================================== */
   853→
   854→/* Timer event data */
   855→typedef struct AfterEvent {
   856→    guint          id;          /* GSource ID */
   857→    TclObj        *script;      /* Script to execute (NULL for blocking sleep) */
   858→    TclObj        *idObj;       /* "after#N" identifier object */
   859→    gboolean       idle;        /* TRUE if idle callback */
   860→    TclInterp     *interp;      /* Interpreter for execution */
   861→} AfterEvent;
   862→
   863→/* File event data */
   864→typedef struct FileEvent {
   865→    TclChannel    *chan;        /* Channel */
   866→    TclObj        *readScript;  /* Readable handler */
   867→    TclObj        *writeScript; /* Writable handler */
   868→    guint          readId;      /* GSource ID for readable */
   869→    guint          writeId;     /* GSource ID for writable */
   870→} FileEvent;
   871→
   872→/* Global event loop state */
   873→static GMainContext *gEventContext = NULL;
   874→static GMainLoop *gEventLoop = NULL;
   875→static GHashTable *gAfterEvents = NULL;  /* id -> AfterEvent */
   876→static GHashTable *gFileEvents = NULL;   /* channel -> FileEvent */
   877→static guint gNextAfterId = 0;
   878→static TclInterp *gCurrentInterp = NULL;
   879→
   880→/* Initialize event loop */
   881→static void ensureEventLoop(void) {
   882→    if (!gEventContext) {
   883→        gEventContext = g_main_context_default();
   884→        gEventLoop = g_main_loop_new(gEventContext, FALSE);
   885→        gAfterEvents = g_hash_table_new(g_direct_hash, g_direct_equal);
   886→        gFileEvents = g_hash_table_new(g_direct_hash, g_direct_equal);
   887→    }
   888→}
   889→
   890→/* Timer callback */
   891→static gboolean afterTimerCallback(gpointer userData) {
   892→    AfterEvent *event = userData;
   893→
   894→    if (event->script && gCurrentInterp) {
   895→        /* Execute the script */
   896→        size_t len;
   897→        const char *script = hostGetStringPtr(event->script, &len);
   898→        tclEvalStr(gCurrentInterp, script, len);
   899→    }
   900→
   901→    /* Remove from hash table */
   902→    g_hash_table_remove(gAfterEvents, event->idObj);
   903→
   904→    /* Clean up */
   905→    if (event->script) hostFreeObj(event->script);
   906→    if (event->idObj) hostFreeObj(event->idObj);
   907→    g_free(event);
   908→
   909→    return G_SOURCE_REMOVE;
   910→}
   911→
   912→static TclTimerToken hostAfterMs(void *ctx, int ms, TclObj *script) {
   913→    (void)ctx;
   914→    ensureEventLoop();
   915→
   916→    if (!script) {
   917→        /* Blocking sleep */
   918→        g_usleep((gulong)ms * 1000);
   919→        return NULL;
   920→    }
   921→
   922→    /* Create after event */
   923→    AfterEvent *event = g_new0(AfterEvent, 1);
   924→    event->script = hostDup(script);
   925→    event->idle = FALSE;
   926→    event->interp = gCurrentInterp;
   927→
   928→    /* Create ID string "after#N" */
   929→    gchar *idStr = g_strdup_printf("after#%u", gNextAfterId++);
   930→    event->idObj = hostNewString(idStr, strlen(idStr));
   931→    g_free(idStr);
   932→
   933→    /* Schedule timer */
   934→    event->id = g_timeout_add(ms, afterTimerCallback, event);
   935→
   936→    /* Store in hash table */
   937→    g_hash_table_insert(gAfterEvents, event->idObj, event);
   938→
   939→    return (TclTimerToken)event->idObj;
   940→}
   941→
   942→static TclTimerToken hostAfterIdle(void *ctx, TclObj *script) {
   943→    (void)ctx;
   944→    ensureEventLoop();
   945→
   946→    if (!script) return NULL;
   947→
   948→    /* Create after event */
   949→    AfterEvent *event = g_new0(AfterEvent, 1);
   950→    event->script = hostDup(script);
   951→    event->idle = TRUE;
   952→    event->interp = gCurrentInterp;
   953→
   954→    /* Create ID string "after#N" */
   955→    gchar *idStr = g_strdup_printf("after#%u", gNextAfterId++);
   956→    event->idObj = hostNewString(idStr, strlen(idStr));
   957→    g_free(idStr);
   958→
   959→    /* Schedule idle callback */
   960→    event->id = g_idle_add(afterTimerCallback, event);
   961→
   962→    /* Store in hash table */
   963→    g_hash_table_insert(gAfterEvents, event->idObj, event);
   964→
   965→    return (TclTimerToken)event->idObj;
   966→}
   967→
   968→static void hostAfterCancel(void *ctx, TclTimerToken token) {
   969→    (void)ctx;
   970→    if (!token || !gAfterEvents) return;
   971→
   972→    TclObj *idObj = (TclObj *)token;
   973→
   974→    /* Try to find by ID object directly */
   975→    AfterEvent *event = g_hash_table_lookup(gAfterEvents, idObj);
   976→
   977→    if (!event) {
   978→        /* Try to find by string value (for cancel by script) */
   979→        size_t tokenLen;
   980→        const char *tokenStr = hostGetStringPtr(idObj, &tokenLen);
   981→
   982→        GHashTableIter iter;
   983→        gpointer key, value;
   984→        g_hash_table_iter_init(&iter, gAfterEvents);
   985→        while (g_hash_table_iter_next(&iter, &key, &value)) {
   986→            AfterEvent *e = value;
   987→            if (e->script) {
   988→                size_t scriptLen;
   989→                const char *scriptStr = hostGetStringPtr(e->script, &scriptLen);
   990→                if (scriptLen == tokenLen && memcmp(scriptStr, tokenStr, tokenLen) == 0) {
   991→                    event = e;
   992→                    idObj = key;
   993→                    break;
   994→                }
   995→            }
   996→        }
   997→    }
   998→
   999→    if (event) {
  1000→        /* Cancel the source */
  1001→        g_source_remove(event->id);
  1002→
  1003→        /* Remove from hash table */
  1004→        g_hash_table_remove(gAfterEvents, idObj);
  1005→
  1006→        /* Clean up */
  1007→        if (event->script) hostFreeObj(event->script);
  1008→        if (event->idObj) hostFreeObj(event->idObj);
  1009→        g_free(event);
  1010→    }
  1011→}
  1012→
  1013→static TclObj *hostAfterInfo(void *ctx, TclTimerToken token) {
  1014→    (void)ctx;
  1015→    ensureEventLoop();
  1016→
  1017→    if (!token) {
  1018→        /* Return list of all pending event IDs */
  1019→        GPtrArray *ids = g_ptr_array_new();
  1020→
  1021→        GHashTableIter iter;
  1022→        gpointer key, value;
  1023→        g_hash_table_iter_init(&iter, gAfterEvents);
  1024→        while (g_hash_table_iter_next(&iter, &key, &value)) {
  1025→            g_ptr_array_add(ids, key);
  1026→        }
  1027→
  1028→        TclObj *result = hostNewList((TclObj **)ids->pdata, ids->len);
  1029→        g_ptr_array_free(ids, TRUE);
  1030→        return result;
  1031→    }
  1032→
  1033→    /* Look up specific event */
  1034→    TclObj *idObj = (TclObj *)token;
  1035→    AfterEvent *event = g_hash_table_lookup(gAfterEvents, idObj);
  1036→
  1037→    if (!event) {
  1038→        /* Try by string match */
  1039→        size_t tokenLen;
  1040→        const char *tokenStr = hostGetStringPtr(idObj, &tokenLen);
  1041→
  1042→        GHashTableIter iter;
  1043→        gpointer key, value;
  1044→        g_hash_table_iter_init(&iter, gAfterEvents);
  1045→        while (g_hash_table_iter_next(&iter, &key, &value)) {
  1046→            TclObj *keyObj = key;
  1047→            size_t keyLen;
  1048→            const char *keyStr = hostGetStringPtr(keyObj, &keyLen);
  1049→            if (keyLen == tokenLen && memcmp(keyStr, tokenStr, tokenLen) == 0) {
  1050→                event = value;
  1051→                break;
  1052→            }
  1053→        }
  1054→    }
  1055→
  1056→    if (!event) {
  1057→        return NULL;  /* Not found - caller will report error */
  1058→    }
  1059→
  1060→    /* Return {script type} where type is "timer" or "idle" */
  1061→    TclObj *elems[2];
  1062→    elems[0] = event->script ? hostDup(event->script) : hostNewString("", 0);
  1063→    elems[1] = hostNewString(event->idle ? "idle" : "timer",
  1064→                             event->idle ? 4 : 5);
  1065→    return hostNewList(elems, 2);
  1066→}
  1067→
  1068→/* Get file descriptor from channel (if possible) */
  1069→extern int hostChanGetFd(TclChannel *chan);
  1070→
  1071→static void hostFileeventSet(void *ctx, TclChannel *chan, int mask, TclObj *script) {
  1072→    (void)ctx;
  1073→    ensureEventLoop();
  1074→
  1075→    if (!chan) return;
  1076→
  1077→    /* Find or create file event entry */
  1078→    FileEvent *fe = g_hash_table_lookup(gFileEvents, chan);
  1079→    if (!fe) {
  1080→        fe = g_new0(FileEvent, 1);
  1081→        fe->chan = chan;
  1082→        g_hash_table_insert(gFileEvents, chan, fe);
  1083→    }
  1084→
  1085→    /* Get script length to check if empty */
  1086→    size_t scriptLen = 0;
  1087→    if (script) {
  1088→        hostGetStringPtr(script, &scriptLen);
  1089→    }
  1090→
  1091→    if (mask & TCL_READABLE) {
  1092→        if (fe->readScript) {
  1093→            hostFreeObj(fe->readScript);
  1094→            fe->readScript = NULL;
  1095→        }
  1096→        if (script && scriptLen > 0) {
  1097→            fe->readScript = hostDup(script);
  1098→        }
  1099→    }
  1100→
  1101→    if (mask & TCL_WRITABLE) {
  1102→        if (fe->writeScript) {
  1103→            hostFreeObj(fe->writeScript);
  1104→            fe->writeScript = NULL;
  1105→        }
  1106→        if (script && scriptLen > 0) {
  1107→            fe->writeScript = hostDup(script);
  1108→        }
  1109→    }
  1110→}
  1111→
  1112→static TclObj *hostFileeventGet(void *ctx, TclChannel *chan, int mask) {
  1113→    (void)ctx;
  1114→    if (!chan || !gFileEvents) return NULL;
  1115→
  1116→    FileEvent *fe = g_hash_table_lookup(gFileEvents, chan);
  1117→    if (!fe) return NULL;
  1118→
  1119→    if (mask & TCL_READABLE) {
  1120→        return fe->readScript ? hostDup(fe->readScript) : NULL;
  1121→    }
  1122→    if (mask & TCL_WRITABLE) {
  1123→        return fe->writeScript ? hostDup(fe->writeScript) : NULL;
  1124→    }
  1125→    return NULL;
  1126→}
  1127→
  1128→static int hostDoOneEvent(void *ctx, int flags) {
  1129→    (void)ctx;
  1130→    ensureEventLoop();
  1131→
  1132→    gboolean mayBlock = !(flags & TCL_EVENT_NOWAIT);
  1133→
  1134→    /* Run one iteration of the main loop */
  1135→    return g_main_context_iteration(gEventContext, mayBlock) ? 1 : 0;
  1136→}
  1137→
  1138→/* Set current interpreter for event callbacks */
  1139→void hostSetCurrentInterp(TclInterp *interp) {
  1140→    gCurrentInterp = interp;
  1141→}
  1142→
  1143→/* ========================================================================
  1144→ * Process/Socket/File stubs
  1145→ * ======================================================================== */
  1146→
  1147→/* Process structure */
  1148→typedef struct {
  1149→    GPid pid;
  1150→    gint exit_status;
  1151→    gboolean exited;
  1152→} HostProcess;
  1153→
  1154→/* External channel creation from channel.c */
  1155→extern TclChannel *hostChanFromFd(int fd, gboolean readable, gboolean writable);
  1156→
  1157→static TclProcess *hostProcessSpawn(const char **argv, int argc, int flags,
  1158→                                    TclChannel **pipeIn, TclChannel **pipeOut,
  1159→                                    TclChannel **pipeErr) {
  1160→    (void)argc;
  1161→
  1162→    GError *error = NULL;
  1163→    GPid child_pid;
  1164→    gint stdin_fd = -1, stdout_fd = -1, stderr_fd = -1;
  1165→
  1166→    GSpawnFlags spawn_flags = G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD;
  1167→
  1168→    gboolean success = g_spawn_async_with_pipes(
  1169→        NULL,           /* working directory (inherit) */
  1170→        (gchar **)argv, /* argv */
  1171→        NULL,           /* envp (inherit) */
  1172→        spawn_flags,
  1173→        NULL,           /* child setup */
  1174→        NULL,           /* user data */
  1175→        &child_pid,
  1176→        (flags & TCL_PROCESS_PIPE_STDIN) ? &stdin_fd : NULL,
  1177→        (flags & TCL_PROCESS_PIPE_STDOUT) ? &stdout_fd : NULL,
  1178→        (flags & TCL_PROCESS_PIPE_STDERR) ? &stderr_fd : NULL,
  1179→        &error
  1180→    );
  1181→
  1182→    if (!success) {
  1183→        if (error) {
  1184→            g_error_free(error);
  1185→        }
  1186→        return NULL;
  1187→    }
  1188→
  1189→    HostProcess *proc = g_new0(HostProcess, 1);
  1190→    proc->pid = child_pid;
  1191→    proc->exit_status = 0;
  1192→    proc->exited = FALSE;
  1193→
  1194→    /* Create pipe channels if requested */
  1195→    if (pipeIn && stdin_fd >= 0) {
  1196→        *pipeIn = hostChanFromFd(stdin_fd, FALSE, TRUE);
  1197→    }
  1198→
  1199→    if (pipeOut && stdout_fd >= 0) {
  1200→        *pipeOut = hostChanFromFd(stdout_fd, TRUE, FALSE);
  1201→    }
  1202→
  1203→    if (pipeErr && stderr_fd >= 0) {
  1204→        *pipeErr = hostChanFromFd(stderr_fd, TRUE, FALSE);
  1205→    }
  1206→
  1207→    return (TclProcess *)proc;
  1208→}
  1209→
  1210→static int hostProcessWait(TclProcess *tproc, int *exitCode) {
  1211→    HostProcess *proc = (HostProcess *)tproc;
  1212→    if (!proc) return -1;
  1213→
  1214→    if (proc->exited) {
  1215→        if (exitCode) *exitCode = proc->exit_status;
  1216→        return 0;
  1217→    }
  1218→
  1219→    gint status;
  1220→    GPid result = waitpid(proc->pid, &status, 0);
  1221→    if (result == proc->pid) {
  1222→        proc->exited = TRUE;
  1223→        if (WIFEXITED(status)) {
  1224→            proc->exit_status = WEXITSTATUS(status);
  1225→        } else if (WIFSIGNALED(status)) {
  1226→            proc->exit_status = 128 + WTERMSIG(status);
  1227→        } else {
  1228→            proc->exit_status = -1;
  1229→        }
  1230→        if (exitCode) *exitCode = proc->exit_status;
  1231→        g_spawn_close_pid(proc->pid);
  1232→        return 0;
  1233→    }
  1234→
  1235→    return -1;
  1236→}
  1237→
  1238→static int hostProcessPid(TclProcess *tproc) {
  1239→    HostProcess *proc = (HostProcess *)tproc;
  1240→    if (!proc) return -1;
  1241→    return (int)proc->pid;
  1242→}
  1243→
  1244→static void hostProcessKill(TclProcess *tproc, int signal) {
  1245→    HostProcess *proc = (HostProcess *)tproc;
  1246→    if (!proc || proc->exited) return;
  1247→    kill(proc->pid, signal);
  1248→}
  1249→
  1250→static TclChannel *hostSocketOpen(const char *host, int port, int flags) {
  1251→    (void)host; (void)port; (void)flags;
  1252→    return NULL;
  1253→}
  1254→
  1255→static void *hostSocketListen(const char *addr, int port,
  1256→                              TclAcceptProc onAccept, void *clientData) {
  1257→    (void)addr; (void)port; (void)onAccept; (void)clientData;
  1258→    return NULL;
  1259→}
  1260→
  1261→static void hostSocketListenClose(void *listener) {
  1262→    (void)listener;
  1263→}
  1264→
  1265→static int hostFileExists(const char *path) {
  1266→    return g_file_test(path, G_FILE_TEST_EXISTS) ? 1 : 0;
  1267→}
  1268→
  1269→static int hostFileIsFile(const char *path) {
  1270→    return g_file_test(path, G_FILE_TEST_IS_REGULAR) ? 1 : 0;
  1271→}
  1272→
  1273→static int hostFileIsDir(const char *path) {
  1274→    return g_file_test(path, G_FILE_TEST_IS_DIR) ? 1 : 0;
  1275→}
  1276→
  1277→static int hostFileReadable(const char *path) {
  1278→    return g_access(path, R_OK) == 0 ? 1 : 0;
  1279→}
  1280→
  1281→static int hostFileWritable(const char *path) {
  1282→    return g_access(path, W_OK) == 0 ? 1 : 0;
  1283→}
  1284→
  1285→static int hostFileExecutable(const char *path) {
  1286→    return g_access(path, X_OK) == 0 ? 1 : 0;
  1287→}
  1288→
  1289→static int64_t hostFileSize(const char *path) {
  1290→    GStatBuf buf;
  1291→    if (g_stat(path, &buf) != 0) return -1;
  1292→    return (int64_t)buf.st_size;
  1293→}
  1294→
  1295→static int64_t hostFileMtime(const char *path) {
  1296→    GStatBuf buf;
  1297→    if (g_stat(path, &buf) != 0) return -1;
  1298→    return (int64_t)buf.st_mtime;
  1299→}
  1300→
  1301→static int64_t hostFileAtime(const char *path) {
  1302→    GStatBuf buf;
  1303→    if (g_stat(path, &buf) != 0) return -1;
  1304→    return (int64_t)buf.st_atime;
  1305→}
  1306→
  1307→static int deleteRecursive(const char *path);
  1308→
  1309→static int hostFileDelete(const char *path, int force) {
  1310→    if (!g_file_test(path, G_FILE_TEST_EXISTS)) {
  1311→        return force ? 0 : -1;
  1312→    }
  1313→    if (g_file_test(path, G_FILE_TEST_IS_DIR)) {
  1314→        if (force) {
  1315→            return deleteRecursive(path);
  1316→        }
  1317→        return g_rmdir(path) == 0 ? 0 : -1;
  1318→    }
  1319→    return g_unlink(path) == 0 ? 0 : -1;
  1320→}
  1321→
  1322→static int deleteRecursive(const char *path) {
  1323→    GDir *dir = g_dir_open(path, 0, NULL);
  1324→    if (!dir) {
  1325→        return -1;
  1326→    }
  1327→    const char *name;
  1328→    while ((name = g_dir_read_name(dir)) != NULL) {
  1329→        char *child = g_build_filename(path, name, NULL);
  1330→        if (g_file_test(child, G_FILE_TEST_IS_DIR)) {
  1331→            deleteRecursive(child);
  1332→        } else {
  1333→            g_unlink(child);
  1334→        }
  1335→        g_free(child);
  1336→    }
  1337→    g_dir_close(dir);
  1338→    return g_rmdir(path) == 0 ? 0 : -1;
  1339→}
  1340→
  1341→static int hostFileRename(const char *old, const char *new_, int force) {
  1342→    if (!force && g_file_test(new_, G_FILE_TEST_EXISTS)) {
  1343→        return -1;
  1344→    }
  1345→    return g_rename(old, new_) == 0 ? 0 : -1;
  1346→}
  1347→
  1348→static int hostFileMkdir(const char *path) {
  1349→    return g_mkdir_with_parents(path, 0755) == 0 ? 0 : -1;
  1350→}
  1351→
  1352→static int hostFileCopy(const char *src, const char *dst, int force) {
  1353→    if (!force && g_file_test(dst, G_FILE_TEST_EXISTS)) {
  1354→        return -1;
  1355→    }
  1356→    gchar *contents = NULL;
  1357→    gsize len = 0;
  1358→    GError *err = NULL;
  1359→    if (!g_file_get_contents(src, &contents, &len, &err)) {
  1360→        if (err) g_error_free(err);
  1361→        return -1;
  1362→    }
  1363→    gboolean ok = g_file_set_contents(dst, contents, len, &err);
  1364→    g_free(contents);
  1365→    if (!ok) {
  1366→        if (err) g_error_free(err);
  1367→        return -1;
  1368→    }
  1369→    return 0;
  1370→}
  1371→
  1372→static TclObj *hostFileDirname(const char *path) {
  1373→    gchar *dir = g_path_get_dirname(path);
  1374→    TclObj *result = hostNewString(dir, strlen(dir));
  1375→    g_free(dir);
  1376→    return result;
  1377→}
  1378→
  1379→static TclObj *hostFileTail(const char *path) {
  1380→    gchar *base = g_path_get_basename(path);
  1381→    TclObj *result = hostNewString(base, strlen(base));
  1382→    g_free(base);
  1383→    return result;
  1384→}
  1385→
  1386→static TclObj *hostFileExtension(const char *path) {
  1387→    /* Get the base filename first */
  1388→    gchar *base = g_path_get_basename(path);
  1389→    const char *dot = strrchr(base, '.');
  1390→    TclObj *result;
  1391→    if (dot) {
  1392→        /* Tcl returns everything from the last dot, even for ".bashrc" */
  1393→        result = hostNewString(dot, strlen(dot));
  1394→    } else {
  1395→        result = hostNewString("", 0);
  1396→    }
  1397→    g_free(base);
  1398→    return result;
  1399→}
  1400→
  1401→static TclObj *hostFileRootname(const char *path) {
  1402→    /* Find last dot in the path (not in directory) */
  1403→    const char *base = strrchr(path, '/');
  1404→    if (base) base++; else base = path;
  1405→    const char *dot = strrchr(base, '.');
  1406→    if (dot) {
  1407→        /* Return everything before the last dot */
  1408→        size_t len = dot - path;
  1409→        return hostNewString(path, len);
  1410→    }
  1411→    return hostNewString(path, strlen(path));
  1412→}
  1413→
  1414→static TclObj *hostFileJoin(TclObj **parts, size_t count) {
  1415→    if (count == 0) return hostNewString("", 0);
  1416→
  1417→    GString *result = g_string_new("");
  1418→    for (size_t i = 0; i < count; i++) {
  1419→        size_t len;
  1420→        const char *s = hostGetStringPtr(parts[i], &len);
  1421→
  1422→        /* If part is absolute path, start fresh */
  1423→        if (len > 0 && s[0] == '/') {
  1424→            g_string_truncate(result, 0);
  1425→            g_string_append_len(result, s, len);
  1426→        } else if (result->len == 0) {
  1427→            g_string_append_len(result, s, len);
  1428→        } else {
  1429→            /* Add separator if needed */
  1430→            if (result->str[result->len - 1] != '/') {
  1431→                g_string_append_c(result, '/');
  1432→            }
  1433→            g_string_append_len(result, s, len);
  1434→        }
  1435→    }
  1436→
  1437→    TclObj *obj = hostNewString(result->str, result->len);
  1438→    g_string_free(result, TRUE);
  1439→    return obj;
  1440→}
  1441→
  1442→static TclObj *hostFileNormalize(const char *path) {
  1443→    gchar *abs = g_canonicalize_filename(path, NULL);
  1444→    TclObj *result = hostNewString(abs, strlen(abs));
  1445→    g_free(abs);
  1446→    return result;
  1447→}
  1448→
  1449→static TclObj *hostFileSplit(const char *path) {
  1450→    GPtrArray *parts = g_ptr_array_new_with_free_func(g_free);
  1451→
  1452→    const char *p = path;
  1453→
  1454→    /* Handle leading / */
  1455→    if (*p == '/') {
  1456→        g_ptr_array_add(parts, g_strdup("/"));
  1457→        p++;
  1458→    }
  1459→
  1460→    /* Split by / */
  1461→    while (*p) {
  1462→        while (*p == '/') p++;  /* Skip consecutive slashes */
  1463→        if (!*p) break;
  1464→
  1465→        const char *start = p;
  1466→        while (*p && *p != '/') p++;
  1467→
  1468→        g_ptr_array_add(parts, g_strndup(start, p - start));
  1469→    }
  1470→
  1471→    /* Build list result */
  1472→    TclObj **elems = g_new(TclObj*, parts->len);
  1473→    for (guint i = 0; i < parts->len; i++) {
  1474→        const char *s = g_ptr_array_index(parts, i);
  1475→        elems[i] = hostNewString(s, strlen(s));
  1476→    }
  1477→    TclObj *result = hostNewList(elems, parts->len);
  1478→    g_free(elems);
  1479→    g_ptr_array_free(parts, TRUE);
  1480→    return result;
  1481→}
  1482→
  1483→static TclObj *hostFileType(const char *path) {
  1484→    GStatBuf buf;
  1485→    if (g_lstat(path, &buf) != 0) return NULL;
  1486→
  1487→    const char *type;
  1488→    if (S_ISREG(buf.st_mode)) type = "file";
  1489→    else if (S_ISDIR(buf.st_mode)) type = "directory";
  1490→    else if (S_ISLNK(buf.st_mode)) type = "link";
  1491→    else if (S_ISCHR(buf.st_mode)) type = "characterSpecial";
  1492→    else if (S_ISBLK(buf.st_mode)) type = "blockSpecial";
  1493→    else if (S_ISFIFO(buf.st_mode)) type = "fifo";
  1494→    else if (S_ISSOCK(buf.st_mode)) type = "socket";
  1495→    else type = "unknown";
  1496→
  1497→    return hostNewString(type, strlen(type));
  1498→}
  1499→
  1500→static TclObj *hostGlob(const char *pattern, int types, const char *dir) {
  1501→    (void)pattern; (void)types; (void)dir;
  1502→    /* Glob is complex - return empty list for now */
  1503→    return hostNewList(NULL, 0);
  1504→}
  1505→
  1506→static int hostFilePathtype(const char *path) {
  1507→    if (!path || !*path) return TCL_PATH_RELATIVE;
  1508→    if (path[0] == '/') return TCL_PATH_ABSOLUTE;
  1509→    return TCL_PATH_RELATIVE;
  1510→}
  1511→
  1512→static TclObj *hostFileSeparator(void) {
  1513→    return hostNewString("/", 1);
  1514→}
  1515→
  1516→static TclObj *hostFileStat(const char *path) {
  1517→    GStatBuf buf;
  1518→    if (g_stat(path, &buf) != 0) return NULL;
  1519→
  1520→    TclObj *dict = hostNewDict();
  1521→    extern void hostDictSetInternal(TclObj *dict, const char *key, TclObj *val);
  1522→    hostDictSetInternal(dict, "atime", hostNewInt((int64_t)buf.st_atime));
  1523→    hostDictSetInternal(dict, "ctime", hostNewInt((int64_t)buf.st_ctime));
  1524→    hostDictSetInternal(dict, "dev", hostNewInt((int64_t)buf.st_dev));
  1525→    hostDictSetInternal(dict, "gid", hostNewInt((int64_t)buf.st_gid));
  1526→    hostDictSetInternal(dict, "ino", hostNewInt((int64_t)buf.st_ino));
  1527→    hostDictSetInternal(dict, "mode", hostNewInt((int64_t)buf.st_mode));
  1528→    hostDictSetInternal(dict, "mtime", hostNewInt((int64_t)buf.st_mtime));
  1529→    hostDictSetInternal(dict, "nlink", hostNewInt((int64_t)buf.st_nlink));
  1530→    hostDictSetInternal(dict, "size", hostNewInt((int64_t)buf.st_size));
  1531→    hostDictSetInternal(dict, "uid", hostNewInt((int64_t)buf.st_uid));
  1532→
  1533→    const char *type;
  1534→    if (S_ISREG(buf.st_mode)) type = "file";
  1535→    else if (S_ISDIR(buf.st_mode)) type = "directory";
  1536→    else if (S_ISLNK(buf.st_mode)) type = "link";
  1537→    else if (S_ISCHR(buf.st_mode)) type = "characterSpecial";
  1538→    else if (S_ISBLK(buf.st_mode)) type = "blockSpecial";
  1539→    else if (S_ISFIFO(buf.st_mode)) type = "fifo";
  1540→    else if (S_ISSOCK(buf.st_mode)) type = "socket";
  1541→    else type = "unknown";
  1542→    hostDictSetInternal(dict, "type", hostNewString(type, strlen(type)));
  1543→
  1544→    return dict;
  1545→}
  1546→
  1547→static TclObj *hostFileLstat(const char *path) {
  1548→    GStatBuf buf;
  1549→    if (g_lstat(path, &buf) != 0) return NULL;
  1550→
  1551→    TclObj *dict = hostNewDict();
  1552→    extern void hostDictSetInternal(TclObj *dict, const char *key, TclObj *val);
  1553→    hostDictSetInternal(dict, "atime", hostNewInt((int64_t)buf.st_atime));
  1554→    hostDictSetInternal(dict, "ctime", hostNewInt((int64_t)buf.st_ctime));
  1555→    hostDictSetInternal(dict, "dev", hostNewInt((int64_t)buf.st_dev));
  1556→    hostDictSetInternal(dict, "gid", hostNewInt((int64_t)buf.st_gid));
  1557→    hostDictSetInternal(dict, "ino", hostNewInt((int64_t)buf.st_ino));
  1558→    hostDictSetInternal(dict, "mode", hostNewInt((int64_t)buf.st_mode));
  1559→    hostDictSetInternal(dict, "mtime", hostNewInt((int64_t)buf.st_mtime));
  1560→    hostDictSetInternal(dict, "nlink", hostNewInt((int64_t)buf.st_nlink));
  1561→    hostDictSetInternal(dict, "size", hostNewInt((int64_t)buf.st_size));
  1562→    hostDictSetInternal(dict, "uid", hostNewInt((int64_t)buf.st_uid));
  1563→
  1564→    const char *type;
  1565→    if (S_ISREG(buf.st_mode)) type = "file";
  1566→    else if (S_ISDIR(buf.st_mode)) type = "directory";
  1567→    else if (S_ISLNK(buf.st_mode)) type = "link";
  1568→    else if (S_ISCHR(buf.st_mode)) type = "characterSpecial";
  1569→    else if (S_ISBLK(buf.st_mode)) type = "blockSpecial";
  1570→    else if (S_ISFIFO(buf.st_mode)) type = "fifo";
  1571→    else if (S_ISSOCK(buf.st_mode)) type = "socket";
  1572→    else type = "unknown";
  1573→    hostDictSetInternal(dict, "type", hostNewString(type, strlen(type)));
  1574→
  1575→    return dict;
  1576→}
  1577→
  1578→static TclObj *hostFileNativename(const char *path) {
  1579→    /* On Unix, native name is the same as the path */
  1580→    return hostNewString(path, strlen(path));
  1581→}
  1582→
  1583→static int hostFileOwned(const char *path) {
  1584→    GStatBuf buf;
  1585→    if (g_stat(path, &buf) != 0) return 0;
  1586→    return buf.st_uid == getuid() ? 1 : 0;
  1587→}
  1588→
  1589→static TclObj *hostFileTempfile(void *ctx, const char *tmpl, TclObj **pathOut) {
  1590→    (void)ctx;
  1591→    gchar *template;
  1592→    if (tmpl && *tmpl) {
  1593→        template = g_strdup_printf("%s/XXXXXX", tmpl);
  1594→    } else {
  1595→        template = g_strdup_printf("%s/tcl_XXXXXX", g_get_tmp_dir());
  1596→    }
  1597→
  1598→    int fd = g_mkstemp(template);
  1599→    if (fd < 0) {
  1600→        g_free(template);
  1601→        return NULL;
  1602→    }
  1603→
  1604→    /* Create channel from the file descriptor */
  1605→    TclChannel *chan = hostChanFromFd(fd, TRUE, TRUE);
  1606→    if (!chan) {
  1607→        close(fd);
  1608→        g_unlink(template);
  1609→        g_free(template);
  1610→        return NULL;
  1611→    }
  1612→
  1613→    /* Set path output */
  1614→    if (pathOut) {
  1615→        *pathOut = hostNewString(template, strlen(template));
  1616→    }
  1617→
  1618→    /* Return channel name */
  1619→    const char *chanName = hostChanGetName(chan);
  1620→    TclObj *result = hostNewString(chanName, strlen(chanName));
  1621→    g_free(template);
  1622→    return result;
  1623→}
  1624→
  1625→static TclObj *hostFileTempdir(const char *tmpl) {
  1626→    gchar *template;
  1627→    if (tmpl && *tmpl) {
  1628→        template = g_strdup_printf("%s/XXXXXX", tmpl);
  1629→    } else {
  1630→        template = g_strdup_printf("%s/tclXXXXXX", g_get_tmp_dir());
  1631→    }
  1632→
  1633→    gchar *result = g_mkdtemp(template);
  1634→    if (!result) {
  1635→        g_free(template);
  1636→        return NULL;
  1637→    }
  1638→    TclObj *obj = hostNewString(result, strlen(result));
  1639→    g_free(template);
  1640→    return obj;
  1641→}
  1642→
  1643→static TclObj *hostFileHome(const char *user) {
  1644→    if (user && *user) {
  1645→        /* Looking up another user's home - not fully supported */
  1646→        return NULL;
  1647→    }
  1648→    const gchar *home = g_get_home_dir();
  1649→    if (!home) return NULL;
  1650→    return hostNewString(home, strlen(home));
  1651→}
  1652→
  1653→static int hostFileLink(const char *linkName, const char *target, int linkType) {
  1654→    if (linkType == TCL_LINK_SYMBOLIC) {
  1655→        return symlink(target, linkName) == 0 ? 0 : -1;
  1656→    } else {
  1657→        return link(target, linkName) == 0 ? 0 : -1;
  1658→    }
  1659→}
  1660→
  1661→static TclObj *hostFileReadlink(const char *linkName) {
  1662→    gchar *target = g_file_read_link(linkName, NULL);
  1663→    if (!target) return NULL;
  1664→    TclObj *result = hostNewString(target, strlen(target));
  1665→    g_free(target);
  1666→    return result;
  1667→}
  1668→
  1669→static TclObj *hostFileSystem(const char *path) {
  1670→    (void)path;
  1671→    /* Return a simple "native" filesystem type */
  1672→    TclObj *elems[1];
  1673→    elems[0] = hostNewString("native", 6);
  1674→    return hostNewList(elems, 1);
  1675→}
  1676→
  1677→static TclObj *hostFileVolumes(void) {
  1678→    /* On Unix, there's just root */
  1679→    TclObj *elems[1];
  1680→    elems[0] = hostNewString("/", 1);
  1681→    return hostNewList(elems, 1);
  1682→}
  1683→
  1684→static TclObj *hostFileAttributes(const char *path, const char *option) {
  1685→    (void)path; (void)option;
  1686→    /* File attributes are complex and platform-specific */
  1687→    return NULL;
  1688→}
  1689→
  1690→static int hostFileAttributesSet(const char *path, const char *option, TclObj *value) {
  1691→    (void)path; (void)option; (void)value;
  1692→    return -1;
  1693→}
  1694→
  1695→static int hostChdir(const char *path) { (void)path; return -1; }
  1696→static TclObj *hostGetcwd(void) { return hostNewString("", 0); }
  1697→static TclObj *hostSysHostname(void) { return hostNewString("", 0); }
  1698→static TclObj *hostSysExecutable(void) { return hostNewString("", 0); }
  1699→static int hostSysPid(void) { return 0; }
  1700→
  1701→/* Regex flags - must match core/builtin_regexp.c */
  1702→#define REGEX_FLAG_NOCASE   (1 << 0)
  1703→#define REGEX_FLAG_ALL      (1 << 1)
  1704→#define REGEX_FLAG_INDICES  (1 << 2)
  1705→#define REGEX_FLAG_INLINE   (1 << 3)
  1706→
  1707→static TclObj *hostRegexMatch(const char *pat, size_t patLen, TclObj *str, int flags) {
  1708→    if (!pat || !str) return NULL;
  1709→
  1710→    /* Get string to match */
  1711→    size_t strLen;
  1712→    const char *strPtr = hostGetStringPtr(str, &strLen);
  1713→    if (!strPtr) return NULL;
  1714→
  1715→    /* Create null-terminated pattern and subject */
  1716→    gchar *pattern = g_strndup(pat, patLen);
  1717→    gchar *subject = g_strndup(strPtr, strLen);
  1718→
  1719→    /* Build GRegex compile flags */
  1720→    GRegexCompileFlags compileFlags = 0;
  1721→    if (flags & REGEX_FLAG_NOCASE) {
  1722→        compileFlags |= G_REGEX_CASELESS;
  1723→    }
  1724→
  1725→    /* Compile the regex */
  1726→    GError *error = NULL;
  1727→    GRegex *regex = g_regex_new(pattern, compileFlags, 0, &error);
  1728→    if (!regex) {
  1729→        g_free(pattern);
  1730→        g_free(subject);
  1731→        if (error) g_error_free(error);
  1732→        return NULL;
  1733→    }
  1734→
  1735→    /* Perform matching */
  1736→    GMatchInfo *matchInfo = NULL;
  1737→    gboolean matched = g_regex_match(regex, subject, 0, &matchInfo);
  1738→
  1739→    if (!matched) {
  1740→        if (matchInfo) g_match_info_free(matchInfo);
  1741→        g_regex_unref(regex);
  1742→        g_free(pattern);
  1743→        g_free(subject);
  1744→        return NULL;
  1745→    }
  1746→
  1747→    /* Build result list */
  1748→    GPtrArray *results = g_ptr_array_new();
  1749→
  1750→    if (flags & REGEX_FLAG_ALL) {
  1751→        /* Collect all matches */
  1752→        do {
  1753→            gint start, end;
  1754→            if (g_match_info_fetch_pos(matchInfo, 0, &start, &end)) {
  1755→                if (flags & REGEX_FLAG_INDICES) {
  1756→                    /* Return indices as "start end" string */
  1757→                    gchar *idx = g_strdup_printf("%d %d", start, end - 1);
  1758→                    g_ptr_array_add(results, hostNewString(idx, strlen(idx)));
  1759→                    g_free(idx);
  1760→                } else {
  1761→                    /* Return matched text */
  1762→                    gchar *match = g_match_info_fetch(matchInfo, 0);
  1763→                    if (match) {
  1764→                        g_ptr_array_add(results, hostNewString(match, strlen(match)));
  1765→                        g_free(match);
  1766→                    }
  1767→                }
  1768→            }
  1769→
  1770→            /* Add subgroup matches for inline mode */
  1771→            if (flags & REGEX_FLAG_INLINE) {
  1772→                gint groupCount = g_match_info_get_match_count(matchInfo);
  1773→                for (gint i = 1; i < groupCount; i++) {
  1774→                    gint subStart, subEnd;
  1775→                    if (g_match_info_fetch_pos(matchInfo, i, &subStart, &subEnd)) {
  1776→                        if (flags & REGEX_FLAG_INDICES) {
  1777→                            if (subStart >= 0) {
  1778→                                gchar *idx = g_strdup_printf("%d %d", subStart, subEnd - 1);
  1779→                                g_ptr_array_add(results, hostNewString(idx, strlen(idx)));
  1780→                                g_free(idx);
  1781→                            } else {
  1782→                                g_ptr_array_add(results, hostNewString("-1 -1", 5));
  1783→                            }
  1784→                        } else {
  1785→                            gchar *subMatch = g_match_info_fetch(matchInfo, i);
  1786→                            if (subMatch) {
  1787→                                g_ptr_array_add(results, hostNewString(subMatch, strlen(subMatch)));
  1788→                                g_free(subMatch);
  1789→                            } else {
  1790→                                g_ptr_array_add(results, hostNewString("", 0));
  1791→                            }
  1792→                        }
  1793→                    }
  1794→                }
  1795→            }
  1796→        } while (g_match_info_next(matchInfo, NULL));
  1797→    } else {
  1798→        /* Single match - return full match and subgroups */
  1799→        gint groupCount = g_match_info_get_match_count(matchInfo);
  1800→        for (gint i = 0; i < groupCount; i++) {
  1801→            gint start, end;
  1802→            if (g_match_info_fetch_pos(matchInfo, i, &start, &end)) {
  1803→                if (flags & REGEX_FLAG_INDICES) {
  1804→                    if (start >= 0) {
  1805→                        gchar *idx = g_strdup_printf("%d %d", start, end - 1);
  1806→                        g_ptr_array_add(results, hostNewString(idx, strlen(idx)));
  1807→                        g_free(idx);
  1808→                    } else {
  1809→                        g_ptr_array_add(results, hostNewString("-1 -1", 5));
  1810→                    }
  1811→                } else {
  1812→                    gchar *match = g_match_info_fetch(matchInfo, i);
  1813→                    if (match) {
  1814→                        g_ptr_array_add(results, hostNewString(match, strlen(match)));
  1815→                        g_free(match);
  1816→                    } else {
  1817→                        g_ptr_array_add(results, hostNewString("", 0));
  1818→                    }
  1819→                }
  1820→            }
  1821→        }
  1822→    }
  1823→
  1824→    /* Create result list */
  1825→    TclObj *result = hostNewList((TclObj**)results->pdata, results->len);
  1826→
  1827→    g_ptr_array_free(results, TRUE);
  1828→    g_match_info_free(matchInfo);
  1829→    g_regex_unref(regex);
  1830→    g_free(pattern);
  1831→    g_free(subject);
  1832→
  1833→    return result;
  1834→}
  1835→
  1836→static TclObj *hostRegexSubst(const char *pat, size_t patLen, TclObj *str, TclObj *rep, int flags) {
  1837→    if (!pat || !str || !rep) return NULL;
  1838→
  1839→    /* Get string and replacement */
  1840→    size_t strLen, repLen;
  1841→    const char *strPtr = hostGetStringPtr(str, &strLen);
  1842→    const char *repPtr = hostGetStringPtr(rep, &repLen);
  1843→    if (!strPtr || !repPtr) return NULL;
  1844→
  1845→    /* Create null-terminated strings */
  1846→    gchar *pattern = g_strndup(pat, patLen);
  1847→    gchar *subject = g_strndup(strPtr, strLen);
  1848→    gchar *replacement = g_strndup(repPtr, repLen);
  1849→
  1850→    /* Convert TCL back-references to GLib format:
  1851→     * TCL uses \0, \1, etc. and &
  1852→     * GLib uses \0, \1, etc. (same) but TCL's & becomes \0
  1853→     */
  1854→    GString *glibRep = g_string_new("");
  1855→    for (size_t i = 0; i < repLen; i++) {
  1856→        if (replacement[i] == '&') {
  1857→            g_string_append(glibRep, "\\0");
  1858→        } else if (replacement[i] == '\\' && i + 1 < repLen) {
  1859→            if (replacement[i+1] >= '0' && replacement[i+1] <= '9') {
  1860→                /* Keep \N as is */
  1861→                g_string_append_c(glibRep, replacement[i]);
  1862→                g_string_append_c(glibRep, replacement[i+1]);
  1863→                i++;
  1864→            } else if (replacement[i+1] == '&') {
  1865→                /* \& is literal & */
  1866→                g_string_append_c(glibRep, '&');
  1867→                i++;
  1868→            } else if (replacement[i+1] == '\\') {
  1869→                /* \\ is literal \ */
  1870→                g_string_append(glibRep, "\\\\");
  1871→                i++;
  1872→            } else {
  1873→                g_string_append_c(glibRep, replacement[i]);
  1874→            }
  1875→        } else {
  1876→            g_string_append_c(glibRep, replacement[i]);
  1877→        }
  1878→    }
  1879→
  1880→    /* Build GRegex compile flags */
  1881→    GRegexCompileFlags compileFlags = 0;
  1882→    if (flags & REGEX_FLAG_NOCASE) {
  1883→        compileFlags |= G_REGEX_CASELESS;
  1884→    }
  1885→
  1886→    /* Compile the regex */
  1887→    GError *error = NULL;
  1888→    GRegex *regex = g_regex_new(pattern, compileFlags, 0, &error);
  1889→    if (!regex) {
  1890→        g_string_free(glibRep, TRUE);
  1891→        g_free(pattern);
  1892→        g_free(subject);
  1893→        g_free(replacement);
  1894→        if (error) g_error_free(error);
  1895→        return NULL;
  1896→    }
  1897→
  1898→    /* Perform substitution */
  1899→    TclObj *resultObj = NULL;
  1900→
  1901→    if (flags & REGEX_FLAG_ALL) {
  1902→        /* Replace all occurrences */
  1903→        gchar *result = g_regex_replace(regex, subject, -1, 0, glibRep->str, 0, &error);
  1904→        if (result) {
  1905→            resultObj = hostNewString(result, strlen(result));
  1906→            g_free(result);
  1907→        }
  1908→    } else {
  1909→        /* Single replacement */
  1910→        GMatchInfo *matchInfo = NULL;
  1911→        if (g_regex_match(regex, subject, 0, &matchInfo)) {
  1912→            gint start, end;
  1913→            g_match_info_fetch_pos(matchInfo, 0, &start, &end);
  1914→
  1915→            /* Expand replacement string */
  1916→            gchar *expanded = g_match_info_expand_references(matchInfo, glibRep->str, &error);
  1917→            if (expanded) {
  1918→                GString *resultStr = g_string_new("");
  1919→                g_string_append_len(resultStr, subject, start);
  1920→                g_string_append(resultStr, expanded);
  1921→                g_string_append(resultStr, subject + end);
  1922→                resultObj = hostNewString(resultStr->str, resultStr->len);
  1923→                g_string_free(resultStr, TRUE);
  1924→                g_free(expanded);
  1925→            }
  1926→            g_match_info_free(matchInfo);
  1927→        } else {
  1928→            /* No match - return original */
  1929→            resultObj = hostNewString(subject, strLen);
  1930→        }
  1931→    }
  1932→
  1933→    g_string_free(glibRep, TRUE);
  1934→    g_regex_unref(regex);
  1935→    g_free(pattern);
  1936→    g_free(subject);
  1937→    g_free(replacement);
  1938→    if (error) g_error_free(error);
  1939→
  1940→    return resultObj;
  1941→}
  1942→
  1943→static int64_t hostClockSeconds(void) { return 0; }
  1944→static int64_t hostClockMillis(void) { return 0; }
  1945→static int64_t hostClockMicros(void) { return 0; }
  1946→static TclObj *hostClockFormat(int64_t time, const char *fmt, const char *tz) {
  1947→    (void)time; (void)fmt; (void)tz; return hostNewString("", 0);
  1948→}
  1949→static int64_t hostClockScan(const char *str, const char *fmt, const char *tz) {
  1950→    (void)str; (void)fmt; (void)tz; return 0;
  1951→}
  1952→
  1953→static TclObj *hostEncodingConvertTo(const char *enc, TclObj *str) {
  1954→    (void)enc; (void)str; return NULL;
  1955→}
  1956→static TclObj *hostEncodingConvertFrom(const char *enc, TclObj *bytes) {
  1957→    (void)enc; (void)bytes; return NULL;
  1958→}
  1959→static TclObj *hostEncodingNames(void) { return hostNewString("", 0); }
  1960→static const char *hostEncodingSystem(void) { return "utf-8"; }
  1961→
  1962→/* ========================================================================
  1963→ * The TclHost Callback Table
  1964→ * ======================================================================== */
  1965→
  1966→const TclHost cHost = {
  1967→    /* Context */
  1968→    .interpContextNew = hostInterpContextNew,
  1969→    .interpContextFree = hostInterpContextFree,
  1970→
  1971→    /* Frames */
  1972→    .frameAlloc = hostFrameAlloc,
  1973→    .frameFree = hostFrameFree,
  1974→
  1975→    /* Objects */
  1976→    .newString = hostNewString,
  1977→    .newInt = hostNewInt,
  1978→    .newDouble = hostNewDouble,
  1979→    .newBool = hostNewBool,
  1980→    .newList = hostNewList,
  1981→    .newDict = hostNewDict,
  1982→    .dup = hostDup,
  1983→    .getStringPtr = hostGetStringPtr,
  1984→    .asInt = hostAsInt,
  1985→    .asDouble = hostAsDouble,
  1986→    .asBool = hostAsBool,
  1987→    .asList = hostAsList,
  1988→
  1989→    /* Lists */
  1990→    .listLength = hostListLength,
  1991→    .listIndex = hostListIndex,
  1992→    .listRange = hostListRange,
  1993→    .listSet = hostListSet,
  1994→    .listAppend = hostListAppend,
  1995→    .listConcat = hostListConcat,
  1996→    .listInsert = hostListInsert,
  1997→    .listSort = hostListSort,
  1998→
  1999→    /* Dicts */
  2000→    .dictGet = hostDictGet,
  2001→    .dictSet = hostDictSet,
  2002→    .dictExists = hostDictExists,
  2003→    .dictKeys = hostDictKeys,
  2004→    .dictValues = hostDictValues,
  2005→    .dictRemove = hostDictRemove,
  2006→    .dictSize = hostDictSize,
  2007→
  2008→    /* Strings */
  2009→    .stringLength = hostStringLength,
  2010→    .stringIndex = hostStringIndex,
  2011→    .stringRange = hostStringRange,
  2012→    .stringConcat = hostStringConcat,
  2013→    .stringCompare = hostStringCompare,
  2014→    .stringCompareNocase = hostStringCompareNocase,
  2015→    .stringMatch = hostStringMatch,
  2016→    .stringToLower = hostStringToLower,
  2017→    .stringToUpper = hostStringToUpper,
  2018→    .stringTrim = hostStringTrim,
  2019→    .stringReplace = hostStringReplace,
  2020→    .stringFirst = hostStringFirst,
  2021→    .stringLast = hostStringLast,
  2022→
  2023→    /* Arena */
  2024→    .arenaPush = hostArenaPush,
  2025→    .arenaPop = hostArenaPop,
  2026→    .arenaAlloc = hostArenaAlloc,
  2027→    .arenaStrdup = hostArenaStrdup,
  2028→    .arenaMark = hostArenaMark,
  2029→    .arenaReset = hostArenaReset,
  2030→
  2031→    /* Variables */
  2032→    .varsNew = hostVarsNew,
  2033→    .varsFree = hostVarsFree,
  2034→    .varGet = hostVarGet,
  2035→    .varSet = hostVarSet,
  2036→    .varUnset = hostVarUnset,
  2037→    .varExists = hostVarExists,
  2038→    .varNames = hostVarNames,
  2039→    .varNamesLocal = hostVarNamesLocal,
  2040→    .varLink = hostVarLink,
  2041→
  2042→    /* Arrays */
  2043→    .arraySet = hostArraySet,
  2044→    .arrayGet = hostArrayGet,
  2045→    .arrayExists = hostArrayExists,
  2046→    .arrayNames = hostArrayNames,
  2047→    .arrayUnset = hostArrayUnset,
  2048→    .arraySize = hostArraySize,
  2049→    .arrayStartSearch = hostArrayStartSearch,
  2050→    .arrayAnymore = hostArrayAnymore,
  2051→    .arrayNextElement = hostArrayNextElement,
  2052→    .arrayDoneSearch = hostArrayDoneSearch,
  2053→
  2054→    /* Traces */
  2055→    .traceVarAdd = hostTraceVarAdd,
  2056→    .traceVarRemove = hostTraceVarRemove,
  2057→
  2058→    /* Commands */
  2059→    .cmdLookup = hostCmdLookup,
  2060→    .procRegister = hostProcRegister,
  2061→    .procGetDef = hostProcGetDef,
  2062→    .extInvoke = hostExtInvoke,
  2063→    .cmdRename = hostCmdRename,
  2064→    .cmdDelete = hostCmdDelete,
  2065→    .cmdExists = hostCmdExists,
  2066→    .cmdList = hostCmdList,
  2067→    .cmdHide = hostCmdHide,
  2068→    .cmdExpose = hostCmdExpose,
  2069→
  2070→    /* Channels */
  2071→    .chanOpen = hostChanOpen,
  2072→    .chanClose = hostChanClose,
  2073→    .chanStdin = hostChanStdin,
  2074→    .chanStdout = hostChanStdout,
  2075→    .chanStderr = hostChanStderr,
  2076→    .chanRead = hostChanRead,
  2077→    .chanWrite = hostChanWrite,
  2078→    .chanGets = hostChanGets,
  2079→    .chanFlush = hostChanFlush,
  2080→    .chanSeek = hostChanSeek,
  2081→    .chanTell = hostChanTell,
  2082→    .chanEof = hostChanEof,
  2083→    .chanBlocked = hostChanBlocked,
  2084→    .chanConfigure = hostChanConfigure,
  2085→    .chanCget = hostChanCget,
  2086→    .chanNames = hostChanNames,
  2087→    .chanShare = hostChanShare,
  2088→    .chanTransfer = hostChanTransfer,
  2089→    .chanTruncate = hostChanTruncate,
  2090→    .chanCopy = hostChanCopy,
  2091→    .chanPending = hostChanPending,
  2092→    .chanPipe = hostChanPipe,
  2093→
  2094→    /* Event loop */
  2095→    .afterMs = hostAfterMs,
  2096→    .afterIdle = hostAfterIdle,
  2097→    .afterCancel = hostAfterCancel,
  2098→    .afterInfo = hostAfterInfo,
  2099→    .fileeventSet = hostFileeventSet,
  2100→    .fileeventGet = hostFileeventGet,
  2101→    .doOneEvent = hostDoOneEvent,
  2102→
  2103→    /* Process */
  2104→    .processSpawn = hostProcessSpawn,
  2105→    .processWait = hostProcessWait,
  2106→    .processPid = hostProcessPid,
  2107→    .processKill = hostProcessKill,
  2108→
  2109→    /* Sockets */
  2110→    .socketOpen = hostSocketOpen,
  2111→    .socketListen = hostSocketListen,
  2112→    .socketListenClose = hostSocketListenClose,
  2113→
  2114→    /* Filesystem */
  2115→    .fileExists = hostFileExists,
  2116→    .fileIsFile = hostFileIsFile,
  2117→    .fileIsDir = hostFileIsDir,
  2118→    .fileReadable = hostFileReadable,
  2119→    .fileWritable = hostFileWritable,
  2120→    .fileExecutable = hostFileExecutable,
  2121→    .fileSize = hostFileSize,
  2122→    .fileMtime = hostFileMtime,
  2123→    .fileAtime = hostFileAtime,
  2124→    .fileDelete = hostFileDelete,
  2125→    .fileRename = hostFileRename,
  2126→    .fileMkdir = hostFileMkdir,
  2127→    .fileCopy = hostFileCopy,
  2128→    .fileDirname = hostFileDirname,
  2129→    .fileTail = hostFileTail,
  2130→    .fileExtension = hostFileExtension,
  2131→    .fileRootname = hostFileRootname,
  2132→    .fileJoin = hostFileJoin,
  2133→    .fileNormalize = hostFileNormalize,
  2134→    .fileSplit = hostFileSplit,
  2135→    .fileType = hostFileType,
  2136→    .glob = hostGlob,
  2137→    .filePathtype = hostFilePathtype,
  2138→    .fileSeparator = hostFileSeparator,
  2139→    .fileStat = hostFileStat,
  2140→    .fileLstat = hostFileLstat,
  2141→    .fileNativename = hostFileNativename,
  2142→    .fileOwned = hostFileOwned,
  2143→    .fileTempfile = hostFileTempfile,
  2144→    .fileTempdir = hostFileTempdir,
  2145→    .fileHome = hostFileHome,
  2146→    .fileLink = hostFileLink,
  2147→    .fileReadlink = hostFileReadlink,
  2148→    .fileSystem = hostFileSystem,
  2149→    .fileVolumes = hostFileVolumes,
  2150→    .fileAttributes = hostFileAttributes,
  2151→    .fileAttributesSet = hostFileAttributesSet,
  2152→
  2153→    /* System */
  2154→    .chdir = hostChdir,
  2155→    .getcwd = hostGetcwd,
  2156→    .sysHostname = hostSysHostname,
  2157→    .sysExecutable = hostSysExecutable,
  2158→    .sysPid = hostSysPid,
  2159→
  2160→    /* Regex */
  2161→    .regexMatch = hostRegexMatch,
  2162→    .regexSubst = hostRegexSubst,
  2163→
  2164→    /* Clock */
  2165→    .clockSeconds = hostClockSeconds,
  2166→    .clockMillis = hostClockMillis,
  2167→    .clockMicros = hostClockMicros,
  2168→    .clockFormat = hostClockFormat,
  2169→    .clockScan = hostClockScan,
  2170→
  2171→    /* Encoding */
  2172→    .encodingConvertTo = hostEncodingConvertTo,
  2173→    .encodingConvertFrom = hostEncodingConvertFrom,
  2174→    .encodingNames = hostEncodingNames,
  2175→    .encodingSystem = hostEncodingSystem,
  2176→};
  2177→
  2178→/* Export the host table */
  2179→const TclHost *tclGetCHost(void) {
  2180→    return &cHost;
  2181→}
  2182→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
