# TCL Core Implementation Task

## Feature: coroutine

**Description:** Coroutine support (coroutine, yield, yieldto)

**Dependencies:** eval, proc

**Status:** 0/28 tests passing

---

## Current Test Results

### Failing Tests

#### Test: coroutine-1.0

**Script:**
```tcl
# Test: basic coroutine creation - immediate return gives result to coroutine caller
proc simple {} {
    return "hello from coroutine"
}
puts [coroutine mycoro simple]
```

**Expected output:**
```
hello from coroutine

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-hello from coroutine
```

---

#### Test: coroutine-1.1

**Script:**
```tcl
# Test: coroutine with immediate yield to synchronize
proc counter {} {
    yield
    set i 0
    while {$i < 3} {
        yield $i
        incr i
    }
    return "done"
}
coroutine c counter
puts [c]
puts [c]
puts [c]
puts [c]
```

**Expected output:**
```
0
1
2
done

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-0
-1
-2
-done
```

---

#### Test: coroutine-1.2

**Script:**
```tcl
# Test: yield returns value passed by caller
proc echo {} {
    yield
    while 1 {
        set val [yield "received"]
        puts "got: $val"
    }
}
coroutine e echo
e
puts [e "first"]
puts [e "second"]
```

**Expected output:**
```
got: first
received
got: second
received

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-got: first
-received
-got: second
-received
```

---

#### Test: coroutine-1.3

**Script:**
```tcl
# Test: coroutine with accumulator pattern
coroutine accumulator apply {{} {
    set x 0
    while 1 {
        incr x [yield $x]
    }
}}
puts [accumulator 5]
puts [accumulator 10]
puts [accumulator 3]
```

**Expected output:**
```
5
15
18

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-5
-15
-18
```

---

#### Test: coroutine-1.4

**Script:**
```tcl
# Test: coroutine that returns normally without yield
proc noYield {} {
    return 42
}
puts [coroutine ny noYield]
```

**Expected output:**
```
42

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-42
```

---

#### Test: coroutine-1.5

**Script:**
```tcl
# Test: yield without value returns empty string
proc emptyYield {} {
    yield
    yield
    return "finished"
}
coroutine ey emptyYield
puts "[ey]."
puts "[ey]."
```

**Expected output:**
```
.
finished.

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-.
-finished.
```

---

#### Test: coroutine-2.0

**Script:**
```tcl
# Test: deleting coroutine with rename
proc counter {} {
    set i 0
    while 1 {
        yield [incr i]
    }
}
coroutine c counter
puts [c]
puts [c]
rename c {}
puts "deleted"
```

**Expected output:**
```
2
3
deleted

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-2
-3
-deleted
```

---

#### Test: coroutine-2.1

**Script:**
```tcl
# Test: error in coroutine propagates to caller
proc failing {} {
    yield
    yield "ok"
    error "something went wrong"
}
coroutine f failing
puts [f]
catch {f} err
puts "caught: $err"
```

**Expected output:**
```
ok
caught: something went wrong

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-ok
-caught: something went wrong
```

---

#### Test: coroutine-2.2

**Script:**
```tcl
# Test: coroutine in namespace
namespace eval myns {
    proc gen {} {
        yield
        yield "in namespace"
        return "done"
    }
    coroutine ::myns::coro gen
}
puts [myns::coro]
puts [myns::coro]
```

**Expected output:**
```
in namespace
done

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-in namespace
-done
```

---

#### Test: coroutine-2.3

**Script:**
```tcl
# Test: calling finished coroutine is error
proc once {} {
    return "only once"
}
puts [coroutine o once]
catch {o} err
puts "error: [string match {*invalid command*} $err]"
```

**Expected output:**
```
only once
error: 1

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-only once
-error: 1
```

---

#### Test: coroutine-2.4

**Script:**
```tcl
# Test: coroutine with args passed to initial proc
proc greet {name} {
    yield
    yield "hello $name"
    return "bye $name"
}
coroutine g greet "world"
puts [g]
puts [g]
```

**Expected output:**
```
hello world
bye world

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-hello world
-bye world
```

---

#### Test: coroutine-2.5

**Script:**
```tcl
# Test: coroutine with multiple args
proc adder {a b} {
    yield [expr {$a + $b}]
    return "done"
}
coroutine add adder 10 20
puts [add]
```

**Expected output:**
```
done

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-done
```

---

#### Test: coroutine-2.6

**Script:**
```tcl
# Test: local variables persist across yields
proc stateful {} {
    set count 0
    yield
    incr count
    yield $count
    incr count
    yield $count
    incr count
    return $count
}
coroutine s stateful
puts [s]
puts [s]
puts [s]
```

**Expected output:**
```
1
2
3

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-1
-2
-3
```

---

#### Test: coroutine-3.0

**Script:**
```tcl
# Test: generator pattern - fibonacci
proc fib {} {
    yield
    set a 0
    set b 1
    while 1 {
        yield $a
        set tmp $b
        set b [expr {$a + $b}]
        set a $tmp
    }
}
coroutine fibonacci fib
fibonacci
puts [fibonacci]
puts [fibonacci]
puts [fibonacci]
puts [fibonacci]
puts [fibonacci]
puts [fibonacci]
puts [fibonacci]
```

**Expected output:**
```
1
1
2
3
5
8
13

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-1
-1
-2
-3
-5
-8
-13
```

---

#### Test: coroutine-3.1

**Script:**
```tcl
# Test: generator pattern - infinite sequence
proc evens {} {
    yield
    set i 0
    while 1 {
        yield $i
        incr i 2
    }
}
coroutine nextEven evens
nextEven
puts [nextEven]
puts [nextEven]
puts [nextEven]
puts [nextEven]
puts [nextEven]
```

**Expected output:**
```
2
4
6
8
10

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-2
-4
-6
-8
-10
```

---

#### Test: coroutine-3.2

**Script:**
```tcl
# Test: coroutine using apply
coroutine counter apply {{} {
    yield
    set n 0
    while 1 {
        yield [incr n]
    }
}}
counter
puts [counter]
puts [counter]
puts [counter]
```

**Expected output:**
```
2
3
4

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-2
-3
-4
```

---

#### Test: info-coroutine-1.0

**Script:**
```tcl
# Test: info coroutine returns coroutine name
proc showName {} {
    yield
    yield [info coroutine]
    return "done"
}
coroutine myCoroutine showName
puts [myCoroutine]
puts [myCoroutine]
```

**Expected output:**
```
::myCoroutine
done

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-::myCoroutine
-done
```

---

#### Test: info-coroutine-1.1

**Script:**
```tcl
# Test: info coroutine outside coroutine returns empty
puts "[info coroutine]."
```

**Expected output:**
```
.

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-.
```

---

#### Test: info-coroutine-1.2

**Script:**
```tcl
# Test: info coroutine in nested proc inside coroutine
proc inner {} {
    return [info coroutine]
}
proc outer {} {
    yield
    yield [inner]
    return "done"
}
coroutine test123 outer
puts [test123]
puts [test123]
```

**Expected output:**
```
::test123
done

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-::test123
-done
```

---

#### Test: info-coroutine-1.3

**Script:**
```tcl
# Test: multiple coroutines with different names
proc showSelf {} {
    yield
    yield [info coroutine]
    return "done"
}
coroutine coro1 showSelf
coroutine coro2 showSelf
puts [coro1]
puts [coro2]
```

**Expected output:**
```
::coro1
::coro2

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-::coro1
-::coro2
```

---

#### Test: yield-1.0

**Script:**
```tcl
# Test: yield returns to coroutine caller
proc gen {} {
    yield
    yield "first"
    yield "second"
    return "third"
}
coroutine g gen
puts [g]
puts [g]
puts [g]
```

**Expected output:**
```
first
second
third

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-first
-second
-third
```

---

#### Test: yield-1.1

**Script:**
```tcl
# Test: yield inside loop
proc numbers {n} {
    yield
    for {set i 1} {$i <= $n} {incr i} {
        yield $i
    }
    return "done"
}
coroutine nums numbers 5
puts [nums]
puts [nums]
puts [nums]
puts [nums]
puts [nums]
puts [nums]
```

**Expected output:**
```
1
2
3
4
5
done

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-1
-2
-3
-4
-5
-done
```

---

#### Test: yield-1.2

**Script:**
```tcl
# Test: yield with expression value
proc compute {} {
    yield
    yield [expr {2 + 2}]
    yield [expr {3 * 4}]
    return [expr {10 - 1}]
}
coroutine c compute
puts [c]
puts [c]
puts [c]
```

**Expected output:**
```
4
12
9

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-4
-12
-9
```

---

#### Test: yield-1.3

**Script:**
```tcl
# Test: yield with list value
proc listGen {} {
    yield
    yield [list a b c]
    yield [list 1 2 3]
    return [list x y z]
}
coroutine lg listGen
puts [lg]
puts [lg]
puts [lg]
```

**Expected output:**
```
a b c
1 2 3
x y z

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-a b c
-1 2 3
-x y z
```

---

#### Test: yield-1.4

**Script:**
```tcl
# Test: nested procedure call with yield
proc helper {} {
    yield "from helper"
}
proc outer {} {
    yield "before"
    helper
    yield "after"
    return "end"
}
coroutine o outer
puts [o]
puts [o]
puts [o]
```

**Expected output:**
```
from helper
after
end

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-from helper
-after
-end
```

---

#### Test: yield-1.5

**Script:**
```tcl
# Test: yield value with special characters
proc special {} {
    yield
    yield "hello world"
    yield {with {braces}}
    yield "with\ttab"
    return "done"
}
coroutine s special
puts [s]
puts [s]
puts [s]
puts [s]
```

**Expected output:**
```
hello world
with {braces}
with	tab
done

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-hello world
-with {braces}
-with	tab
-done
```

---

#### Test: yieldto-1.0

**Script:**
```tcl
# Test: basic yieldto usage with string cat
proc gen {} {
    yield
    set result [yieldto string cat "yielded"]
    return "got: $result"
}
coroutine g gen
puts [g]
puts [g "input"]
```

**Expected output:**
```
yielded
got: input

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-yielded
-got: input
```

---

#### Test: yieldto-1.1

**Script:**
```tcl
# Test: yieldto with string cat to receive multiple values
proc multiReceive {} {
    yield
    set args [yieldto string cat "ready"]
    return "received: $args"
}
coroutine mr multiReceive
puts [mr]
puts [mr a b c]
```

**Expected output:**
```
ready
received: a b c

```

**Expected return code:** 0

**Actual output:**
```
(empty)
```

**Actual stderr:**
```
Interpreter not implemented yet
```

**Actual return code:** -1

**Diff:**
```diff
--- expected
+++ actual
-ready
-received: a b c
```

---



## Implementation Guidelines

1. **Match TCL 9 semantics exactly** - The oracle (tclsh9) is the source of truth
2. **No memory allocation in C** - Use host callbacks for all dynamic memory
3. **Error messages must match** - TCL has specific error message formats
4. **Handle edge cases** - Empty strings, negative indices, Unicode, etc.

## Files You May Modify

- `core/coro.c` - Coroutine management
- `core/eval.c` - Evaluation loop


## Reference Files

- `core/tclc.h` - Host interface definition
- `harness/oracle/coroutine.json` - Expected test outputs

## Your Task

1. Analyze the failing tests and identify the root cause
1.2	 If no tests exist, use the add-tests skill to tests first.
2. Implement or fix the relevant code in the C core
3. Ensure your changes don't break other tests
4. Run `make diff FEATURE=coroutine` to check against oracle

Focus on making tests pass one at a time. Commit working increments.