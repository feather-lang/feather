     1→package main
     2→
     3→import (
     4→	"context"
     5→	"encoding/json"
     6→	"fmt"
     7→	"os"
     8→	"os/exec"
     9→	"path/filepath"
    10→	"strings"
    11→	"time"
    12→)
    13→
    14→// RunDiff compares our implementation against oracle
    15→func RunDiff(featureID string) error {
    16→	// Load oracle
    17→	oracle, err := loadOracle(featureID)
    18→	if err != nil {
    19→		result := DiffResult{
    20→			Feature: featureID,
    21→			Error:   err.Error(),
    22→		}
    23→		saveResults(featureID, result)
    24→		return err
    25→	}
    26→
    27→	if len(oracle.Tests) == 0 {
    28→		fmt.Printf("No tests in oracle for feature %q\n", featureID)
    29→		result := DiffResult{
    30→			Feature: featureID,
    31→			Error:   "no_tests",
    32→		}
    33→		saveResults(featureID, result)
    34→		return nil
    35→	}
    36→
    37→	interp := os.Getenv("TCLC_INTERP")
    38→	if interp == "" {
    39→		fmt.Println("  Note: TCLC_INTERP not set, using placeholder results")
    40→	}
    41→
    42→	fmt.Printf("Running differential tests for %s...\n", featureID)
    43→
    44→	result := DiffResult{
    45→		Feature: featureID,
    46→		Tests:   make([]TestDiff, 0, len(oracle.Tests)),
    47→	}
    48→
    49→	for _, oracleTest := range oracle.Tests {
    50→		diff := compareTest(interp, oracleTest)
    51→		result.Tests = append(result.Tests, diff)
    52→
    53→		if diff.Passed {
    54→			result.Passed++
    55→			fmt.Printf("  ✓ %s\n", diff.Name)
    56→		} else {
    57→			result.Failed++
    58→			fmt.Printf("  ✗ %s\n", diff.Name)
    59→			if diff.Error != "" {
    60→				fmt.Printf("    Error: %s\n", diff.Error)
    61→			}
    62→		}
    63→	}
    64→
    65→	result.Total = len(result.Tests)
    66→
    67→	// Save results
    68→	if err := saveResults(featureID, result); err != nil {
    69→		return err
    70→	}
    71→
    72→	// Summary
    73→	fmt.Println()
    74→	fmt.Printf("Results: %d/%d tests passing\n", result.Passed, result.Total)
    75→
    76→	return nil
    77→}
    78→
    79→func loadOracle(featureID string) (*OracleResult, error) {
    80→	oracleFile := filepath.Join("harness", "oracle", featureID+".json")
    81→	data, err := os.ReadFile(oracleFile)
    82→	if err != nil {
    83→		if os.IsNotExist(err) {
    84→			return nil, fmt.Errorf("no oracle found for feature %q\nRun: make oracle FEATURE=%s", featureID, featureID)
    85→		}
    86→		return nil, fmt.Errorf("reading oracle: %w", err)
    87→	}
    88→
    89→	var oracle OracleResult
    90→	if err := json.Unmarshal(data, &oracle); err != nil {
    91→		return nil, fmt.Errorf("parsing oracle: %w", err)
    92→	}
    93→
    94→	return &oracle, nil
    95→}
    96→
    97→func compareTest(interp string, oracle OracleTest) TestDiff {
    98→	actual := runOurInterp(interp, oracle.File)
    99→
   100→	stdoutMatch := actual.Stdout == oracle.Stdout
   101→	codeMatch := actual.ReturnCode == oracle.ReturnCode
   102→
   103→	passed := stdoutMatch && codeMatch
   104→
   105→	diff := TestDiff{
   106→		Name:   oracle.Name,
   107→		Passed: passed,
   108→		Expected: TestOutput{
   109→			Stdout:     oracle.Stdout,
   110→			Stderr:     oracle.Stderr,
   111→			ReturnCode: oracle.ReturnCode,
   112→		},
   113→		Actual: actual,
   114→	}
   115→
   116→	if !passed {
   117→		diff.Diff = computeDiff(oracle.Stdout, actual.Stdout)
   118→	}
   119→
   120→	return diff
   121→}
   122→
   123→func runOurInterp(interp, testFile string) TestOutput {
   124→	if interp == "" {
   125→		return TestOutput{
   126→			Stdout:     "",
   127→			Stderr:     "Interpreter not implemented yet",
   128→			ReturnCode: -1,
   129→		}
   130→	}
   131→
   132→	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
   133→	defer cancel()
   134→
   135→	cmd := exec.CommandContext(ctx, interp, testFile)
   136→
   137→	stdout, err := cmd.Output()
   138→	result := TestOutput{
   139→		Stdout: string(stdout),
   140→	}
   141→
   142→	if err != nil {
   143→		if exitErr, ok := err.(*exec.ExitError); ok {
   144→			result.Stderr = string(exitErr.Stderr)
   145→			result.ReturnCode = exitErr.ExitCode()
   146→		} else if ctx.Err() == context.DeadlineExceeded {
   147→			result.Stderr = "timeout"
   148→			result.ReturnCode = -1
   149→		} else {
   150→			result.Stderr = err.Error()
   151→			result.ReturnCode = -1
   152→		}
   153→	}
   154→
   155→	return result
   156→}
   157→
   158→func computeDiff(expected, actual string) string {
   159→	expectedLines := strings.Split(expected, "\n")
   160→	actualLines := strings.Split(actual, "\n")
   161→
   162→	var diff strings.Builder
   163→	diff.WriteString("--- expected\n")
   164→	diff.WriteString("+++ actual\n")
   165→
   166→	maxLines := len(expectedLines)
   167→	if len(actualLines) > maxLines {
   168→		maxLines = len(actualLines)
   169→	}
   170→
   171→	for i := 0; i < maxLines; i++ {
   172→		var expLine, actLine string
   173→		if i < len(expectedLines) {
   174→			expLine = expectedLines[i]
   175→		}
   176→		if i < len(actualLines) {
   177→			actLine = actualLines[i]
   178→		}
   179→
   180→		if expLine != actLine {
   181→			if expLine != "" {
   182→				diff.WriteString("-" + expLine + "\n")
   183→			}
   184→			if actLine != "" {
   185→				diff.WriteString("+" + actLine + "\n")
   186→			}
   187→		}
   188→	}
   189→
   190→	return diff.String()
   191→}
   192→
   193→func saveResults(featureID string, result DiffResult) error {
   194→	resultsDir := filepath.Join("harness", "results")
   195→	if err := os.MkdirAll(resultsDir, 0755); err != nil {
   196→		return fmt.Errorf("creating results directory: %w", err)
   197→	}
   198→
   199→	resultsFile := filepath.Join(resultsDir, featureID+".json")
   200→	data, err := json.MarshalIndent(result, "", "  ")
   201→	if err != nil {
   202→		return fmt.Errorf("encoding results: %w", err)
   203→	}
   204→
   205→	if err := os.WriteFile(resultsFile, data, 0644); err != nil {
   206→		return fmt.Errorf("writing results: %w", err)
   207→	}
   208→
   209→	fmt.Printf("Saved to %s\n", resultsFile)
   210→	return nil
   211→}
   212→
   213→// RunAllDiffs runs differential tests for all features with test directories
   214→func RunAllDiffs() error {
   215→	testDir := filepath.Join("spec", "tests")
   216→	entries, err := os.ReadDir(testDir)
   217→	if err != nil {
   218→		return fmt.Errorf("reading test directory: %w", err)
   219→	}
   220→
   221→	var totalPassed, totalFailed int
   222→	for _, e := range entries {
   223→		if !e.IsDir() {
   224→			continue
   225→		}
   226→		featureID := e.Name()
   227→		if err := RunDiff(featureID); err != nil {
   228→			fmt.Printf("Error running diff for %s: %v\n", featureID, err)
   229→		}
   230→		// Load results to accumulate totals
   231→		if result, _ := LoadResults(featureID); result != nil {
   232→			totalPassed += result.Passed
   233→			totalFailed += result.Failed
   234→		}
   235→	}
   236→
   237→	fmt.Println()
   238→	fmt.Printf("=== Overall: %d passed, %d failed ===\n", totalPassed, totalFailed)
   239→	return nil
   240→}
   241→
   242→// LoadResults loads test results for a feature
   243→func LoadResults(featureID string) (*DiffResult, error) {
   244→	resultsFile := filepath.Join("harness", "results", featureID+".json")
   245→	data, err := os.ReadFile(resultsFile)
   246→	if err != nil {
   247→		if os.IsNotExist(err) {
   248→			return nil, nil
   249→		}
   250→		return nil, err
   251→	}
   252→
   253→	var result DiffResult
   254→	if err := json.Unmarshal(data, &result); err != nil {
   255→		return nil, err
   256→	}
   257→
   258→	return &result, nil
   259→}
   260→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
