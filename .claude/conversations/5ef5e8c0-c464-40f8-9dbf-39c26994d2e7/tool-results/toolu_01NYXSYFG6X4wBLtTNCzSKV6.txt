     1→/*
     2→ * host.c - TclHost Callback Table for C Host
     3→ *
     4→ * Assembles all host callbacks into the TclHost structure.
     5→ */
     6→
     7→#include "../../core/tclc.h"
     8→#include <stdlib.h>
     9→#include <string.h>
    10→
    11→/* External functions from object.c */
    12→extern TclObj *hostNewString(const char *s, size_t len);
    13→extern TclObj *hostNewInt(int64_t val);
    14→extern TclObj *hostNewDouble(double val);
    15→extern TclObj *hostNewBool(int val);
    16→extern TclObj *hostNewList(TclObj **elems, size_t count);
    17→extern TclObj *hostNewDict(void);
    18→extern TclObj *hostDup(TclObj *obj);
    19→extern void hostFreeObj(TclObj *obj);
    20→extern const char *hostGetStringPtr(TclObj *obj, size_t *lenOut);
    21→extern int hostAsInt(TclObj *obj, int64_t *out);
    22→extern int hostAsDouble(TclObj *obj, double *out);
    23→extern int hostAsBool(TclObj *obj, int *out);
    24→extern int hostAsList(TclObj *obj, TclObj ***elemsOut, size_t *countOut);
    25→extern size_t hostStringLength(TclObj *str);
    26→extern int hostStringCompare(TclObj *a, TclObj *b);
    27→extern size_t hostListLengthImpl(TclObj *list);
    28→extern TclObj *hostListIndexImpl(TclObj *list, size_t idx);
    29→
    30→/* External functions from vars.c */
    31→extern void *hostVarsNew(void *ctx);
    32→extern void hostVarsFree(void *ctx, void *vars);
    33→extern TclObj *hostVarGet(void *vars, const char *name, size_t len);
    34→extern void hostVarSet(void *vars, const char *name, size_t len, TclObj *val);
    35→extern void hostVarUnset(void *vars, const char *name, size_t len);
    36→extern int hostVarExists(void *vars, const char *name, size_t len);
    37→extern TclObj *hostVarNames(void *vars, const char *pattern);
    38→extern void hostVarLink(void *localVars, const char *localName, size_t localLen,
    39→                        void *targetVars, const char *targetName, size_t targetLen);
    40→extern void hostArraySet(void *vars, const char *arr, size_t arrLen,
    41→                         const char *key, size_t keyLen, TclObj *val);
    42→extern TclObj *hostArrayGet(void *vars, const char *arr, size_t arrLen,
    43→                            const char *key, size_t keyLen);
    44→extern int hostArrayExists(void *vars, const char *arr, size_t arrLen,
    45→                           const char *key, size_t keyLen);
    46→extern TclObj *hostArrayNames(void *vars, const char *arr, size_t arrLen,
    47→                              const char *pattern);
    48→extern void hostArrayUnset(void *vars, const char *arr, size_t arrLen,
    49→                           const char *key, size_t keyLen);
    50→extern size_t hostArraySize(void *vars, const char *arr, size_t arrLen);
    51→
    52→/* External functions from arena.c */
    53→extern void *hostArenaPush(void *ctx);
    54→extern void hostArenaPop(void *ctx, void *arena);
    55→extern void *hostArenaAlloc(void *arena, size_t size, size_t align);
    56→extern char *hostArenaStrdup(void *arena, const char *s, size_t len);
    57→extern size_t hostArenaMark(void *arena);
    58→extern void hostArenaReset(void *arena, size_t mark);
    59→
    60→/* External functions from channel.c */
    61→extern TclChannel *hostChanOpen(void *ctx, const char *name, const char *mode);
    62→extern void hostChanClose(void *ctx, TclChannel *chan);
    63→extern TclChannel *hostChanStdin(void *ctx);
    64→extern TclChannel *hostChanStdout(void *ctx);
    65→extern TclChannel *hostChanStderr(void *ctx);
    66→extern int hostChanRead(TclChannel *chan, char *buf, size_t len);
    67→extern int hostChanWrite(TclChannel *chan, const char *buf, size_t len);
    68→extern TclObj *hostChanGets(TclChannel *chan, int *eofOut);
    69→extern int hostChanFlush(TclChannel *chan);
    70→extern int hostChanSeek(TclChannel *chan, int64_t offset, int whence);
    71→extern int64_t hostChanTell(TclChannel *chan);
    72→extern int hostChanEof(TclChannel *chan);
    73→extern int hostChanBlocked(TclChannel *chan);
    74→extern int hostChanConfigure(TclChannel *chan, const char *opt, TclObj *val);
    75→extern TclObj *hostChanCget(TclChannel *chan, const char *opt);
    76→extern TclObj *hostChanNames(void *ctx, const char *pattern);
    77→extern void hostChanShare(void *fromCtx, void *toCtx, TclChannel *chan);
    78→extern void hostChanTransfer(void *fromCtx, void *toCtx, TclChannel *chan);
    79→
    80→/* ========================================================================
    81→ * Proc Storage
    82→ * ======================================================================== */
    83→
    84→typedef struct ProcDef {
    85→    char    *name;      /* Procedure name */
    86→    size_t   nameLen;   /* Name length */
    87→    TclObj  *argList;   /* Argument list */
    88→    TclObj  *body;      /* Procedure body */
    89→    struct ProcDef *next;
    90→} ProcDef;
    91→
    92→/* ========================================================================
    93→ * Interpreter Context
    94→ * ======================================================================== */
    95→
    96→typedef struct HostContext {
    97→    void    *globalVars;   /* Global variable table */
    98→    ProcDef *procs;        /* Linked list of procedures */
    99→} HostContext;
   100→
   101→static void *hostInterpContextNew(void *parentCtx, int safe) {
   102→    (void)parentCtx;
   103→    (void)safe;
   104→
   105→    HostContext *ctx = calloc(1, sizeof(HostContext));
   106→    if (!ctx) return NULL;
   107→
   108→    ctx->globalVars = hostVarsNew(ctx);
   109→    ctx->procs = NULL;
   110→    return ctx;
   111→}
   112→
   113→static void hostInterpContextFree(void *ctxPtr) {
   114→    HostContext *ctx = ctxPtr;
   115→    if (!ctx) return;
   116→
   117→    /* Free all procedures */
   118→    ProcDef *proc = ctx->procs;
   119→    while (proc) {
   120→        ProcDef *next = proc->next;
   121→        free(proc->name);
   122→        /* Note: argList and body are TclObj - would need proper cleanup */
   123→        free(proc);
   124→        proc = next;
   125→    }
   126→
   127→    hostVarsFree(ctx, ctx->globalVars);
   128→    free(ctx);
   129→}
   130→
   131→/* ========================================================================
   132→ * Frame Allocation
   133→ * ======================================================================== */
   134→
   135→static TclFrame *hostFrameAlloc(void *ctx) {
   136→    (void)ctx;
   137→    TclFrame *frame = calloc(1, sizeof(TclFrame));
   138→    if (frame) {
   139→        frame->varsHandle = hostVarsNew(ctx);
   140→    }
   141→    return frame;
   142→}
   143→
   144→static void hostFrameFree(void *ctx, TclFrame *frame) {
   145→    if (frame) {
   146→        hostVarsFree(ctx, frame->varsHandle);
   147→        free(frame);
   148→    }
   149→}
   150→
   151→/* ========================================================================
   152→ * Command Lookup - finds procedures registered via proc command
   153→ * ======================================================================== */
   154→
   155→static ProcDef *findProc(HostContext *ctx, const char *name, size_t len) {
   156→    ProcDef *proc = ctx->procs;
   157→    while (proc) {
   158→        if (proc->nameLen == len && memcmp(proc->name, name, len) == 0) {
   159→            return proc;
   160→        }
   161→        proc = proc->next;
   162→    }
   163→    return NULL;
   164→}
   165→
   166→static int hostCmdLookup(void *ctxPtr, const char *name, size_t len, TclCmdInfo *out) {
   167→    HostContext *ctx = ctxPtr;
   168→
   169→    /* Look for a proc with this name */
   170→    ProcDef *proc = findProc(ctx, name, len);
   171→    if (proc) {
   172→        out->type = TCL_CMD_PROC;
   173→        out->u.procHandle = proc;
   174→        return 0;
   175→    }
   176→
   177→    out->type = TCL_CMD_NOT_FOUND;
   178→    return 0;
   179→}
   180→
   181→static void *hostProcRegister(void *ctxPtr, const char *name, size_t len,
   182→                              TclObj *argList, TclObj *body) {
   183→    HostContext *ctx = ctxPtr;
   184→
   185→    /* Check if proc already exists */
   186→    ProcDef *existing = findProc(ctx, name, len);
   187→    if (existing) {
   188→        /* Replace the existing definition */
   189→        existing->argList = hostDup(argList);
   190→        existing->body = hostDup(body);
   191→        return existing;
   192→    }
   193→
   194→    /* Create new proc definition */
   195→    ProcDef *proc = malloc(sizeof(ProcDef));
   196→    if (!proc) return NULL;
   197→
   198→    proc->name = malloc(len + 1);
   199→    if (!proc->name) {
   200→        free(proc);
   201→        return NULL;
   202→    }
   203→    memcpy(proc->name, name, len);
   204→    proc->name[len] = '\0';
   205→    proc->nameLen = len;
   206→    proc->argList = hostDup(argList);
   207→    proc->body = hostDup(body);
   208→
   209→    /* Add to front of list */
   210→    proc->next = ctx->procs;
   211→    ctx->procs = proc;
   212→
   213→    return proc;
   214→}
   215→
   216→static int hostProcGetDef(void *handle, TclObj **argListOut, TclObj **bodyOut) {
   217→    ProcDef *proc = handle;
   218→    if (!proc) return -1;
   219→
   220→    *argListOut = proc->argList;
   221→    *bodyOut = proc->body;
   222→    return 0;
   223→}
   224→
   225→static TclResult hostExtInvoke(TclInterp *interp, void *handle,
   226→                               int objc, TclObj **objv) {
   227→    (void)interp;
   228→    (void)handle;
   229→    (void)objc;
   230→    (void)objv;
   231→    return TCL_ERROR;
   232→}
   233→
   234→static int hostCmdRename(void *ctx, const char *oldName, size_t oldLen,
   235→                         const char *newName, size_t newLen) {
   236→    (void)ctx;
   237→    (void)oldName;
   238→    (void)oldLen;
   239→    (void)newName;
   240→    (void)newLen;
   241→    return -1;
   242→}
   243→
   244→static int hostCmdDelete(void *ctx, const char *name, size_t len) {
   245→    (void)ctx;
   246→    (void)name;
   247→    (void)len;
   248→    return -1;
   249→}
   250→
   251→static int hostCmdExists(void *ctx, const char *name, size_t len) {
   252→    (void)ctx;
   253→    (void)name;
   254→    (void)len;
   255→    return 0;
   256→}
   257→
   258→static TclObj *hostCmdList(void *ctx, const char *pattern) {
   259→    (void)ctx;
   260→    (void)pattern;
   261→    return hostNewString("", 0);
   262→}
   263→
   264→static void hostCmdHide(void *ctx, const char *name, size_t len) {
   265→    (void)ctx;
   266→    (void)name;
   267→    (void)len;
   268→}
   269→
   270→static void hostCmdExpose(void *ctx, const char *name, size_t len) {
   271→    (void)ctx;
   272→    (void)name;
   273→    (void)len;
   274→}
   275→
   276→/* ========================================================================
   277→ * List Operations
   278→ * ======================================================================== */
   279→
   280→static size_t hostListLength(TclObj *list) {
   281→    return hostListLengthImpl(list);
   282→}
   283→
   284→static TclObj *hostListIndex(TclObj *list, size_t idx) {
   285→    return hostListIndexImpl(list, idx);
   286→}
   287→
   288→static TclObj *hostListRange(TclObj *list, size_t first, size_t last) {
   289→    if (!list || first > last) {
   290→        return hostNewString("", 0);
   291→    }
   292→
   293→    size_t listLen = hostListLengthImpl(list);
   294→    if (first >= listLen) {
   295→        return hostNewString("", 0);
   296→    }
   297→    if (last >= listLen) {
   298→        last = listLen - 1;
   299→    }
   300→
   301→    size_t count = last - first + 1;
   302→    TclObj **elems = malloc(count * sizeof(TclObj*));
   303→    if (!elems) return hostNewString("", 0);
   304→
   305→    for (size_t i = 0; i < count; i++) {
   306→        elems[i] = hostListIndexImpl(list, first + i);
   307→    }
   308→
   309→    TclObj *result = hostNewList(elems, count);
   310→    free(elems);
   311→    return result;
   312→}
   313→
   314→static TclObj *hostListSet(TclObj *list, size_t idx, TclObj *val) {
   315→    (void)list;
   316→    (void)idx;
   317→    (void)val;
   318→    return NULL;
   319→}
   320→
   321→static TclObj *hostListAppend(TclObj *list, TclObj *elem) {
   322→    if (!elem) return list ? hostDup(list) : hostNewString("", 0);
   323→
   324→    size_t listLen = list ? hostListLengthImpl(list) : 0;
   325→    size_t newCount = listLen + 1;
   326→
   327→    TclObj **elems = malloc(newCount * sizeof(TclObj*));
   328→    if (!elems) return list ? hostDup(list) : hostNewString("", 0);
   329→
   330→    /* Copy existing elements */
   331→    for (size_t i = 0; i < listLen; i++) {
   332→        elems[i] = hostListIndexImpl(list, i);
   333→    }
   334→    /* Add new element */
   335→    elems[listLen] = elem;
   336→
   337→    TclObj *result = hostNewList(elems, newCount);
   338→    free(elems);
   339→    return result;
   340→}
   341→
   342→static TclObj *hostListConcat(TclObj *a, TclObj *b) {
   343→    (void)a;
   344→    (void)b;
   345→    return NULL;
   346→}
   347→
   348→static TclObj *hostListInsert(TclObj *list, size_t idx, TclObj **elems, size_t count) {
   349→    (void)list;
   350→    (void)idx;
   351→    (void)elems;
   352→    (void)count;
   353→    return NULL;
   354→}
   355→
   356→/* Compare function for qsort - ascending string */
   357→static int cmpStrAsc(const void *a, const void *b) {
   358→    TclObj *oa = *(TclObj **)a;
   359→    TclObj *ob = *(TclObj **)b;
   360→    return hostStringCompare(oa, ob);
   361→}
   362→
   363→/* Compare function for qsort - descending string */
   364→static int cmpStrDesc(const void *a, const void *b) {
   365→    return -cmpStrAsc(a, b);
   366→}
   367→
   368→/* Case-insensitive string comparison */
   369→static int strcasecmpTcl(const char *a, const char *b) {
   370→    while (*a && *b) {
   371→        char ca = *a, cb = *b;
   372→        if (ca >= 'A' && ca <= 'Z') ca += 32;
   373→        if (cb >= 'A' && cb <= 'Z') cb += 32;
   374→        if (ca != cb) return (unsigned char)ca - (unsigned char)cb;
   375→        a++; b++;
   376→    }
   377→    return (unsigned char)*a - (unsigned char)*b;
   378→}
   379→
   380→/* Compare function for qsort - ascending string nocase */
   381→static int cmpStrNocaseAsc(const void *a, const void *b) {
   382→    TclObj *oa = *(TclObj **)a;
   383→    TclObj *ob = *(TclObj **)b;
   384→    size_t lenA, lenB;
   385→    const char *sa = hostGetStringPtr(oa, &lenA);
   386→    const char *sb = hostGetStringPtr(ob, &lenB);
   387→    return strcasecmpTcl(sa, sb);
   388→}
   389→
   390→/* Compare function for qsort - descending string nocase */
   391→static int cmpStrNocaseDesc(const void *a, const void *b) {
   392→    return -cmpStrNocaseAsc(a, b);
   393→}
   394→
   395→/* Compare function for qsort - ascending integer */
   396→static int cmpIntAsc(const void *a, const void *b) {
   397→    TclObj *oa = *(TclObj **)a;
   398→    TclObj *ob = *(TclObj **)b;
   399→    int64_t ia, ib;
   400→    hostAsInt(oa, &ia);
   401→    hostAsInt(ob, &ib);
   402→    if (ia < ib) return -1;
   403→    if (ia > ib) return 1;
   404→    return 0;
   405→}
   406→
   407→/* Compare function for qsort - descending integer */
   408→static int cmpIntDesc(const void *a, const void *b) {
   409→    return -cmpIntAsc(a, b);
   410→}
   411→
   412→/* Compare function for qsort - ascending real */
   413→static int cmpRealAsc(const void *a, const void *b) {
   414→    TclObj *oa = *(TclObj **)a;
   415→    TclObj *ob = *(TclObj **)b;
   416→    double da, db;
   417→    hostAsDouble(oa, &da);
   418→    hostAsDouble(ob, &db);
   419→    if (da < db) return -1;
   420→    if (da > db) return 1;
   421→    return 0;
   422→}
   423→
   424→/* Compare function for qsort - descending real */
   425→static int cmpRealDesc(const void *a, const void *b) {
   426→    return -cmpRealAsc(a, b);
   427→}
   428→
   429→/* Dictionary comparison - case insensitive with embedded numbers */
   430→static int dictcmp(const char *a, const char *b) {
   431→    while (*a && *b) {
   432→        /* Check if both are digits */
   433→        if ((*a >= '0' && *a <= '9') && (*b >= '0' && *b <= '9')) {
   434→            /* Compare as numbers */
   435→            long na = 0, nb = 0;
   436→            while (*a >= '0' && *a <= '9') { na = na * 10 + (*a - '0'); a++; }
   437→            while (*b >= '0' && *b <= '9') { nb = nb * 10 + (*b - '0'); b++; }
   438→            if (na != nb) return (na < nb) ? -1 : 1;
   439→        } else {
   440→            /* Compare as case-insensitive chars */
   441→            char ca = *a, cb = *b;
   442→            if (ca >= 'A' && ca <= 'Z') ca += 32;
   443→            if (cb >= 'A' && cb <= 'Z') cb += 32;
   444→            if (ca != cb) return (unsigned char)ca - (unsigned char)cb;
   445→            a++; b++;
   446→        }
   447→    }
   448→    return (unsigned char)*a - (unsigned char)*b;
   449→}
   450→
   451→/* Compare function for qsort - ascending dictionary */
   452→static int cmpDictAsc(const void *a, const void *b) {
   453→    TclObj *oa = *(TclObj **)a;
   454→    TclObj *ob = *(TclObj **)b;
   455→    size_t lenA, lenB;
   456→    const char *sa = hostGetStringPtr(oa, &lenA);
   457→    const char *sb = hostGetStringPtr(ob, &lenB);
   458→    return dictcmp(sa, sb);
   459→}
   460→
   461→/* Compare function for qsort - descending dictionary */
   462→static int cmpDictDesc(const void *a, const void *b) {
   463→    return -cmpDictAsc(a, b);
   464→}
   465→
   466→static TclObj *hostListSort(TclObj *list, int flags) {
   467→    if (!list) return hostNewString("", 0);
   468→
   469→    size_t listLen = hostListLengthImpl(list);
   470→    if (listLen == 0) return hostNewString("", 0);
   471→    if (listLen == 1) return hostDup(list);
   472→
   473→    /* Get all elements */
   474→    TclObj **elems = malloc(listLen * sizeof(TclObj*));
   475→    if (!elems) return hostDup(list);
   476→
   477→    for (size_t i = 0; i < listLen; i++) {
   478→        elems[i] = hostListIndexImpl(list, i);
   479→    }
   480→
   481→    /* flags: 1=decreasing, 2=integer, 4=nocase, 8=unique, 16=dictionary, 32=real */
   482→    int decreasing = flags & 1;
   483→    int integer = flags & 2;
   484→    int nocase = flags & 4;
   485→    int unique = flags & 8;
   486→    int dictionary = flags & 16;
   487→    int real = flags & 32;
   488→
   489→    /* Select comparison function */
   490→    int (*cmpfn)(const void*, const void*);
   491→    if (integer) {
   492→        cmpfn = decreasing ? cmpIntDesc : cmpIntAsc;
   493→    } else if (real) {
   494→        cmpfn = decreasing ? cmpRealDesc : cmpRealAsc;
   495→    } else if (dictionary) {
   496→        cmpfn = decreasing ? cmpDictDesc : cmpDictAsc;
   497→    } else if (nocase) {
   498→        cmpfn = decreasing ? cmpStrNocaseDesc : cmpStrNocaseAsc;
   499→    } else {
   500→        cmpfn = decreasing ? cmpStrDesc : cmpStrAsc;
   501→    }
   502→
   503→    qsort(elems, listLen, sizeof(TclObj*), cmpfn);
   504→
   505→    /* Apply -unique if requested */
   506→    size_t resultLen = listLen;
   507→    if (unique && listLen > 1) {
   508→        /* Remove duplicates in-place - use same comparison for equality */
   509→        size_t writeIdx = 1;
   510→        for (size_t i = 1; i < listLen; i++) {
   511→            int same = 0;
   512→            if (integer) {
   513→                int64_t a, b;
   514→                hostAsInt(elems[writeIdx-1], &a);
   515→                hostAsInt(elems[i], &b);
   516→                same = (a == b);
   517→            } else if (real) {
   518→                double a, b;
   519→                hostAsDouble(elems[writeIdx-1], &a);
   520→                hostAsDouble(elems[i], &b);
   521→                same = (a == b);
   522→            } else if (dictionary || nocase) {
   523→                size_t lenA, lenB;
   524→                const char *sa = hostGetStringPtr(elems[writeIdx-1], &lenA);
   525→                const char *sb = hostGetStringPtr(elems[i], &lenB);
   526→                same = (strcasecmpTcl(sa, sb) == 0);
   527→            } else {
   528→                same = (hostStringCompare(elems[writeIdx-1], elems[i]) == 0);
   529→            }
   530→            if (!same) {
   531→                if (writeIdx != i) {
   532→                    hostFreeObj(elems[writeIdx]);
   533→                    elems[writeIdx] = elems[i];
   534→                    elems[i] = NULL;
   535→                }
   536→                writeIdx++;
   537→            } else {
   538→                hostFreeObj(elems[i]);
   539→                elems[i] = NULL;
   540→            }
   541→        }
   542→        resultLen = writeIdx;
   543→    }
   544→
   545→    TclObj *result = hostNewList(elems, resultLen);
   546→
   547→    /* Free remaining elements */
   548→    for (size_t i = 0; i < listLen; i++) {
   549→        if (elems[i]) hostFreeObj(elems[i]);
   550→    }
   551→    free(elems);
   552→    return result;
   553→}
   554→
   555→/* ========================================================================
   556→ * Dict Operations (stubs)
   557→ * ======================================================================== */
   558→
   559→static TclObj *hostDictGet(TclObj *dict, TclObj *key) {
   560→    (void)dict;
   561→    (void)key;
   562→    return NULL;
   563→}
   564→
   565→static TclObj *hostDictSet(TclObj *dict, TclObj *key, TclObj *val) {
   566→    (void)dict;
   567→    (void)key;
   568→    (void)val;
   569→    return NULL;
   570→}
   571→
   572→static int hostDictExists(TclObj *dict, TclObj *key) {
   573→    (void)dict;
   574→    (void)key;
   575→    return 0;
   576→}
   577→
   578→static TclObj *hostDictKeys(TclObj *dict, const char *pattern) {
   579→    (void)dict;
   580→    (void)pattern;
   581→    return hostNewString("", 0);
   582→}
   583→
   584→static TclObj *hostDictValues(TclObj *dict, const char *pattern) {
   585→    (void)dict;
   586→    (void)pattern;
   587→    return hostNewString("", 0);
   588→}
   589→
   590→static TclObj *hostDictRemove(TclObj *dict, TclObj *key) {
   591→    (void)dict;
   592→    (void)key;
   593→    return NULL;
   594→}
   595→
   596→static size_t hostDictSize(TclObj *dict) {
   597→    (void)dict;
   598→    return 0;
   599→}
   600→
   601→/* ========================================================================
   602→ * More String Operations (stubs)
   603→ * ======================================================================== */
   604→
   605→static TclObj *hostStringIndex(TclObj *str, size_t idx) {
   606→    (void)str;
   607→    (void)idx;
   608→    return hostNewString("", 0);
   609→}
   610→
   611→static TclObj *hostStringRange(TclObj *str, size_t first, size_t last) {
   612→    (void)str;
   613→    (void)first;
   614→    (void)last;
   615→    return hostNewString("", 0);
   616→}
   617→
   618→static TclObj *hostStringConcat(TclObj **parts, size_t count) {
   619→    (void)parts;
   620→    (void)count;
   621→    return hostNewString("", 0);
   622→}
   623→
   624→static int hostStringCompareNocase(TclObj *a, TclObj *b) {
   625→    (void)a;
   626→    (void)b;
   627→    return 0;
   628→}
   629→
   630→/* Helper for glob pattern matching */
   631→static int globMatch(const char *pat, size_t patLen, const char *str, size_t strLen, int nocase) {
   632→    size_t p = 0, s = 0;
   633→    size_t starP = (size_t)-1, starS = (size_t)-1;
   634→
   635→    while (s < strLen) {
   636→        if (p < patLen && pat[p] == '*') {
   637→            /* Remember position for backtracking */
   638→            starP = p++;
   639→            starS = s;
   640→        } else if (p < patLen && pat[p] == '?') {
   641→            /* Match any single character */
   642→            p++;
   643→            s++;
   644→        } else if (p < patLen && pat[p] == '[') {
   645→            /* Character class */
   646→            p++;
   647→            int invert = 0;
   648→            if (p < patLen && pat[p] == '!') {
   649→                invert = 1;
   650→                p++;
   651→            }
   652→            int matched = 0;
   653→            char sc = nocase && str[s] >= 'A' && str[s] <= 'Z' ? str[s] + 32 : str[s];
   654→            while (p < patLen && pat[p] != ']') {
   655→                char c1 = nocase && pat[p] >= 'A' && pat[p] <= 'Z' ? pat[p] + 32 : pat[p];
   656→                if (p + 2 < patLen && pat[p + 1] == '-' && pat[p + 2] != ']') {
   657→                    char c2 = nocase && pat[p + 2] >= 'A' && pat[p + 2] <= 'Z' ? pat[p + 2] + 32 : pat[p + 2];
   658→                    if (sc >= c1 && sc <= c2) matched = 1;
   659→                    p += 3;
   660→                } else {
   661→                    if (sc == c1) matched = 1;
   662→                    p++;
   663→                }
   664→            }
   665→            if (p < patLen) p++; /* skip ] */
   666→            if (matched == invert) {
   667→                /* No match, try backtracking */
   668→                if (starP == (size_t)-1) return 0;
   669→                p = starP + 1;
   670→                s = ++starS;
   671→            } else {
   672→                s++;
   673→            }
   674→        } else if (p < patLen && pat[p] == '\\' && p + 1 < patLen) {
   675→            /* Escaped character */
   676→            p++;
   677→            char pc = pat[p];
   678→            char sc = str[s];
   679→            if (nocase) {
   680→                if (pc >= 'A' && pc <= 'Z') pc += 32;
   681→                if (sc >= 'A' && sc <= 'Z') sc += 32;
   682→            }
   683→            if (pc == sc) {
   684→                p++;
   685→                s++;
   686→            } else if (starP != (size_t)-1) {
   687→                p = starP + 1;
   688→                s = ++starS;
   689→            } else {
   690→                return 0;
   691→            }
   692→        } else if (p < patLen) {
   693→            /* Literal character */
   694→            char pc = pat[p];
   695→            char sc = str[s];
   696→            if (nocase) {
   697→                if (pc >= 'A' && pc <= 'Z') pc += 32;
   698→                if (sc >= 'A' && sc <= 'Z') sc += 32;
   699→            }
   700→            if (pc == sc) {
   701→                p++;
   702→                s++;
   703→            } else if (starP != (size_t)-1) {
   704→                p = starP + 1;
   705→                s = ++starS;
   706→            } else {
   707→                return 0;
   708→            }
   709→        } else if (starP != (size_t)-1) {
   710→            p = starP + 1;
   711→            s = ++starS;
   712→        } else {
   713→            return 0;
   714→        }
   715→    }
   716→
   717→    /* Skip trailing stars */
   718→    while (p < patLen && pat[p] == '*') p++;
   719→
   720→    return p == patLen;
   721→}
   722→
   723→static int hostStringMatch(const char *pattern, TclObj *str, int nocase) {
   724→    size_t strLen;
   725→    const char *strPtr = hostGetStringPtr(str, &strLen);
   726→    size_t patLen = 0;
   727→    while (pattern[patLen]) patLen++;
   728→    return globMatch(pattern, patLen, strPtr, strLen, nocase);
   729→}
   730→
   731→static TclObj *hostStringToLower(TclObj *str) {
   732→    (void)str;
   733→    return hostNewString("", 0);
   734→}
   735→
   736→static TclObj *hostStringToUpper(TclObj *str) {
   737→    (void)str;
   738→    return hostNewString("", 0);
   739→}
   740→
   741→static TclObj *hostStringTrim(TclObj *str, const char *chars) {
   742→    (void)str;
   743→    (void)chars;
   744→    return hostNewString("", 0);
   745→}
   746→
   747→static TclObj *hostStringReplace(TclObj *str, size_t first, size_t last, TclObj *rep) {
   748→    (void)str;
   749→    (void)first;
   750→    (void)last;
   751→    (void)rep;
   752→    return hostNewString("", 0);
   753→}
   754→
   755→static int hostStringFirst(TclObj *needle, TclObj *haystack, size_t start) {
   756→    (void)needle;
   757→    (void)haystack;
   758→    (void)start;
   759→    return -1;
   760→}
   761→
   762→static int hostStringLast(TclObj *needle, TclObj *haystack, size_t start) {
   763→    (void)needle;
   764→    (void)haystack;
   765→    (void)start;
   766→    return -1;
   767→}
   768→
   769→/* ========================================================================
   770→ * Trace Operations (stubs)
   771→ * ======================================================================== */
   772→
   773→static void hostTraceVarAdd(void *vars, const char *name, size_t len, int ops,
   774→                            TclTraceProc callback, void *clientData) {
   775→    (void)vars;
   776→    (void)name;
   777→    (void)len;
   778→    (void)ops;
   779→    (void)callback;
   780→    (void)clientData;
   781→}
   782→
   783→static void hostTraceVarRemove(void *vars, const char *name, size_t len,
   784→                               TclTraceProc callback, void *clientData) {
   785→    (void)vars;
   786→    (void)name;
   787→    (void)len;
   788→    (void)callback;
   789→    (void)clientData;
   790→}
   791→
   792→/* ========================================================================
   793→ * Event Loop (stubs)
   794→ * ======================================================================== */
   795→
   796→static TclTimerToken hostAfterMs(void *ctx, int ms, TclObj *script) {
   797→    (void)ctx;
   798→    (void)ms;
   799→    (void)script;
   800→    return NULL;
   801→}
   802→
   803→static TclTimerToken hostAfterIdle(void *ctx, TclObj *script) {
   804→    (void)ctx;
   805→    (void)script;
   806→    return NULL;
   807→}
   808→
   809→static void hostAfterCancel(void *ctx, TclTimerToken token) {
   810→    (void)ctx;
   811→    (void)token;
   812→}
   813→
   814→static TclObj *hostAfterInfo(void *ctx, TclTimerToken token) {
   815→    (void)ctx;
   816→    (void)token;
   817→    return hostNewString("", 0);
   818→}
   819→
   820→static void hostFileeventSet(void *ctx, TclChannel *chan, int mask, TclObj *script) {
   821→    (void)ctx;
   822→    (void)chan;
   823→    (void)mask;
   824→    (void)script;
   825→}
   826→
   827→static TclObj *hostFileeventGet(void *ctx, TclChannel *chan, int mask) {
   828→    (void)ctx;
   829→    (void)chan;
   830→    (void)mask;
   831→    return NULL;
   832→}
   833→
   834→static int hostDoOneEvent(void *ctx, int flags) {
   835→    (void)ctx;
   836→    (void)flags;
   837→    return 0;
   838→}
   839→
   840→/* ========================================================================
   841→ * Process/Socket/File stubs
   842→ * ======================================================================== */
   843→
   844→static TclProcess *hostProcessSpawn(const char **argv, int argc, int flags,
   845→                                    TclChannel **pipeIn, TclChannel **pipeOut,
   846→                                    TclChannel **pipeErr) {
   847→    (void)argv; (void)argc; (void)flags;
   848→    (void)pipeIn; (void)pipeOut; (void)pipeErr;
   849→    return NULL;
   850→}
   851→
   852→static int hostProcessWait(TclProcess *proc, int *exitCode) {
   853→    (void)proc; (void)exitCode;
   854→    return -1;
   855→}
   856→
   857→static int hostProcessPid(TclProcess *proc) {
   858→    (void)proc;
   859→    return -1;
   860→}
   861→
   862→static void hostProcessKill(TclProcess *proc, int signal) {
   863→    (void)proc; (void)signal;
   864→}
   865→
   866→static TclChannel *hostSocketOpen(const char *host, int port, int flags) {
   867→    (void)host; (void)port; (void)flags;
   868→    return NULL;
   869→}
   870→
   871→static void *hostSocketListen(const char *addr, int port,
   872→                              TclAcceptProc onAccept, void *clientData) {
   873→    (void)addr; (void)port; (void)onAccept; (void)clientData;
   874→    return NULL;
   875→}
   876→
   877→static void hostSocketListenClose(void *listener) {
   878→    (void)listener;
   879→}
   880→
   881→static int hostFileExists(const char *path) { (void)path; return 0; }
   882→static int hostFileIsFile(const char *path) { (void)path; return 0; }
   883→static int hostFileIsDir(const char *path) { (void)path; return 0; }
   884→static int hostFileReadable(const char *path) { (void)path; return 0; }
   885→static int hostFileWritable(const char *path) { (void)path; return 0; }
   886→static int hostFileExecutable(const char *path) { (void)path; return 0; }
   887→static int64_t hostFileSize(const char *path) { (void)path; return -1; }
   888→static int64_t hostFileMtime(const char *path) { (void)path; return -1; }
   889→static int64_t hostFileAtime(const char *path) { (void)path; return -1; }
   890→static int hostFileDelete(const char *path, int force) { (void)path; (void)force; return -1; }
   891→static int hostFileRename(const char *old, const char *new_, int force) {
   892→    (void)old; (void)new_; (void)force; return -1;
   893→}
   894→static int hostFileMkdir(const char *path) { (void)path; return -1; }
   895→static int hostFileCopy(const char *src, const char *dst, int force) {
   896→    (void)src; (void)dst; (void)force; return -1;
   897→}
   898→static TclObj *hostFileDirname(const char *path) { (void)path; return hostNewString("", 0); }
   899→static TclObj *hostFileTail(const char *path) { (void)path; return hostNewString("", 0); }
   900→static TclObj *hostFileExtension(const char *path) { (void)path; return hostNewString("", 0); }
   901→static TclObj *hostFileRootname(const char *path) { (void)path; return hostNewString("", 0); }
   902→static TclObj *hostFileJoin(TclObj **parts, size_t count) { (void)parts; (void)count; return hostNewString("", 0); }
   903→static TclObj *hostFileNormalize(const char *path) { (void)path; return hostNewString("", 0); }
   904→static TclObj *hostFileSplit(const char *path) { (void)path; return hostNewString("", 0); }
   905→static TclObj *hostFileType(const char *path) { (void)path; return hostNewString("", 0); }
   906→static TclObj *hostGlob(const char *pattern, int types, const char *dir) {
   907→    (void)pattern; (void)types; (void)dir; return hostNewString("", 0);
   908→}
   909→
   910→static int hostChdir(const char *path) { (void)path; return -1; }
   911→static TclObj *hostGetcwd(void) { return hostNewString("", 0); }
   912→static TclObj *hostSysHostname(void) { return hostNewString("", 0); }
   913→static TclObj *hostSysExecutable(void) { return hostNewString("", 0); }
   914→static int hostSysPid(void) { return 0; }
   915→
   916→static TclObj *hostRegexMatch(const char *pat, size_t patLen, TclObj *str, int flags) {
   917→    (void)pat; (void)patLen; (void)str; (void)flags; return NULL;
   918→}
   919→static TclObj *hostRegexSubst(const char *pat, size_t patLen, TclObj *str, TclObj *rep, int flags) {
   920→    (void)pat; (void)patLen; (void)str; (void)rep; (void)flags; return NULL;
   921→}
   922→
   923→static int64_t hostClockSeconds(void) { return 0; }
   924→static int64_t hostClockMillis(void) { return 0; }
   925→static int64_t hostClockMicros(void) { return 0; }
   926→static TclObj *hostClockFormat(int64_t time, const char *fmt, const char *tz) {
   927→    (void)time; (void)fmt; (void)tz; return hostNewString("", 0);
   928→}
   929→static int64_t hostClockScan(const char *str, const char *fmt, const char *tz) {
   930→    (void)str; (void)fmt; (void)tz; return 0;
   931→}
   932→
   933→static TclObj *hostEncodingConvertTo(const char *enc, TclObj *str) {
   934→    (void)enc; (void)str; return NULL;
   935→}
   936→static TclObj *hostEncodingConvertFrom(const char *enc, TclObj *bytes) {
   937→    (void)enc; (void)bytes; return NULL;
   938→}
   939→static TclObj *hostEncodingNames(void) { return hostNewString("", 0); }
   940→static const char *hostEncodingSystem(void) { return "utf-8"; }
   941→
   942→/* ========================================================================
   943→ * The TclHost Callback Table
   944→ * ======================================================================== */
   945→
   946→const TclHost cHost = {
   947→    /* Context */
   948→    .interpContextNew = hostInterpContextNew,
   949→    .interpContextFree = hostInterpContextFree,
   950→
   951→    /* Frames */
   952→    .frameAlloc = hostFrameAlloc,
   953→    .frameFree = hostFrameFree,
   954→
   955→    /* Objects */
   956→    .newString = hostNewString,
   957→    .newInt = hostNewInt,
   958→    .newDouble = hostNewDouble,
   959→    .newBool = hostNewBool,
   960→    .newList = hostNewList,
   961→    .newDict = hostNewDict,
   962→    .dup = hostDup,
   963→    .getStringPtr = hostGetStringPtr,
   964→    .asInt = hostAsInt,
   965→    .asDouble = hostAsDouble,
   966→    .asBool = hostAsBool,
   967→    .asList = hostAsList,
   968→
   969→    /* Lists */
   970→    .listLength = hostListLength,
   971→    .listIndex = hostListIndex,
   972→    .listRange = hostListRange,
   973→    .listSet = hostListSet,
   974→    .listAppend = hostListAppend,
   975→    .listConcat = hostListConcat,
   976→    .listInsert = hostListInsert,
   977→    .listSort = hostListSort,
   978→
   979→    /* Dicts */
   980→    .dictGet = hostDictGet,
   981→    .dictSet = hostDictSet,
   982→    .dictExists = hostDictExists,
   983→    .dictKeys = hostDictKeys,
   984→    .dictValues = hostDictValues,
   985→    .dictRemove = hostDictRemove,
   986→    .dictSize = hostDictSize,
   987→
   988→    /* Strings */
   989→    .stringLength = hostStringLength,
   990→    .stringIndex = hostStringIndex,
   991→    .stringRange = hostStringRange,
   992→    .stringConcat = hostStringConcat,
   993→    .stringCompare = hostStringCompare,
   994→    .stringCompareNocase = hostStringCompareNocase,
   995→    .stringMatch = hostStringMatch,
   996→    .stringToLower = hostStringToLower,
   997→    .stringToUpper = hostStringToUpper,
   998→    .stringTrim = hostStringTrim,
   999→    .stringReplace = hostStringReplace,
  1000→    .stringFirst = hostStringFirst,
  1001→    .stringLast = hostStringLast,
  1002→
  1003→    /* Arena */
  1004→    .arenaPush = hostArenaPush,
  1005→    .arenaPop = hostArenaPop,
  1006→    .arenaAlloc = hostArenaAlloc,
  1007→    .arenaStrdup = hostArenaStrdup,
  1008→    .arenaMark = hostArenaMark,
  1009→    .arenaReset = hostArenaReset,
  1010→
  1011→    /* Variables */
  1012→    .varsNew = hostVarsNew,
  1013→    .varsFree = hostVarsFree,
  1014→    .varGet = hostVarGet,
  1015→    .varSet = hostVarSet,
  1016→    .varUnset = hostVarUnset,
  1017→    .varExists = hostVarExists,
  1018→    .varNames = hostVarNames,
  1019→    .varLink = hostVarLink,
  1020→
  1021→    /* Arrays */
  1022→    .arraySet = hostArraySet,
  1023→    .arrayGet = hostArrayGet,
  1024→    .arrayExists = hostArrayExists,
  1025→    .arrayNames = hostArrayNames,
  1026→    .arrayUnset = hostArrayUnset,
  1027→    .arraySize = hostArraySize,
  1028→
  1029→    /* Traces */
  1030→    .traceVarAdd = hostTraceVarAdd,
  1031→    .traceVarRemove = hostTraceVarRemove,
  1032→
  1033→    /* Commands */
  1034→    .cmdLookup = hostCmdLookup,
  1035→    .procRegister = hostProcRegister,
  1036→    .procGetDef = hostProcGetDef,
  1037→    .extInvoke = hostExtInvoke,
  1038→    .cmdRename = hostCmdRename,
  1039→    .cmdDelete = hostCmdDelete,
  1040→    .cmdExists = hostCmdExists,
  1041→    .cmdList = hostCmdList,
  1042→    .cmdHide = hostCmdHide,
  1043→    .cmdExpose = hostCmdExpose,
  1044→
  1045→    /* Channels */
  1046→    .chanOpen = hostChanOpen,
  1047→    .chanClose = hostChanClose,
  1048→    .chanStdin = hostChanStdin,
  1049→    .chanStdout = hostChanStdout,
  1050→    .chanStderr = hostChanStderr,
  1051→    .chanRead = hostChanRead,
  1052→    .chanWrite = hostChanWrite,
  1053→    .chanGets = hostChanGets,
  1054→    .chanFlush = hostChanFlush,
  1055→    .chanSeek = hostChanSeek,
  1056→    .chanTell = hostChanTell,
  1057→    .chanEof = hostChanEof,
  1058→    .chanBlocked = hostChanBlocked,
  1059→    .chanConfigure = hostChanConfigure,
  1060→    .chanCget = hostChanCget,
  1061→    .chanNames = hostChanNames,
  1062→    .chanShare = hostChanShare,
  1063→    .chanTransfer = hostChanTransfer,
  1064→
  1065→    /* Event loop */
  1066→    .afterMs = hostAfterMs,
  1067→    .afterIdle = hostAfterIdle,
  1068→    .afterCancel = hostAfterCancel,
  1069→    .afterInfo = hostAfterInfo,
  1070→    .fileeventSet = hostFileeventSet,
  1071→    .fileeventGet = hostFileeventGet,
  1072→    .doOneEvent = hostDoOneEvent,
  1073→
  1074→    /* Process */
  1075→    .processSpawn = hostProcessSpawn,
  1076→    .processWait = hostProcessWait,
  1077→    .processPid = hostProcessPid,
  1078→    .processKill = hostProcessKill,
  1079→
  1080→    /* Sockets */
  1081→    .socketOpen = hostSocketOpen,
  1082→    .socketListen = hostSocketListen,
  1083→    .socketListenClose = hostSocketListenClose,
  1084→
  1085→    /* Filesystem */
  1086→    .fileExists = hostFileExists,
  1087→    .fileIsFile = hostFileIsFile,
  1088→    .fileIsDir = hostFileIsDir,
  1089→    .fileReadable = hostFileReadable,
  1090→    .fileWritable = hostFileWritable,
  1091→    .fileExecutable = hostFileExecutable,
  1092→    .fileSize = hostFileSize,
  1093→    .fileMtime = hostFileMtime,
  1094→    .fileAtime = hostFileAtime,
  1095→    .fileDelete = hostFileDelete,
  1096→    .fileRename = hostFileRename,
  1097→    .fileMkdir = hostFileMkdir,
  1098→    .fileCopy = hostFileCopy,
  1099→    .fileDirname = hostFileDirname,
  1100→    .fileTail = hostFileTail,
  1101→    .fileExtension = hostFileExtension,
  1102→    .fileRootname = hostFileRootname,
  1103→    .fileJoin = hostFileJoin,
  1104→    .fileNormalize = hostFileNormalize,
  1105→    .fileSplit = hostFileSplit,
  1106→    .fileType = hostFileType,
  1107→    .glob = hostGlob,
  1108→
  1109→    /* System */
  1110→    .chdir = hostChdir,
  1111→    .getcwd = hostGetcwd,
  1112→    .sysHostname = hostSysHostname,
  1113→    .sysExecutable = hostSysExecutable,
  1114→    .sysPid = hostSysPid,
  1115→
  1116→    /* Regex */
  1117→    .regexMatch = hostRegexMatch,
  1118→    .regexSubst = hostRegexSubst,
  1119→
  1120→    /* Clock */
  1121→    .clockSeconds = hostClockSeconds,
  1122→    .clockMillis = hostClockMillis,
  1123→    .clockMicros = hostClockMicros,
  1124→    .clockFormat = hostClockFormat,
  1125→    .clockScan = hostClockScan,
  1126→
  1127→    /* Encoding */
  1128→    .encodingConvertTo = hostEncodingConvertTo,
  1129→    .encodingConvertFrom = hostEncodingConvertFrom,
  1130→    .encodingNames = hostEncodingNames,
  1131→    .encodingSystem = hostEncodingSystem,
  1132→};
  1133→
  1134→/* Export the host table */
  1135→const TclHost *tclGetCHost(void) {
  1136→    return &cHost;
  1137→}
  1138→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
