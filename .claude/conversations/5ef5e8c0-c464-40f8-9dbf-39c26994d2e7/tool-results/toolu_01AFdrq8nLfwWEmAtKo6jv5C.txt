     1→/*
     2→ * object.c - TclObj Implementation for C Host
     3→ *
     4→ * Implements TCL value objects with string representation and
     5→ * optional cached numeric representations.
     6→ */
     7→
     8→#include "../../core/tclc.h"
     9→#include <stdlib.h>
    10→#include <string.h>
    11→#include <stdio.h>
    12→#include <errno.h>
    13→#include <limits.h>
    14→
    15→/* Object structure - opaque to core */
    16→struct TclObj {
    17→    char   *stringRep;      /* String representation (always valid) */
    18→    size_t  stringLen;      /* Length of string */
    19→    int     hasInt;         /* Has cached integer value */
    20→    int64_t intRep;         /* Cached integer value */
    21→    int     hasDouble;      /* Has cached double value */
    22→    double  doubleRep;      /* Cached double value */
    23→    int     refCount;       /* Reference count (for future use) */
    24→};
    25→
    26→/* Create a new string object */
    27→TclObj *hostNewString(const char *s, size_t len) {
    28→    TclObj *obj = malloc(sizeof(TclObj));
    29→    if (!obj) return NULL;
    30→
    31→    obj->stringRep = malloc(len + 1);
    32→    if (!obj->stringRep) {
    33→        free(obj);
    34→        return NULL;
    35→    }
    36→
    37→    memcpy(obj->stringRep, s, len);
    38→    obj->stringRep[len] = '\0';
    39→    obj->stringLen = len;
    40→    obj->hasInt = 0;
    41→    obj->hasDouble = 0;
    42→    obj->refCount = 1;
    43→
    44→    return obj;
    45→}
    46→
    47→/* Create a new integer object */
    48→TclObj *hostNewInt(int64_t val) {
    49→    char buf[32];
    50→    int len = snprintf(buf, sizeof(buf), "%lld", (long long)val);
    51→
    52→    TclObj *obj = hostNewString(buf, len);
    53→    if (obj) {
    54→        obj->hasInt = 1;
    55→        obj->intRep = val;
    56→    }
    57→    return obj;
    58→}
    59→
    60→/* Helper to check if value is infinite */
    61→static int isInf(double val) {
    62→    return val > 1e308 || val < -1e308;
    63→}
    64→
    65→/* Helper to check if value is NaN */
    66→static int isNaN(double val) {
    67→    return val != val;
    68→}
    69→
    70→/* Create a new double object */
    71→TclObj *hostNewDouble(double val) {
    72→    char buf[64];
    73→    int len;
    74→
    75→    /* Handle special values */
    76→    if (isNaN(val)) {
    77→        len = snprintf(buf, sizeof(buf), "NaN");
    78→    } else if (isInf(val)) {
    79→        len = snprintf(buf, sizeof(buf), val > 0 ? "Inf" : "-Inf");
    80→    } else {
    81→        len = snprintf(buf, sizeof(buf), "%g", val);
    82→
    83→        /* Tcl always shows at least ".0" for floats that are whole numbers */
    84→        /* Check if we need to add ".0" - if no '.' or 'e' in the output */
    85→        int hasDot = 0, hasE = 0;
    86→        for (int i = 0; i < len; i++) {
    87→            if (buf[i] == '.') hasDot = 1;
    88→            if (buf[i] == 'e' || buf[i] == 'E') hasE = 1;
    89→        }
    90→        if (!hasDot && !hasE && len < 62) {
    91→            buf[len++] = '.';
    92→            buf[len++] = '0';
    93→            buf[len] = '\0';
    94→        }
    95→    }
    96→
    97→    TclObj *obj = hostNewString(buf, len);
    98→    if (obj) {
    99→        obj->hasDouble = 1;
   100→        obj->doubleRep = val;
   101→    }
   102→    return obj;
   103→}
   104→
   105→/* Create a new boolean object */
   106→TclObj *hostNewBool(int val) {
   107→    return hostNewString(val ? "1" : "0", 1);
   108→}
   109→
   110→/* Check if a string needs quoting in a list - returns:
   111→ * 0 = no quoting needed
   112→ * 1 = can use brace quoting
   113→ * 2 = needs backslash quoting (unbalanced braces, odd trailing \, or ")
   114→ */
   115→static int needsListQuoting(const char *s, size_t len) {
   116→    if (len == 0) return 1;  /* Empty string needs braces */
   117→
   118→    /* Check if starts with # (needs brace quoting to prevent comment) */
   119→    int startsWithHash = (s[0] == '#');
   120→
   121→    int needsQuote = startsWithHash;
   122→    int braceDepth = 0;
   123→    int hasUnbalancedBrace = 0;
   124→    int hasQuote = 0;
   125→
   126→    /* If string starts with { it could be parsed as a braced word - needs quoting */
   127→    int startsWithBrace = (s[0] == '{');
   128→    if (startsWithBrace) needsQuote = 1;
   129→
   130→    for (size_t i = 0; i < len; i++) {
   131→        char c = s[i];
   132→        if (c == '{') {
   133→            braceDepth++;
   134→        } else if (c == '}') {
   135→            braceDepth--;
   136→            if (braceDepth < 0) hasUnbalancedBrace = 1;
   137→        } else if (c == '"') {
   138→            hasQuote = 1;
   139→            needsQuote = 1;
   140→        } else if (c == '\\') {
   141→            needsQuote = 1;
   142→        } else if (c == ' ' || c == '\t' || c == '\n' || c == '\r' ||
   143→                   c == '$' || c == '[' || c == ']' || c == ';') {
   144→            needsQuote = 1;
   145→        }
   146→    }
   147→
   148→    if (braceDepth != 0) hasUnbalancedBrace = 1;
   149→
   150→    /* Unbalanced braces need quoting */
   151→    if (hasUnbalancedBrace) needsQuote = 1;
   152→
   153→    /* Count trailing backslashes - odd count can't use brace quoting */
   154→    int trailingBackslashes = 0;
   155→    for (size_t i = len; i > 0; i--) {
   156→        if (s[i-1] == '\\') trailingBackslashes++;
   157→        else break;
   158→    }
   159→    int hasOddTrailingBackslash = (trailingBackslashes % 2 == 1);
   160→
   161→    if (!needsQuote) return 0;
   162→    /* Can't use brace quoting if: unbalanced braces, has quotes, or odd trailing backslash */
   163→    if (hasUnbalancedBrace || hasQuote || hasOddTrailingBackslash) return 2;
   164→    return 1;  /* can use brace quoting */
   165→}
   166→
   167→/* Count backslash-escaped length for an element */
   168→static size_t backslashQuotedLen(const char *s, size_t len) {
   169→    size_t result = 0;
   170→    for (size_t i = 0; i < len; i++) {
   171→        char c = s[i];
   172→        if (c == '{' || c == '}' || c == '\\' || c == '"' ||
   173→            c == '$' || c == '[' || c == ']' || c == ' ' || c == ';') {
   174→            result += 2;  /* backslash + char */
   175→        } else {
   176→            result += 1;
   177→        }
   178→    }
   179→    return result;
   180→}
   181→
   182→/* Write backslash-quoted string */
   183→static char *writeBackslashQuoted(char *p, const char *s, size_t len) {
   184→    for (size_t i = 0; i < len; i++) {
   185→        char c = s[i];
   186→        if (c == '{' || c == '}' || c == '\\' || c == '"' ||
   187→            c == '$' || c == '[' || c == ']' || c == ' ' || c == ';') {
   188→            *p++ = '\\';
   189→        }
   190→        *p++ = c;
   191→    }
   192→    return p;
   193→}
   194→
   195→/* Create a new list object with proper quoting */
   196→TclObj *hostNewList(TclObj **elems, size_t count) {
   197→    if (count == 0) {
   198→        return hostNewString("", 0);
   199→    }
   200→
   201→    /* Calculate total length needed */
   202→    size_t totalLen = 0;
   203→    for (size_t i = 0; i < count; i++) {
   204→        int quoteType = needsListQuoting(elems[i]->stringRep, elems[i]->stringLen);
   205→        if (quoteType == 2) {
   206→            /* Backslash quoting */
   207→            totalLen += backslashQuotedLen(elems[i]->stringRep, elems[i]->stringLen);
   208→        } else if (quoteType == 1) {
   209→            totalLen += elems[i]->stringLen + 2;  /* Add {} */
   210→        } else {
   211→            totalLen += elems[i]->stringLen;
   212→        }
   213→        if (i > 0) totalLen++;  /* space separator */
   214→    }
   215→
   216→    char *buf = malloc(totalLen + 1);
   217→    if (!buf) return NULL;
   218→
   219→    char *p = buf;
   220→    for (size_t i = 0; i < count; i++) {
   221→        if (i > 0) *p++ = ' ';
   222→        int quoteType = needsListQuoting(elems[i]->stringRep, elems[i]->stringLen);
   223→        if (quoteType == 2) {
   224→            /* Backslash quoting */
   225→            p = writeBackslashQuoted(p, elems[i]->stringRep, elems[i]->stringLen);
   226→        } else if (quoteType == 1) {
   227→            *p++ = '{';
   228→            memcpy(p, elems[i]->stringRep, elems[i]->stringLen);
   229→            p += elems[i]->stringLen;
   230→            *p++ = '}';
   231→        } else {
   232→            memcpy(p, elems[i]->stringRep, elems[i]->stringLen);
   233→            p += elems[i]->stringLen;
   234→        }
   235→    }
   236→    *p = '\0';
   237→
   238→    TclObj *obj = hostNewString(buf, p - buf);
   239→    free(buf);
   240→    return obj;
   241→}
   242→
   243→/* Create empty dict (as empty string for now) */
   244→TclObj *hostNewDict(void) {
   245→    return hostNewString("", 0);
   246→}
   247→
   248→/* Duplicate an object */
   249→TclObj *hostDup(TclObj *obj) {
   250→    if (!obj) return NULL;
   251→    TclObj *dup = hostNewString(obj->stringRep, obj->stringLen);
   252→    if (dup) {
   253→        dup->hasInt = obj->hasInt;
   254→        dup->intRep = obj->intRep;
   255→        dup->hasDouble = obj->hasDouble;
   256→        dup->doubleRep = obj->doubleRep;
   257→    }
   258→    return dup;
   259→}
   260→
   261→/* Free an object */
   262→void hostFreeObj(TclObj *obj) {
   263→    if (obj) {
   264→        free(obj->stringRep);
   265→        free(obj);
   266→    }
   267→}
   268→
   269→/* Get string representation */
   270→const char *hostGetStringPtr(TclObj *obj, size_t *lenOut) {
   271→    if (!obj) {
   272→        if (lenOut) *lenOut = 0;
   273→        return "";
   274→    }
   275→    if (lenOut) *lenOut = obj->stringLen;
   276→    return obj->stringRep;
   277→}
   278→
   279→/* Convert to integer (caches result) */
   280→int hostAsInt(TclObj *obj, int64_t *out) {
   281→    if (!obj) return -1;
   282→
   283→    if (obj->hasInt) {
   284→        *out = obj->intRep;
   285→        return 0;
   286→    }
   287→
   288→    /* Try to parse */
   289→    char *endptr;
   290→    errno = 0;
   291→    long long val = strtoll(obj->stringRep, &endptr, 0);
   292→
   293→    /* Check for errors */
   294→    if (errno == ERANGE || endptr == obj->stringRep) {
   295→        return -1;
   296→    }
   297→
   298→    /* Skip trailing whitespace */
   299→    while (*endptr == ' ' || *endptr == '\t') endptr++;
   300→    if (*endptr != '\0') {
   301→        return -1;
   302→    }
   303→
   304→    obj->hasInt = 1;
   305→    obj->intRep = val;
   306→    *out = val;
   307→    return 0;
   308→}
   309→
   310→/* Convert to double (caches result) */
   311→int hostAsDouble(TclObj *obj, double *out) {
   312→    if (!obj) return -1;
   313→
   314→    if (obj->hasDouble) {
   315→        *out = obj->doubleRep;
   316→        return 0;
   317→    }
   318→
   319→    /* Try to parse */
   320→    char *endptr;
   321→    errno = 0;
   322→    double val = strtod(obj->stringRep, &endptr);
   323→
   324→    /* Check for errors */
   325→    if (errno == ERANGE || endptr == obj->stringRep) {
   326→        return -1;
   327→    }
   328→
   329→    /* Skip trailing whitespace */
   330→    while (*endptr == ' ' || *endptr == '\t') endptr++;
   331→    if (*endptr != '\0') {
   332→        return -1;
   333→    }
   334→
   335→    obj->hasDouble = 1;
   336→    obj->doubleRep = val;
   337→    *out = val;
   338→    return 0;
   339→}
   340→
   341→/* Convert to boolean */
   342→int hostAsBool(TclObj *obj, int *out) {
   343→    if (!obj) return -1;
   344→
   345→    /* Check for common boolean strings */
   346→    const char *s = obj->stringRep;
   347→    size_t len = obj->stringLen;
   348→
   349→    if (len == 1) {
   350→        if (s[0] == '0') { *out = 0; return 0; }
   351→        if (s[0] == '1') { *out = 1; return 0; }
   352→    }
   353→
   354→    if ((len == 4 && strncmp(s, "true", 4) == 0) ||
   355→        (len == 3 && strncmp(s, "yes", 3) == 0) ||
   356→        (len == 2 && strncmp(s, "on", 2) == 0)) {
   357→        *out = 1;
   358→        return 0;
   359→    }
   360→
   361→    if ((len == 5 && strncmp(s, "false", 5) == 0) ||
   362→        (len == 2 && strncmp(s, "no", 2) == 0) ||
   363→        (len == 3 && strncmp(s, "off", 3) == 0)) {
   364→        *out = 0;
   365→        return 0;
   366→    }
   367→
   368→    /* Try as integer */
   369→    int64_t ival;
   370→    if (hostAsInt(obj, &ival) == 0) {
   371→        *out = (ival != 0);
   372→        return 0;
   373→    }
   374→
   375→    return -1;
   376→}
   377→
   378→/* ========================================================================
   379→ * TCL List Parsing
   380→ *
   381→ * Parses TCL list syntax: elements separated by whitespace.
   382→ * Elements can be quoted with braces {}, double quotes "", or bare words.
   383→ * ======================================================================== */
   384→
   385→static int isListSpace(char c) {
   386→    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
   387→}
   388→
   389→/* Parse a single list element starting at *pos.
   390→ * Updates *pos to point past the element.
   391→ * Returns a new TclObj for the element, or NULL on error.
   392→ */
   393→static TclObj *parseListElement(const char **pos, const char *end) {
   394→    const char *p = *pos;
   395→
   396→    /* Skip leading whitespace */
   397→    while (p < end && isListSpace(*p)) p++;
   398→
   399→    if (p >= end) {
   400→        *pos = p;
   401→        return NULL;  /* No more elements */
   402→    }
   403→
   404→    const char *start;
   405→    size_t len;
   406→
   407→    if (*p == '{') {
   408→        /* Braced element - find matching close brace */
   409→        p++;  /* Skip { */
   410→        start = p;
   411→        int depth = 1;
   412→        while (p < end && depth > 0) {
   413→            if (*p == '{') depth++;
   414→            else if (*p == '}') depth--;
   415→            if (depth > 0) p++;
   416→        }
   417→        /* Check for unclosed brace */
   418→        if (depth > 0) {
   419→            *pos = p;
   420→            return (TclObj *)(intptr_t)-1;  /* Error indicator */
   421→        }
   422→        len = p - start;
   423→        if (p < end) p++;  /* Skip } */
   424→        *pos = p;
   425→        return hostNewString(start, len);
   426→    }
   427→
   428→    if (*p == '"') {
   429→        /* Quoted element - find closing quote */
   430→        p++;  /* Skip " */
   431→        start = p;
   432→        while (p < end && *p != '"') {
   433→            if (*p == '\\' && p + 1 < end) p++;  /* Skip escape */
   434→            p++;
   435→        }
   436→        len = p - start;
   437→        if (p < end) p++;  /* Skip " */
   438→        *pos = p;
   439→        return hostNewString(start, len);
   440→    }
   441→
   442→    /* Bare word - read until unescaped whitespace, and unescape backslashes */
   443→    start = p;
   444→    int hasEscape = 0;
   445→    const char *scanP = p;
   446→    while (scanP < end) {
   447→        if (*scanP == '\\' && scanP + 1 < end) {
   448→            hasEscape = 1;
   449→            scanP += 2;
   450→        } else if (isListSpace(*scanP)) {
   451→            break;
   452→        } else {
   453→            scanP++;
   454→        }
   455→    }
   456→    len = scanP - start;
   457→    *pos = scanP;
   458→
   459→    if (!hasEscape) {
   460→        return hostNewString(start, len);
   461→    }
   462→
   463→    /* Need to unescape backslashes */
   464→    char *buf = malloc(len + 1);
   465→    if (!buf) return hostNewString(start, len);
   466→
   467→    char *out = buf;
   468→    p = start;
   469→    while (p < scanP) {
   470→        if (*p == '\\' && p + 1 < scanP) {
   471→            p++;  /* Skip backslash */
   472→            *out++ = *p++;
   473→        } else {
   474→            *out++ = *p++;
   475→        }
   476→    }
   477→    *out = '\0';
   478→
   479→    TclObj *result = hostNewString(buf, out - buf);
   480→    free(buf);
   481→    return result;
   482→}
   483→
   484→/* Parse list into array of elements.
   485→ * Caller must free the array and its elements.
   486→ */
   487→static int parseList(TclObj *obj, TclObj ***elemsOut, size_t *countOut) {
   488→    if (!obj) {
   489→        *elemsOut = NULL;
   490→        *countOut = 0;
   491→        return 0;
   492→    }
   493→
   494→    const char *str = obj->stringRep;
   495→    size_t strLen = obj->stringLen;
   496→    const char *end = str + strLen;
   497→
   498→    /* Count elements first (estimate) */
   499→    size_t capacity = 16;
   500→    TclObj **elems = malloc(capacity * sizeof(TclObj*));
   501→    if (!elems) return -1;
   502→
   503→    size_t count = 0;
   504→    const char *pos = str;
   505→
   506→    while (pos < end) {
   507→        /* Skip whitespace */
   508→        while (pos < end && isListSpace(*pos)) pos++;
   509→        if (pos >= end) break;
   510→
   511→        TclObj *elem = parseListElement(&pos, end);
   512→        if (!elem) break;
   513→        if (elem == (TclObj *)(intptr_t)-1) {
   514→            /* Parse error - unclosed brace/quote */
   515→            for (size_t i = 0; i < count; i++) {
   516→                free(elems[i]->stringRep);
   517→                free(elems[i]);
   518→            }
   519→            free(elems);
   520→            return -1;
   521→        }
   522→
   523→        /* Grow array if needed */
   524→        if (count >= capacity) {
   525→            capacity *= 2;
   526→            TclObj **newElems = realloc(elems, capacity * sizeof(TclObj*));
   527→            if (!newElems) {
   528→                for (size_t i = 0; i < count; i++) {
   529→                    free(elems[i]->stringRep);
   530→                    free(elems[i]);
   531→                }
   532→                free(elems);
   533→                return -1;
   534→            }
   535→            elems = newElems;
   536→        }
   537→
   538→        elems[count++] = elem;
   539→    }
   540→
   541→    *elemsOut = elems;
   542→    *countOut = count;
   543→    return 0;
   544→}
   545→
   546→/* Convert to list */
   547→int hostAsList(TclObj *obj, TclObj ***elemsOut, size_t *countOut) {
   548→    return parseList(obj, elemsOut, countOut);
   549→}
   550→
   551→/* Get list length */
   552→size_t hostListLengthImpl(TclObj *list) {
   553→    if (!list || list->stringLen == 0) return 0;
   554→
   555→    TclObj **elems;
   556→    size_t count;
   557→    if (parseList(list, &elems, &count) != 0) return 0;
   558→
   559→    /* Free the parsed elements */
   560→    for (size_t i = 0; i < count; i++) {
   561→        free(elems[i]->stringRep);
   562→        free(elems[i]);
   563→    }
   564→    free(elems);
   565→
   566→    return count;
   567→}
   568→
   569→/* Get list element by index */
   570→TclObj *hostListIndexImpl(TclObj *list, size_t idx) {
   571→    if (!list) return NULL;
   572→
   573→    TclObj **elems;
   574→    size_t count;
   575→    if (parseList(list, &elems, &count) != 0) return NULL;
   576→
   577→    TclObj *result = NULL;
   578→    if (idx < count) {
   579→        result = hostDup(elems[idx]);
   580→    }
   581→
   582→    /* Free the parsed elements */
   583→    for (size_t i = 0; i < count; i++) {
   584→        free(elems[i]->stringRep);
   585→        free(elems[i]);
   586→    }
   587→    free(elems);
   588→
   589→    return result;
   590→}
   591→
   592→/* String length in characters (bytes for now, TODO: UTF-8) */
   593→size_t hostStringLength(TclObj *str) {
   594→    return str ? str->stringLen : 0;
   595→}
   596→
   597→/* String comparison */
   598→int hostStringCompare(TclObj *a, TclObj *b) {
   599→    if (!a && !b) return 0;
   600→    if (!a) return -1;
   601→    if (!b) return 1;
   602→    return strcmp(a->stringRep, b->stringRep);
   603→}
   604→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
