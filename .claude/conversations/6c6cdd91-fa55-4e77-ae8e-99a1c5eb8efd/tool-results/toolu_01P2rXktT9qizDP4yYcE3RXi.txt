     1→/*
     2→ * builtins.c - TCL Built-in Commands
     3→ *
     4→ * Static table of built-in commands and their implementations.
     5→ */
     6→
     7→#include "internal.h"
     8→
     9→/* ========================================================================
    10→ * puts Command
    11→ * ======================================================================== */
    12→
    13→TclResult tclCmdPuts(TclInterp *interp, int objc, TclObj **objv) {
    14→    const TclHost *host = interp->host;
    15→    int newline = 1;
    16→    int argStart = 1;
    17→    TclChannel *chan = host->chanStdout(interp->hostCtx);
    18→
    19→    /* Check for -nonewline flag */
    20→    if (objc >= 2) {
    21→        size_t len;
    22→        const char *arg = host->getStringPtr(objv[1], &len);
    23→        if (len == 10 && tclStrncmp(arg, "-nonewline", 10) == 0) {
    24→            newline = 0;
    25→            argStart = 2;
    26→        }
    27→    }
    28→
    29→    /* Check argument count */
    30→    int remaining = objc - argStart;
    31→    if (remaining < 1 || remaining > 2) {
    32→        tclSetError(interp, "wrong # args: should be \"puts ?-nonewline? ?channelId? string\"", -1);
    33→        return TCL_ERROR;
    34→    }
    35→
    36→    /* Get channel and string */
    37→    TclObj *strObj;
    38→    if (remaining == 2) {
    39→        size_t chanLen;
    40→        const char *chanName = host->getStringPtr(objv[argStart], &chanLen);
    41→
    42→        if (chanLen == 6 && tclStrncmp(chanName, "stdout", 6) == 0) {
    43→            chan = host->chanStdout(interp->hostCtx);
    44→        } else if (chanLen == 6 && tclStrncmp(chanName, "stderr", 6) == 0) {
    45→            chan = host->chanStderr(interp->hostCtx);
    46→        } else {
    47→            tclSetError(interp, "can not find channel", -1);
    48→            return TCL_ERROR;
    49→        }
    50→        strObj = objv[argStart + 1];
    51→    } else {
    52→        strObj = objv[argStart];
    53→    }
    54→
    55→    /* Write string */
    56→    size_t strLen;
    57→    const char *str = host->getStringPtr(strObj, &strLen);
    58→    host->chanWrite(chan, str, strLen);
    59→    if (newline) {
    60→        host->chanWrite(chan, "\n", 1);
    61→    }
    62→
    63→    tclSetResult(interp, host->newString("", 0));
    64→    return TCL_OK;
    65→}
    66→
    67→/* ========================================================================
    68→ * set Command
    69→ * ======================================================================== */
    70→
    71→TclResult tclCmdSet(TclInterp *interp, int objc, TclObj **objv) {
    72→    const TclHost *host = interp->host;
    73→
    74→    if (objc < 2 || objc > 3) {
    75→        tclSetError(interp, "wrong # args: should be \"set varName ?newValue?\"", -1);
    76→        return TCL_ERROR;
    77→    }
    78→
    79→    size_t nameLen;
    80→    const char *name = host->getStringPtr(objv[1], &nameLen);
    81→    void *vars = interp->currentFrame->varsHandle;
    82→
    83→    if (objc == 3) {
    84→        /* Setting a value */
    85→        TclObj *value = host->dup(objv[2]);
    86→        host->varSet(vars, name, nameLen, value);
    87→        tclSetResult(interp, host->dup(objv[2]));
    88→    } else {
    89→        /* Getting a value */
    90→        TclObj *value = host->varGet(vars, name, nameLen);
    91→
    92→        /* Try global frame if not found */
    93→        if (!value && interp->currentFrame != interp->globalFrame) {
    94→            value = host->varGet(interp->globalFrame->varsHandle, name, nameLen);
    95→        }
    96→
    97→        if (!value) {
    98→            /* Build error message: can't read "varname": no such variable */
    99→            void *arena = host->arenaPush(interp->hostCtx);
   100→            char *errBuf = host->arenaAlloc(arena, nameLen + 50, 1);
   101→            char *ep = errBuf;
   102→            const char *prefix = "can't read \"";
   103→            while (*prefix) *ep++ = *prefix++;
   104→            for (size_t i = 0; i < nameLen; i++) *ep++ = name[i];
   105→            const char *suffix = "\": no such variable";
   106→            while (*suffix) *ep++ = *suffix++;
   107→            *ep = '\0';
   108→            tclSetError(interp, errBuf, ep - errBuf);
   109→            host->arenaPop(interp->hostCtx, arena);
   110→            return TCL_ERROR;
   111→        }
   112→        tclSetResult(interp, host->dup(value));
   113→    }
   114→
   115→    return TCL_OK;
   116→}
   117→
   118→/* ========================================================================
   119→ * string Command - Implementation in builtin_string.c
   120→ * ======================================================================== */
   121→
   122→/* tclCmdString is defined in builtin_string.c */
   123→
   124→/* ========================================================================
   125→ * expr Command - Implementation in builtin_expr.c
   126→ * ======================================================================== */
   127→
   128→/* tclCmdExpr is defined in builtin_expr.c */
   129→
   130→/* ========================================================================
   131→ * subst Command
   132→ * ======================================================================== */
   133→
   134→TclResult tclCmdSubst(TclInterp *interp, int objc, TclObj **objv) {
   135→    const TclHost *host = interp->host;
   136→
   137→    if (objc < 2) {
   138→        tclSetError(interp, "wrong # args: should be \"subst ?-nobackslashes? ?-nocommands? ?-novariables? string\"", -1);
   139→        return TCL_ERROR;
   140→    }
   141→
   142→    int flags = TCL_SUBST_ALL;
   143→    int stringIdx = 1;
   144→
   145→    /* Parse flags */
   146→    for (int i = 1; i < objc - 1; i++) {
   147→        size_t len;
   148→        const char *arg = host->getStringPtr(objv[i], &len);
   149→
   150→        if (len == 14 && tclStrncmp(arg, "-nobackslashes", 14) == 0) {
   151→            flags &= ~TCL_SUBST_BACKSLASH;
   152→            stringIdx = i + 1;
   153→        } else if (len == 11 && tclStrncmp(arg, "-nocommands", 11) == 0) {
   154→            flags &= ~TCL_SUBST_COMMANDS;
   155→            stringIdx = i + 1;
   156→        } else if (len == 12 && tclStrncmp(arg, "-novariables", 12) == 0) {
   157→            flags &= ~TCL_SUBST_VARIABLES;
   158→            stringIdx = i + 1;
   159→        }
   160→    }
   161→
   162→    /* Get the string */
   163→    size_t strLen;
   164→    const char *str = host->getStringPtr(objv[stringIdx], &strLen);
   165→
   166→    /* Perform substitution */
   167→    TclObj *result = tclSubstString(interp, str, strLen, flags);
   168→    if (!result) {
   169→        return TCL_ERROR;
   170→    }
   171→
   172→    tclSetResult(interp, result);
   173→    return TCL_OK;
   174→}
   175→
   176→/* ========================================================================
   177→ * proc Command
   178→ * ======================================================================== */
   179→
   180→TclResult tclCmdProc(TclInterp *interp, int objc, TclObj **objv) {
   181→    const TclHost *host = interp->host;
   182→
   183→    if (objc != 4) {
   184→        tclSetError(interp, "wrong # args: should be \"proc name args body\"", -1);
   185→        return TCL_ERROR;
   186→    }
   187→
   188→    size_t nameLen;
   189→    const char *name = host->getStringPtr(objv[1], &nameLen);
   190→
   191→    /* Register the procedure with the host */
   192→    void *handle = host->procRegister(interp->hostCtx, name, nameLen, objv[2], objv[3]);
   193→    if (!handle) {
   194→        tclSetError(interp, "failed to register procedure", -1);
   195→        return TCL_ERROR;
   196→    }
   197→
   198→    tclSetResult(interp, host->newString("", 0));
   199→    return TCL_OK;
   200→}
   201→
   202→/* ========================================================================
   203→ * return Command
   204→ * ======================================================================== */
   205→
   206→TclResult tclCmdReturn(TclInterp *interp, int objc, TclObj **objv) {
   207→    const TclHost *host = interp->host;
   208→
   209→    /* Default return value is empty string */
   210→    TclObj *result = host->newString("", 0);
   211→    int code = TCL_OK;
   212→    int level = 1;
   213→
   214→    /* Parse options: return ?-code code? ?-level level? ?result? */
   215→    int i = 1;
   216→    while (i < objc) {
   217→        size_t len;
   218→        const char *arg = host->getStringPtr(objv[i], &len);
   219→
   220→        if (len >= 1 && arg[0] == '-') {
   221→            if (len == 5 && tclStrncmp(arg, "-code", 5) == 0) {
   222→                if (i + 1 >= objc) {
   223→                    tclSetError(interp, "wrong # args: should be \"-code code\"", -1);
   224→                    return TCL_ERROR;
   225→                }
   226→                i++;
   227→                size_t codeLen;
   228→                const char *codeStr = host->getStringPtr(objv[i], &codeLen);
   229→
   230→                /* Parse code value */
   231→                if (codeLen == 2 && tclStrncmp(codeStr, "ok", 2) == 0) {
   232→                    code = TCL_OK;
   233→                } else if (codeLen == 5 && tclStrncmp(codeStr, "error", 5) == 0) {
   234→                    code = TCL_ERROR;
   235→                } else if (codeLen == 6 && tclStrncmp(codeStr, "return", 6) == 0) {
   236→                    code = TCL_RETURN;
   237→                } else if (codeLen == 5 && tclStrncmp(codeStr, "break", 5) == 0) {
   238→                    code = TCL_BREAK;
   239→                } else if (codeLen == 8 && tclStrncmp(codeStr, "continue", 8) == 0) {
   240→                    code = TCL_CONTINUE;
   241→                } else {
   242→                    /* Try as integer */
   243→                    int64_t val;
   244→                    if (host->asInt(objv[i], &val) == 0) {
   245→                        code = (int)val;
   246→                    } else {
   247→                        tclSetError(interp, "bad completion code", -1);
   248→                        return TCL_ERROR;
   249→                    }
   250→                }
   251→                i++;
   252→            } else if (len == 6 && tclStrncmp(arg, "-level", 6) == 0) {
   253→                if (i + 1 >= objc) {
   254→                    tclSetError(interp, "wrong # args: should be \"-level level\"", -1);
   255→                    return TCL_ERROR;
   256→                }
   257→                i++;
   258→                int64_t val;
   259→                if (host->asInt(objv[i], &val) != 0 || val < 0) {
   260→                    tclSetError(interp, "bad level", -1);
   261→                    return TCL_ERROR;
   262→                }
   263→                level = (int)val;
   264→                i++;
   265→            } else {
   266→                /* Unknown option - treat as result value */
   267→                result = objv[i];
   268→                i++;
   269→            }
   270→        } else {
   271→            /* Result value */
   272→            result = objv[i];
   273→            i++;
   274→        }
   275→    }
   276→
   277→    /* Set interpreter state for return */
   278→    interp->result = result;
   279→    interp->returnCode = code;
   280→    interp->returnLevel = level;
   281→
   282→    return TCL_RETURN;
   283→}
   284→
   285→/* ========================================================================
   286→ * Expression Boolean Evaluation Helper
   287→ * ======================================================================== */
   288→
   289→/* Evaluate expression string and return boolean result */
   290→static int evalExprBool(TclInterp *interp, const char *exprRaw, size_t lenRaw, int *result) {
   291→    const TclHost *host = interp->host;
   292→
   293→    /* First, perform variable/command substitution on the expression */
   294→    TclObj *substResult = tclSubstString(interp, exprRaw, lenRaw, TCL_SUBST_ALL);
   295→    if (!substResult) {
   296→        return -1;
   297→    }
   298→
   299→    size_t len;
   300→    const char *expr = host->getStringPtr(substResult, &len);
   301→
   302→    /* Simple expression evaluator - handles:
   303→     * - Integer literals (0 = false, non-zero = true)
   304→     * - Comparisons: ==, !=, <, >, <=, >=
   305→     * - Boolean literals: true, false, yes, no, on, off
   306→     */
   307→    const char *p = expr;
   308→    const char *end = expr + len;
   309→
   310→    /* Skip whitespace */
   311→    while (p < end && (*p == ' ' || *p == '\t')) p++;
   312→    if (p >= end) {
   313→        *result = 0;
   314→        return 0;
   315→    }
   316→
   317→    /* Check for boolean literals */
   318→    size_t remaining = end - p;
   319→    if (remaining == 4 && tclStrncmp(p, "true", 4) == 0) { *result = 1; return 0; }
   320→    if (remaining == 5 && tclStrncmp(p, "false", 5) == 0) { *result = 0; return 0; }
   321→    if (remaining == 3 && tclStrncmp(p, "yes", 3) == 0) { *result = 1; return 0; }
   322→    if (remaining == 2 && tclStrncmp(p, "no", 2) == 0) { *result = 0; return 0; }
   323→    if (remaining == 2 && tclStrncmp(p, "on", 2) == 0) { *result = 1; return 0; }
   324→    if (remaining == 3 && tclStrncmp(p, "off", 3) == 0) { *result = 0; return 0; }
   325→
   326→    /* Try to parse as simple comparison or arithmetic */
   327→    /* First, look for comparison operators */
   328→    const char *op = NULL;
   329→    int opLen = 0;
   330→    const char *scan = p;
   331→    while (scan < end) {
   332→        if (scan + 1 < end) {
   333→            if ((scan[0] == '=' && scan[1] == '=') ||
   334→                (scan[0] == '!' && scan[1] == '=') ||
   335→                (scan[0] == '<' && scan[1] == '=') ||
   336→                (scan[0] == '>' && scan[1] == '=')) {
   337→                op = scan;
   338→                opLen = 2;
   339→                break;
   340→            }
   341→        }
   342→        if (*scan == '<' || *scan == '>') {
   343→            op = scan;
   344→            opLen = 1;
   345→            break;
   346→        }
   347→        scan++;
   348→    }
   349→
   350→    if (op) {
   351→        /* Comparison expression */
   352→        /* Parse left operand */
   353→        const char *leftStart = p;
   354→        while (leftStart < op && (*leftStart == ' ' || *leftStart == '\t')) leftStart++;
   355→        const char *leftEnd = op;
   356→        while (leftEnd > leftStart && (leftEnd[-1] == ' ' || leftEnd[-1] == '\t')) leftEnd--;
   357→
   358→        /* Strip quotes from left operand */
   359→        if (leftEnd > leftStart && *leftStart == '"' && leftEnd[-1] == '"') {
   360→            leftStart++;
   361→            leftEnd--;
   362→        }
   363→
   364→        /* Parse right operand */
   365→        const char *rightStart = op + opLen;
   366→        while (rightStart < end && (*rightStart == ' ' || *rightStart == '\t')) rightStart++;
   367→        const char *rightEnd = end;
   368→        while (rightEnd > rightStart && (rightEnd[-1] == ' ' || rightEnd[-1] == '\t')) rightEnd--;
   369→
   370→        /* Strip quotes from right operand */
   371→        if (rightEnd > rightStart && *rightStart == '"' && rightEnd[-1] == '"') {
   372→            rightStart++;
   373→            rightEnd--;
   374→        }
   375→
   376→        /* Try as integers first */
   377→        int64_t leftVal = 0, rightVal = 0;
   378→        int leftIsInt = 1, rightIsInt = 1;
   379→
   380→        /* Parse left as int */
   381→        const char *lp = leftStart;
   382→        int lneg = 0;
   383→        if (lp < leftEnd && *lp == '-') { lneg = 1; lp++; }
   384→        else if (lp < leftEnd && *lp == '+') { lp++; }
   385→        if (lp < leftEnd && *lp >= '0' && *lp <= '9') {
   386→            while (lp < leftEnd && *lp >= '0' && *lp <= '9') {
   387→                leftVal = leftVal * 10 + (*lp - '0');
   388→                lp++;
   389→            }
   390→            if (lneg) leftVal = -leftVal;
   391→            /* Check for trailing non-digits */
   392→            while (lp < leftEnd && (*lp == ' ' || *lp == '\t')) lp++;
   393→            if (lp != leftEnd) leftIsInt = 0;
   394→        } else {
   395→            leftIsInt = 0;
   396→        }
   397→
   398→        /* Parse right as int */
   399→        const char *rp = rightStart;
   400→        int rneg = 0;
   401→        if (rp < rightEnd && *rp == '-') { rneg = 1; rp++; }
   402→        else if (rp < rightEnd && *rp == '+') { rp++; }
   403→        if (rp < rightEnd && *rp >= '0' && *rp <= '9') {
   404→            while (rp < rightEnd && *rp >= '0' && *rp <= '9') {
   405→                rightVal = rightVal * 10 + (*rp - '0');
   406→                rp++;
   407→            }
   408→            if (rneg) rightVal = -rightVal;
   409→            while (rp < rightEnd && (*rp == ' ' || *rp == '\t')) rp++;
   410→            if (rp != rightEnd) rightIsInt = 0;
   411→        } else {
   412→            rightIsInt = 0;
   413→        }
   414→
   415→        if (leftIsInt && rightIsInt) {
   416→            /* Integer comparison */
   417→            if (opLen == 2 && op[0] == '=' && op[1] == '=') {
   418→                *result = (leftVal == rightVal);
   419→            } else if (opLen == 2 && op[0] == '!' && op[1] == '=') {
   420→                *result = (leftVal != rightVal);
   421→            } else if (opLen == 2 && op[0] == '<' && op[1] == '=') {
   422→                *result = (leftVal <= rightVal);
   423→            } else if (opLen == 2 && op[0] == '>' && op[1] == '=') {
   424→                *result = (leftVal >= rightVal);
   425→            } else if (opLen == 1 && op[0] == '<') {
   426→                *result = (leftVal < rightVal);
   427→            } else if (opLen == 1 && op[0] == '>') {
   428→                *result = (leftVal > rightVal);
   429→            }
   430→            return 0;
   431→        } else {
   432→            /* String comparison */
   433→            size_t leftLen = leftEnd - leftStart;
   434→            size_t rightLen = rightEnd - rightStart;
   435→            int cmp = 0;
   436→            size_t minLen = leftLen < rightLen ? leftLen : rightLen;
   437→            cmp = tclStrncmp(leftStart, rightStart, minLen);
   438→            if (cmp == 0) {
   439→                if (leftLen < rightLen) cmp = -1;
   440→                else if (leftLen > rightLen) cmp = 1;
   441→            }
   442→
   443→            if (opLen == 2 && op[0] == '=' && op[1] == '=') {
   444→                *result = (cmp == 0);
   445→            } else if (opLen == 2 && op[0] == '!' && op[1] == '=') {
   446→                *result = (cmp != 0);
   447→            } else if (opLen == 2 && op[0] == '<' && op[1] == '=') {
   448→                *result = (cmp <= 0);
   449→            } else if (opLen == 2 && op[0] == '>' && op[1] == '=') {
   450→                *result = (cmp >= 0);
   451→            } else if (opLen == 1 && op[0] == '<') {
   452→                *result = (cmp < 0);
   453→            } else if (opLen == 1 && op[0] == '>') {
   454→                *result = (cmp > 0);
   455→            }
   456→            return 0;
   457→        }
   458→    }
   459→
   460→    /* Try as simple integer (non-zero = true) */
   461→    int64_t val = 0;
   462→    int neg = 0;
   463→    if (p < end && *p == '-') { neg = 1; p++; }
   464→    else if (p < end && *p == '+') { p++; }
   465→
   466→    if (p < end && *p >= '0' && *p <= '9') {
   467→        while (p < end && *p >= '0' && *p <= '9') {
   468→            val = val * 10 + (*p - '0');
   469→            p++;
   470→        }
   471→        if (neg) val = -val;
   472→        *result = (val != 0);
   473→        return 0;
   474→    }
   475→
   476→    /* Use expr command and interpret result */
   477→    TclObj *exprObj = host->newString(expr, len);
   478→    TclObj *args[2] = { host->newString("expr", 4), exprObj };
   479→    TclResult res = tclCmdExpr(interp, 2, args);
   480→    if (res != TCL_OK) {
   481→        return -1;
   482→    }
   483→
   484→    /* Check result */
   485→    int64_t intResult;
   486→    if (host->asInt(interp->result, &intResult) == 0) {
   487→        *result = (intResult != 0);
   488→        return 0;
   489→    }
   490→
   491→    /* Try as boolean */
   492→    int boolResult;
   493→    if (host->asBool(interp->result, &boolResult) == 0) {
   494→        *result = boolResult;
   495→        return 0;
   496→    }
   497→
   498→    tclSetError(interp, "expected boolean expression", -1);
   499→    return -1;
   500→}
   501→
   502→/* ========================================================================
   503→ * if Command
   504→ * ======================================================================== */
   505→
   506→TclResult tclCmdIf(TclInterp *interp, int objc, TclObj **objv) {
   507→    const TclHost *host = interp->host;
   508→
   509→    if (objc < 3) {
   510→        tclSetError(interp, "wrong # args: should be \"if expr1 ?then? body1 elseif expr2 ?then? body2 ... ?else? ?bodyN?\"", -1);
   511→        return TCL_ERROR;
   512→    }
   513→
   514→    int i = 1;
   515→    while (i < objc) {
   516→        /* Get condition expression */
   517→        size_t exprLen;
   518→        const char *exprStr = host->getStringPtr(objv[i], &exprLen);
   519→        i++;
   520→
   521→        /* Evaluate condition */
   522→        int condResult;
   523→        if (evalExprBool(interp, exprStr, exprLen, &condResult) != 0) {
   524→            return TCL_ERROR;
   525→        }
   526→
   527→        /* Skip optional "then" */
   528→        if (i < objc) {
   529→            size_t kwLen;
   530→            const char *kw = host->getStringPtr(objv[i], &kwLen);
   531→            if (kwLen == 4 && tclStrncmp(kw, "then", 4) == 0) {
   532→                i++;
   533→            }
   534→        }
   535→
   536→        if (i >= objc) {
   537→            tclSetError(interp, "wrong # args: no body after condition", -1);
   538→            return TCL_ERROR;
   539→        }
   540→
   541→        if (condResult) {
   542→            /* Execute this branch */
   543→            size_t bodyLen;
   544→            const char *bodyStr = host->getStringPtr(objv[i], &bodyLen);
   545→            return tclEvalScript(interp, bodyStr, bodyLen);
   546→        }
   547→
   548→        i++;  /* Skip body */
   549→
   550→        /* Check for elseif or else */
   551→        if (i >= objc) {
   552→            /* No more branches, return empty */
   553→            tclSetResult(interp, host->newString("", 0));
   554→            return TCL_OK;
   555→        }
   556→
   557→        size_t kwLen;
   558→        const char *kw = host->getStringPtr(objv[i], &kwLen);
   559→
   560→        if (kwLen == 6 && tclStrncmp(kw, "elseif", 6) == 0) {
   561→            i++;
   562→            continue;  /* Process next condition */
   563→        }
   564→
   565→        if (kwLen == 4 && tclStrncmp(kw, "else", 4) == 0) {
   566→            i++;
   567→            if (i >= objc) {
   568→                tclSetError(interp, "wrong # args: no body after else", -1);
   569→                return TCL_ERROR;
   570→            }
   571→            /* Execute else branch */
   572→            size_t bodyLen;
   573→            const char *bodyStr = host->getStringPtr(objv[i], &bodyLen);
   574→            return tclEvalScript(interp, bodyStr, bodyLen);
   575→        }
   576→
   577→        /* Must be else body without "else" keyword */
   578→        size_t bodyLen;
   579→        const char *bodyStr = host->getStringPtr(objv[i], &bodyLen);
   580→        return tclEvalScript(interp, bodyStr, bodyLen);
   581→    }
   582→
   583→    tclSetResult(interp, host->newString("", 0));
   584→    return TCL_OK;
   585→}
   586→
   587→/* ========================================================================
   588→ * while Command
   589→ * ======================================================================== */
   590→
   591→TclResult tclCmdWhile(TclInterp *interp, int objc, TclObj **objv) {
   592→    const TclHost *host = interp->host;
   593→
   594→    if (objc != 3) {
   595→        tclSetError(interp, "wrong # args: should be \"while test command\"", -1);
   596→        return TCL_ERROR;
   597→    }
   598→
   599→    size_t testLen, bodyLen;
   600→    const char *testStr = host->getStringPtr(objv[1], &testLen);
   601→    const char *bodyStr = host->getStringPtr(objv[2], &bodyLen);
   602→
   603→    tclSetResult(interp, host->newString("", 0));
   604→
   605→    while (1) {
   606→        /* Evaluate condition */
   607→        int condResult;
   608→        if (evalExprBool(interp, testStr, testLen, &condResult) != 0) {
   609→            return TCL_ERROR;
   610→        }
   611→
   612→        if (!condResult) {
   613→            break;
   614→        }
   615→
   616→        /* Execute body */
   617→        TclResult result = tclEvalScript(interp, bodyStr, bodyLen);
   618→
   619→        if (result == TCL_BREAK) {
   620→            break;
   621→        }
   622→        if (result == TCL_CONTINUE) {
   623→            continue;
   624→        }
   625→        if (result == TCL_ERROR || result == TCL_RETURN) {
   626→            return result;
   627→        }
   628→    }
   629→
   630→    tclSetResult(interp, host->newString("", 0));
   631→    return TCL_OK;
   632→}
   633→
   634→/* ========================================================================
   635→ * for Command
   636→ * ======================================================================== */
   637→
   638→TclResult tclCmdFor(TclInterp *interp, int objc, TclObj **objv) {
   639→    const TclHost *host = interp->host;
   640→
   641→    if (objc != 5) {
   642→        tclSetError(interp, "wrong # args: should be \"for start test next command\"", -1);
   643→        return TCL_ERROR;
   644→    }
   645→
   646→    size_t startLen, testLen, nextLen, bodyLen;
   647→    const char *startStr = host->getStringPtr(objv[1], &startLen);
   648→    const char *testStr = host->getStringPtr(objv[2], &testLen);
   649→    const char *nextStr = host->getStringPtr(objv[3], &nextLen);
   650→    const char *bodyStr = host->getStringPtr(objv[4], &bodyLen);
   651→
   652→    /* Execute initialization */
   653→    TclResult result = tclEvalScript(interp, startStr, startLen);
   654→    if (result != TCL_OK) {
   655→        return result;
   656→    }
   657→
   658→    while (1) {
   659→        /* Evaluate condition */
   660→        int condResult;
   661→        if (evalExprBool(interp, testStr, testLen, &condResult) != 0) {
   662→            return TCL_ERROR;
   663→        }
   664→
   665→        if (!condResult) {
   666→            break;
   667→        }
   668→
   669→        /* Execute body */
   670→        result = tclEvalScript(interp, bodyStr, bodyLen);
   671→
   672→        if (result == TCL_BREAK) {
   673→            break;
   674→        }
   675→        if (result == TCL_CONTINUE) {
   676→            /* Fall through to next */
   677→        } else if (result == TCL_ERROR || result == TCL_RETURN) {
   678→            return result;
   679→        }
   680→
   681→        /* Execute next */
   682→        result = tclEvalScript(interp, nextStr, nextLen);
   683→        if (result != TCL_OK && result != TCL_CONTINUE) {
   684→            return result;
   685→        }
   686→    }
   687→
   688→    tclSetResult(interp, host->newString("", 0));
   689→    return TCL_OK;
   690→}
   691→
   692→/* ========================================================================
   693→ * foreach Command
   694→ * ======================================================================== */
   695→
   696→TclResult tclCmdForeach(TclInterp *interp, int objc, TclObj **objv) {
   697→    const TclHost *host = interp->host;
   698→
   699→    if (objc != 4) {
   700→        tclSetError(interp, "wrong # args: should be \"foreach varname list body\"", -1);
   701→        return TCL_ERROR;
   702→    }
   703→
   704→    size_t varNameLen;
   705→    const char *varName = host->getStringPtr(objv[1], &varNameLen);
   706→
   707→    /* Parse list */
   708→    TclObj **elems = NULL;
   709→    size_t elemCount = 0;
   710→    if (host->asList(objv[2], &elems, &elemCount) != 0) {
   711→        tclSetError(interp, "invalid list", -1);
   712→        return TCL_ERROR;
   713→    }
   714→
   715→    size_t bodyLen;
   716→    const char *bodyStr = host->getStringPtr(objv[3], &bodyLen);
   717→
   718→    void *vars = interp->currentFrame->varsHandle;
   719→
   720→    for (size_t i = 0; i < elemCount; i++) {
   721→        /* Set loop variable */
   722→        host->varSet(vars, varName, varNameLen, host->dup(elems[i]));
   723→
   724→        /* Execute body */
   725→        TclResult result = tclEvalScript(interp, bodyStr, bodyLen);
   726→
   727→        if (result == TCL_BREAK) {
   728→            break;
   729→        }
   730→        if (result == TCL_CONTINUE) {
   731→            continue;
   732→        }
   733→        if (result == TCL_ERROR || result == TCL_RETURN) {
   734→            return result;
   735→        }
   736→    }
   737→
   738→    tclSetResult(interp, host->newString("", 0));
   739→    return TCL_OK;
   740→}
   741→
   742→/* ========================================================================
   743→ * break Command
   744→ * ======================================================================== */
   745→
   746→TclResult tclCmdBreak(TclInterp *interp, int objc, TclObj **objv) {
   747→    (void)objv;
   748→
   749→    if (objc != 1) {
   750→        tclSetError(interp, "wrong # args: should be \"break\"", -1);
   751→        return TCL_ERROR;
   752→    }
   753→
   754→    tclSetResult(interp, interp->host->newString("", 0));
   755→    return TCL_BREAK;
   756→}
   757→
   758→/* ========================================================================
   759→ * continue Command
   760→ * ======================================================================== */
   761→
   762→TclResult tclCmdContinue(TclInterp *interp, int objc, TclObj **objv) {
   763→    (void)objv;
   764→
   765→    if (objc != 1) {
   766→        tclSetError(interp, "wrong # args: should be \"continue\"", -1);
   767→        return TCL_ERROR;
   768→    }
   769→
   770→    tclSetResult(interp, interp->host->newString("", 0));
   771→    return TCL_CONTINUE;
   772→}
   773→
   774→/* ========================================================================
   775→ * incr Command
   776→ * ======================================================================== */
   777→
   778→TclResult tclCmdIncr(TclInterp *interp, int objc, TclObj **objv) {
   779→    const TclHost *host = interp->host;
   780→
   781→    if (objc < 2 || objc > 3) {
   782→        tclSetError(interp, "wrong # args: should be \"incr varName ?increment?\"", -1);
   783→        return TCL_ERROR;
   784→    }
   785→
   786→    size_t nameLen;
   787→    const char *name = host->getStringPtr(objv[1], &nameLen);
   788→    void *vars = interp->currentFrame->varsHandle;
   789→
   790→    /* Get increment value (default 1) */
   791→    int64_t increment = 1;
   792→    if (objc == 3) {
   793→        if (host->asInt(objv[2], &increment) != 0) {
   794→            tclSetError(interp, "expected integer but got non-integer value", -1);
   795→            return TCL_ERROR;
   796→        }
   797→    }
   798→
   799→    /* Get current value (or 0 if doesn't exist) */
   800→    int64_t currentVal = 0;
   801→    TclObj *current = host->varGet(vars, name, nameLen);
   802→    if (!current && interp->currentFrame != interp->globalFrame) {
   803→        current = host->varGet(interp->globalFrame->varsHandle, name, nameLen);
   804→    }
   805→
   806→    if (current) {
   807→        if (host->asInt(current, &currentVal) != 0) {
   808→            tclSetError(interp, "expected integer but got non-integer value", -1);
   809→            return TCL_ERROR;
   810→        }
   811→    }
   812→
   813→    /* Calculate new value */
   814→    int64_t newVal = currentVal + increment;
   815→
   816→    /* Store and return */
   817→    TclObj *result = host->newInt(newVal);
   818→    host->varSet(vars, name, nameLen, host->dup(result));
   819→    tclSetResult(interp, result);
   820→    return TCL_OK;
   821→}
   822→
   823→/* ========================================================================
   824→ * append Command
   825→ * ======================================================================== */
   826→
   827→TclResult tclCmdAppend(TclInterp *interp, int objc, TclObj **objv) {
   828→    const TclHost *host = interp->host;
   829→
   830→    if (objc < 2) {
   831→        tclSetError(interp, "wrong # args: should be \"append varName ?value ...?\"", -1);
   832→        return TCL_ERROR;
   833→    }
   834→
   835→    size_t nameLen;
   836→    const char *name = host->getStringPtr(objv[1], &nameLen);
   837→    void *vars = interp->currentFrame->varsHandle;
   838→
   839→    /* Get current value (or empty if doesn't exist) */
   840→    TclObj *current = host->varGet(vars, name, nameLen);
   841→    if (!current && interp->currentFrame != interp->globalFrame) {
   842→        current = host->varGet(interp->globalFrame->varsHandle, name, nameLen);
   843→    }
   844→
   845→    size_t currentLen = 0;
   846→    const char *currentStr = "";
   847→    if (current) {
   848→        currentStr = host->getStringPtr(current, &currentLen);
   849→    }
   850→
   851→    /* Calculate total length */
   852→    size_t totalLen = currentLen;
   853→    for (int i = 2; i < objc; i++) {
   854→        size_t len;
   855→        host->getStringPtr(objv[i], &len);
   856→        totalLen += len;
   857→    }
   858→
   859→    /* Build result */
   860→    void *arena = host->arenaPush(interp->hostCtx);
   861→    char *buf = host->arenaAlloc(arena, totalLen + 1, 1);
   862→    char *p = buf;
   863→
   864→    /* Copy current value */
   865→    for (size_t i = 0; i < currentLen; i++) {
   866→        *p++ = currentStr[i];
   867→    }
   868→
   869→    /* Append all values */
   870→    for (int i = 2; i < objc; i++) {
   871→        size_t len;
   872→        const char *s = host->getStringPtr(objv[i], &len);
   873→        for (size_t j = 0; j < len; j++) {
   874→            *p++ = s[j];
   875→        }
   876→    }
   877→    *p = '\0';
   878→
   879→    TclObj *result = host->newString(buf, totalLen);
   880→    host->arenaPop(interp->hostCtx, arena);
   881→
   882→    host->varSet(vars, name, nameLen, host->dup(result));
   883→    tclSetResult(interp, result);
   884→    return TCL_OK;
   885→}
   886→
   887→/* ========================================================================
   888→ * unset Command
   889→ * ======================================================================== */
   890→
   891→TclResult tclCmdUnset(TclInterp *interp, int objc, TclObj **objv) {
   892→    const TclHost *host = interp->host;
   893→
   894→    int nocomplain = 0;
   895→    int argStart = 1;
   896→
   897→    /* Parse options */
   898→    while (argStart < objc) {
   899→        size_t len;
   900→        const char *arg = host->getStringPtr(objv[argStart], &len);
   901→
   902→        if (len == 11 && tclStrncmp(arg, "-nocomplain", 11) == 0) {
   903→            nocomplain = 1;
   904→            argStart++;
   905→        } else if (len == 2 && tclStrncmp(arg, "--", 2) == 0) {
   906→            argStart++;
   907→            break;
   908→        } else {
   909→            break;
   910→        }
   911→    }
   912→
   913→    void *vars = interp->currentFrame->varsHandle;
   914→
   915→    /* Unset each variable */
   916→    for (int i = argStart; i < objc; i++) {
   917→        size_t nameLen;
   918→        const char *name = host->getStringPtr(objv[i], &nameLen);
   919→
   920→        /* Check if variable exists */
   921→        if (!host->varExists(vars, name, nameLen)) {
   922→            if (interp->currentFrame != interp->globalFrame) {
   923→                if (host->varExists(interp->globalFrame->varsHandle, name, nameLen)) {
   924→                    host->varUnset(interp->globalFrame->varsHandle, name, nameLen);
   925→                    continue;
   926→                }
   927→            }
   928→            if (!nocomplain) {
   929→                tclSetError(interp, "can't unset: no such variable", -1);
   930→                return TCL_ERROR;
   931→            }
   932→        } else {
   933→            host->varUnset(vars, name, nameLen);
   934→        }
   935→    }
   936→
   937→    tclSetResult(interp, host->newString("", 0));
   938→    return TCL_OK;
   939→}
   940→
   941→/* ========================================================================
   942→ * array Command
   943→ * ======================================================================== */
   944→
   945→TclResult tclCmdArray(TclInterp *interp, int objc, TclObj **objv) {
   946→    const TclHost *host = interp->host;
   947→
   948→    if (objc < 2) {
   949→        tclSetError(interp, "wrong # args: should be \"array subcommand arrayName ?arg ...?\"", -1);
   950→        return TCL_ERROR;
   951→    }
   952→
   953→    size_t subcmdLen;
   954→    const char *subcmd = host->getStringPtr(objv[1], &subcmdLen);
   955→
   956→    /* array exists arrayName */
   957→    if (subcmdLen == 6 && tclStrncmp(subcmd, "exists", 6) == 0) {
   958→        if (objc != 3) {
   959→            tclSetError(interp, "wrong # args: should be \"array exists arrayName\"", -1);
   960→            return TCL_ERROR;
   961→        }
   962→        size_t arrLen;
   963→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
   964→        void *vars = interp->currentFrame->varsHandle;
   965→
   966→        /* Check if any array elements exist */
   967→        size_t size = host->arraySize(vars, arrName, arrLen);
   968→        if (size == 0 && interp->currentFrame != interp->globalFrame) {
   969→            size = host->arraySize(interp->globalFrame->varsHandle, arrName, arrLen);
   970→        }
   971→
   972→        tclSetResult(interp, host->newInt(size > 0 ? 1 : 0));
   973→        return TCL_OK;
   974→    }
   975→
   976→    /* array names arrayName ?pattern? */
   977→    if (subcmdLen == 5 && tclStrncmp(subcmd, "names", 5) == 0) {
   978→        if (objc < 3 || objc > 4) {
   979→            tclSetError(interp, "wrong # args: should be \"array names arrayName ?pattern?\"", -1);
   980→            return TCL_ERROR;
   981→        }
   982→        size_t arrLen;
   983→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
   984→        const char *pattern = NULL;
   985→        if (objc == 4) {
   986→            size_t patLen;
   987→            pattern = host->getStringPtr(objv[3], &patLen);
   988→        }
   989→
   990→        void *vars = interp->currentFrame->varsHandle;
   991→        TclObj *names = host->arrayNames(vars, arrName, arrLen, pattern);
   992→        if (!names && interp->currentFrame != interp->globalFrame) {
   993→            names = host->arrayNames(interp->globalFrame->varsHandle, arrName, arrLen, pattern);
   994→        }
   995→
   996→        tclSetResult(interp, names ? names : host->newString("", 0));
   997→        return TCL_OK;
   998→    }
   999→
  1000→    /* array size arrayName */
  1001→    if (subcmdLen == 4 && tclStrncmp(subcmd, "size", 4) == 0) {
  1002→        if (objc != 3) {
  1003→            tclSetError(interp, "wrong # args: should be \"array size arrayName\"", -1);
  1004→            return TCL_ERROR;
  1005→        }
  1006→        size_t arrLen;
  1007→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
  1008→        void *vars = interp->currentFrame->varsHandle;
  1009→
  1010→        size_t size = host->arraySize(vars, arrName, arrLen);
  1011→        if (size == 0 && interp->currentFrame != interp->globalFrame) {
  1012→            size = host->arraySize(interp->globalFrame->varsHandle, arrName, arrLen);
  1013→        }
  1014→
  1015→        tclSetResult(interp, host->newInt((int64_t)size));
  1016→        return TCL_OK;
  1017→    }
  1018→
  1019→    /* array get arrayName ?pattern? */
  1020→    if (subcmdLen == 3 && tclStrncmp(subcmd, "get", 3) == 0) {
  1021→        if (objc < 3 || objc > 4) {
  1022→            tclSetError(interp, "wrong # args: should be \"array get arrayName ?pattern?\"", -1);
  1023→            return TCL_ERROR;
  1024→        }
  1025→        size_t arrLen;
  1026→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
  1027→        const char *pattern = NULL;
  1028→        if (objc == 4) {
  1029→            size_t patLen;
  1030→            pattern = host->getStringPtr(objv[3], &patLen);
  1031→        }
  1032→
  1033→        void *vars = interp->currentFrame->varsHandle;
  1034→
  1035→        /* Get array names */
  1036→        TclObj *names = host->arrayNames(vars, arrName, arrLen, pattern);
  1037→        if (!names && interp->currentFrame != interp->globalFrame) {
  1038→            vars = interp->globalFrame->varsHandle;
  1039→            names = host->arrayNames(vars, arrName, arrLen, pattern);
  1040→        }
  1041→
  1042→        if (!names) {
  1043→            tclSetResult(interp, host->newString("", 0));
  1044→            return TCL_OK;
  1045→        }
  1046→
  1047→        /* Parse names and build key-value list */
  1048→        TclObj **nameList;
  1049→        size_t nameCount;
  1050→        if (host->asList(names, &nameList, &nameCount) != 0 || nameCount == 0) {
  1051→            tclSetResult(interp, host->newString("", 0));
  1052→            return TCL_OK;
  1053→        }
  1054→
  1055→        /* Build result list with key value pairs */
  1056→        void *arena = host->arenaPush(interp->hostCtx);
  1057→        size_t resultCount = nameCount * 2;
  1058→        TclObj **resultElems = host->arenaAlloc(arena, resultCount * sizeof(TclObj*), sizeof(void*));
  1059→
  1060→        for (size_t i = 0; i < nameCount; i++) {
  1061→            size_t keyLen;
  1062→            const char *key = host->getStringPtr(nameList[i], &keyLen);
  1063→            resultElems[i * 2] = nameList[i];
  1064→            resultElems[i * 2 + 1] = host->arrayGet(vars, arrName, arrLen, key, keyLen);
  1065→        }
  1066→
  1067→        TclObj *result = host->newList(resultElems, resultCount);
  1068→        host->arenaPop(interp->hostCtx, arena);
  1069→        tclSetResult(interp, result);
  1070→        return TCL_OK;
  1071→    }
  1072→
  1073→    /* array set arrayName list */
  1074→    if (subcmdLen == 3 && tclStrncmp(subcmd, "set", 3) == 0) {
  1075→        if (objc != 4) {
  1076→            tclSetError(interp, "wrong # args: should be \"array set arrayName list\"", -1);
  1077→            return TCL_ERROR;
  1078→        }
  1079→        size_t arrLen;
  1080→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
  1081→
  1082→        /* Parse list */
  1083→        TclObj **elems;
  1084→        size_t elemCount;
  1085→        if (host->asList(objv[3], &elems, &elemCount) != 0) {
  1086→            tclSetError(interp, "list must have an even number of elements", -1);
  1087→            return TCL_ERROR;
  1088→        }
  1089→
  1090→        if (elemCount % 2 != 0) {
  1091→            tclSetError(interp, "list must have an even number of elements", -1);
  1092→            return TCL_ERROR;
  1093→        }
  1094→
  1095→        void *vars = interp->currentFrame->varsHandle;
  1096→
  1097→        /* Set each key-value pair */
  1098→        for (size_t i = 0; i < elemCount; i += 2) {
  1099→            size_t keyLen;
  1100→            const char *key = host->getStringPtr(elems[i], &keyLen);
  1101→            host->arraySet(vars, arrName, arrLen, key, keyLen, host->dup(elems[i + 1]));
  1102→        }
  1103→
  1104→        tclSetResult(interp, host->newString("", 0));
  1105→        return TCL_OK;
  1106→    }
  1107→
  1108→    /* array unset arrayName ?pattern? */
  1109→    if (subcmdLen == 5 && tclStrncmp(subcmd, "unset", 5) == 0) {
  1110→        if (objc < 3 || objc > 4) {
  1111→            tclSetError(interp, "wrong # args: should be \"array unset arrayName ?pattern?\"", -1);
  1112→            return TCL_ERROR;
  1113→        }
  1114→        size_t arrLen;
  1115→        const char *arrName = host->getStringPtr(objv[2], &arrLen);
  1116→        const char *pattern = NULL;
  1117→        if (objc == 4) {
  1118→            size_t patLen;
  1119→            pattern = host->getStringPtr(objv[3], &patLen);
  1120→        }
  1121→
  1122→        void *vars = interp->currentFrame->varsHandle;
  1123→
  1124→        if (pattern == NULL) {
  1125→            /* Unset entire array - get all names and unset each */
  1126→            TclObj *names = host->arrayNames(vars, arrName, arrLen, NULL);
  1127→            if (names) {
  1128→                TclObj **nameList;
  1129→                size_t nameCount;
  1130→                if (host->asList(names, &nameList, &nameCount) == 0) {
  1131→                    for (size_t i = 0; i < nameCount; i++) {
  1132→                        size_t keyLen;
  1133→                        const char *key = host->getStringPtr(nameList[i], &keyLen);
  1134→                        host->arrayUnset(vars, arrName, arrLen, key, keyLen);
  1135→                    }
  1136→                }
  1137→            }
  1138→        } else {
  1139→            /* Unset matching elements */
  1140→            TclObj *names = host->arrayNames(vars, arrName, arrLen, pattern);
  1141→            if (names) {
  1142→                TclObj **nameList;
  1143→                size_t nameCount;
  1144→                if (host->asList(names, &nameList, &nameCount) == 0) {
  1145→                    for (size_t i = 0; i < nameCount; i++) {
  1146→                        size_t keyLen;
  1147→                        const char *key = host->getStringPtr(nameList[i], &keyLen);
  1148→                        host->arrayUnset(vars, arrName, arrLen, key, keyLen);
  1149→                    }
  1150→                }
  1151→            }
  1152→        }
  1153→
  1154→        tclSetResult(interp, host->newString("", 0));
  1155→        return TCL_OK;
  1156→    }
  1157→
  1158→    tclSetError(interp, "unknown or ambiguous subcommand", -1);
  1159→    return TCL_ERROR;
  1160→}
  1161→
  1162→/* ========================================================================
  1163→ * info Command
  1164→ * ======================================================================== */
  1165→
  1166→TclResult tclCmdInfo(TclInterp *interp, int objc, TclObj **objv) {
  1167→    const TclHost *host = interp->host;
  1168→
  1169→    if (objc < 2) {
  1170→        tclSetError(interp, "wrong # args: should be \"info subcommand ?arg ...?\"", -1);
  1171→        return TCL_ERROR;
  1172→    }
  1173→
  1174→    size_t subcmdLen;
  1175→    const char *subcmd = host->getStringPtr(objv[1], &subcmdLen);
  1176→
  1177→    /* info exists varName */
  1178→    if (subcmdLen == 6 && tclStrncmp(subcmd, "exists", 6) == 0) {
  1179→        if (objc != 3) {
  1180→            tclSetError(interp, "wrong # args: should be \"info exists varName\"", -1);
  1181→            return TCL_ERROR;
  1182→        }
  1183→        size_t nameLen;
  1184→        const char *name = host->getStringPtr(objv[2], &nameLen);
  1185→
  1186→        /* Handle :: prefix for global variables */
  1187→        int forceGlobal = 0;
  1188→        if (nameLen >= 2 && name[0] == ':' && name[1] == ':') {
  1189→            name += 2;
  1190→            nameLen -= 2;
  1191→            forceGlobal = 1;
  1192→        }
  1193→
  1194→        void *vars = forceGlobal ? interp->globalFrame->varsHandle : interp->currentFrame->varsHandle;
  1195→
  1196→        int exists = host->varExists(vars, name, nameLen);
  1197→        if (!exists && !forceGlobal && interp->currentFrame != interp->globalFrame) {
  1198→            exists = host->varExists(interp->globalFrame->varsHandle, name, nameLen);
  1199→        }
  1200→
  1201→        tclSetResult(interp, host->newInt(exists ? 1 : 0));
  1202→        return TCL_OK;
  1203→    }
  1204→
  1205→    tclSetError(interp, "unknown or ambiguous subcommand", -1);
  1206→    return TCL_ERROR;
  1207→}
  1208→
  1209→/* ========================================================================
  1210→ * error Command
  1211→ * ======================================================================== */
  1212→
  1213→TclResult tclCmdError(TclInterp *interp, int objc, TclObj **objv) {
  1214→    const TclHost *host = interp->host;
  1215→
  1216→    if (objc < 2 || objc > 4) {
  1217→        tclSetError(interp, "wrong # args: should be \"error message ?info? ?code?\"", -1);
  1218→        return TCL_ERROR;
  1219→    }
  1220→
  1221→    /* Get the error message */
  1222→    size_t msgLen;
  1223→    const char *msg = host->getStringPtr(objv[1], &msgLen);
  1224→
  1225→    /* Set the error message */
  1226→    tclSetError(interp, msg, (int)msgLen);
  1227→
  1228→    /* Handle optional info argument (errorInfo) */
  1229→    if (objc >= 3) {
  1230→        size_t infoLen;
  1231→        const char *info = host->getStringPtr(objv[2], &infoLen);
  1232→        if (infoLen > 0) {
  1233→            /* Set errorInfo directly instead of letting it accumulate */
  1234→            interp->errorInfo = host->newString(info, infoLen);
  1235→        }
  1236→    }
  1237→
  1238→    /* Handle optional code argument (errorCode) */
  1239→    if (objc >= 4) {
  1240→        tclSetErrorCode(interp, objv[3]);
  1241→    }
  1242→
  1243→    return TCL_ERROR;
  1244→}
  1245→
  1246→/* ========================================================================
  1247→ * catch Command
  1248→ * ======================================================================== */
  1249→
  1250→TclResult tclCmdCatch(TclInterp *interp, int objc, TclObj **objv) {
  1251→    const TclHost *host = interp->host;
  1252→
  1253→    if (objc < 2 || objc > 4) {
  1254→        tclSetError(interp, "wrong # args: should be \"catch script ?resultVarName? ?optionsVarName?\"", -1);
  1255→        return TCL_ERROR;
  1256→    }
  1257→
  1258→    /* Get the script to execute */
  1259→    size_t scriptLen;
  1260→    const char *script = host->getStringPtr(objv[1], &scriptLen);
  1261→
  1262→    /* Execute the script and capture the result code */
  1263→    TclResult code = tclEvalScript(interp, script, scriptLen);
  1264→
  1265→    /* Set global errorInfo and errorCode variables after catching an error */
  1266→    if (code == TCL_ERROR) {
  1267→        void *globalVars = interp->globalFrame->varsHandle;
  1268→
  1269→        /* Set ::errorInfo */
  1270→        if (interp->errorInfo) {
  1271→            host->varSet(globalVars, "errorInfo", 9, host->dup(interp->errorInfo));
  1272→        } else if (interp->result) {
  1273→            host->varSet(globalVars, "errorInfo", 9, host->dup(interp->result));
  1274→        }
  1275→
  1276→        /* Set ::errorCode */
  1277→        if (interp->errorCode) {
  1278→            host->varSet(globalVars, "errorCode", 9, host->dup(interp->errorCode));
  1279→        } else {
  1280→            host->varSet(globalVars, "errorCode", 9, host->newString("NONE", 4));
  1281→        }
  1282→    }
  1283→
  1284→    /* Store result in variable if requested */
  1285→    if (objc >= 3) {
  1286→        size_t varLen;
  1287→        const char *varName = host->getStringPtr(objv[2], &varLen);
  1288→        void *vars = interp->currentFrame->varsHandle;
  1289→
  1290→        /* Store the result (or error message) */
  1291→        TclObj *resultValue = interp->result ? host->dup(interp->result) : host->newString("", 0);
  1292→        host->varSet(vars, varName, varLen, resultValue);
  1293→    }
  1294→
  1295→    /* Store options dict in variable if requested */
  1296→    if (objc >= 4) {
  1297→        size_t optVarLen;
  1298→        const char *optVarName = host->getStringPtr(objv[3], &optVarLen);
  1299→        void *vars = interp->currentFrame->varsHandle;
  1300→
  1301→        /* Build a simple options dict with -code and -level */
  1302→        /* For now, just store -code as a simple value */
  1303→        void *arena = host->arenaPush(interp->hostCtx);
  1304→        char buf[64];
  1305→        int len = 0;
  1306→        buf[len++] = '-'; buf[len++] = 'c'; buf[len++] = 'o'; buf[len++] = 'd'; buf[len++] = 'e';
  1307→        buf[len++] = ' ';
  1308→        if (code == TCL_OK) buf[len++] = '0';
  1309→        else if (code == TCL_ERROR) buf[len++] = '1';
  1310→        else if (code == TCL_RETURN) buf[len++] = '2';
  1311→        else if (code == TCL_BREAK) buf[len++] = '3';
  1312→        else if (code == TCL_CONTINUE) buf[len++] = '4';
  1313→        buf[len++] = ' ';
  1314→        buf[len++] = '-'; buf[len++] = 'l'; buf[len++] = 'e'; buf[len++] = 'v';
  1315→        buf[len++] = 'e'; buf[len++] = 'l'; buf[len++] = ' '; buf[len++] = '0';
  1316→
  1317→        TclObj *optValue = host->newString(buf, len);
  1318→        host->arenaPop(interp->hostCtx, arena);
  1319→        host->varSet(vars, optVarName, optVarLen, optValue);
  1320→    }
  1321→
  1322→    /* Return the code as an integer - catch always succeeds */
  1323→    tclSetResult(interp, host->newInt((int64_t)code));
  1324→    return TCL_OK;
  1325→}
  1326→
  1327→/* ========================================================================
  1328→ * throw Command
  1329→ * ======================================================================== */
  1330→
  1331→TclResult tclCmdThrow(TclInterp *interp, int objc, TclObj **objv) {
  1332→    const TclHost *host = interp->host;
  1333→
  1334→    if (objc != 3) {
  1335→        tclSetError(interp, "wrong # args: should be \"throw type message\"", -1);
  1336→        return TCL_ERROR;
  1337→    }
  1338→
  1339→    /* Set error code from type */
  1340→    tclSetErrorCode(interp, objv[1]);
  1341→
  1342→    /* Set error message */
  1343→    size_t msgLen;
  1344→    const char *msg = host->getStringPtr(objv[2], &msgLen);
  1345→    tclSetError(interp, msg, (int)msgLen);
  1346→
  1347→    return TCL_ERROR;
  1348→}
  1349→
  1350→/* ========================================================================
  1351→ * try Command
  1352→ * ======================================================================== */
  1353→
  1354→TclResult tclCmdTry(TclInterp *interp, int objc, TclObj **objv) {
  1355→    const TclHost *host = interp->host;
  1356→
  1357→    if (objc < 2) {
  1358→        tclSetError(interp, "wrong # args: should be \"try body ?handler...? ?finally script?\"", -1);
  1359→        return TCL_ERROR;
  1360→    }
  1361→
  1362→    /* Execute the body */
  1363→    size_t bodyLen;
  1364→    const char *body = host->getStringPtr(objv[1], &bodyLen);
  1365→    TclResult bodyCode = tclEvalScript(interp, body, bodyLen);
  1366→    TclObj *bodyResult = interp->result ? host->dup(interp->result) : host->newString("", 0);
  1367→
  1368→    /* Look for handlers and finally clause */
  1369→    int finallyIdx = -1;
  1370→    int handlerMatched = 0;
  1371→    TclResult handlerCode = bodyCode;
  1372→    TclObj *handlerResult = bodyResult;
  1373→
  1374→    int i = 2;
  1375→    while (i < objc) {
  1376→        size_t kwLen;
  1377→        const char *kw = host->getStringPtr(objv[i], &kwLen);
  1378→
  1379→        if (kwLen == 7 && tclStrncmp(kw, "finally", 7) == 0) {
  1380→            /* finally clause */
  1381→            if (i + 1 >= objc) {
  1382→                tclSetError(interp, "wrong # args: finally requires a script", -1);
  1383→                return TCL_ERROR;
  1384→            }
  1385→            finallyIdx = i + 1;
  1386→            break;
  1387→        }
  1388→
  1389→        if (kwLen == 2 && tclStrncmp(kw, "on", 2) == 0) {
  1390→            /* on code varList script */
  1391→            if (i + 3 >= objc) {
  1392→                tclSetError(interp, "wrong # args: on requires code varList script", -1);
  1393→                return TCL_ERROR;
  1394→            }
  1395→
  1396→            if (!handlerMatched) {
  1397→                /* Parse the code */
  1398→                size_t codeLen;
  1399→                const char *codeStr = host->getStringPtr(objv[i + 1], &codeLen);
  1400→                int targetCode = -1;
  1401→
  1402→                if (codeLen == 2 && tclStrncmp(codeStr, "ok", 2) == 0) targetCode = TCL_OK;
  1403→                else if (codeLen == 5 && tclStrncmp(codeStr, "error", 5) == 0) targetCode = TCL_ERROR;
  1404→                else if (codeLen == 6 && tclStrncmp(codeStr, "return", 6) == 0) targetCode = TCL_RETURN;
  1405→                else if (codeLen == 5 && tclStrncmp(codeStr, "break", 5) == 0) targetCode = TCL_BREAK;
  1406→                else if (codeLen == 8 && tclStrncmp(codeStr, "continue", 8) == 0) targetCode = TCL_CONTINUE;
  1407→                else {
  1408→                    /* Try as integer */
  1409→                    int64_t val;
  1410→                    if (host->asInt(objv[i + 1], &val) == 0) {
  1411→                        targetCode = (int)val;
  1412→                    }
  1413→                }
  1414→
  1415→                if (targetCode == (int)bodyCode) {
  1416→                    handlerMatched = 1;
  1417→
  1418→                    /* Bind variables from varList */
  1419→                    TclObj **varNames;
  1420→                    size_t varCount;
  1421→                    if (host->asList(objv[i + 2], &varNames, &varCount) == 0) {
  1422→                        void *vars = interp->currentFrame->varsHandle;
  1423→                        if (varCount >= 1) {
  1424→                            size_t vlen;
  1425→                            const char *vname = host->getStringPtr(varNames[0], &vlen);
  1426→                            if (vlen > 0) {
  1427→                                host->varSet(vars, vname, vlen, host->dup(bodyResult));
  1428→                            }
  1429→                        }
  1430→                        /* varCount >= 2 would be options dict - skip for now */
  1431→                    }
  1432→
  1433→                    /* Execute handler script */
  1434→                    size_t scriptLen;
  1435→                    const char *script = host->getStringPtr(objv[i + 3], &scriptLen);
  1436→                    handlerCode = tclEvalScript(interp, script, scriptLen);
  1437→                    handlerResult = interp->result ? host->dup(interp->result) : host->newString("", 0);
  1438→                }
  1439→            }
  1440→
  1441→            i += 4;
  1442→            continue;
  1443→        }
  1444→
  1445→        if (kwLen == 4 && tclStrncmp(kw, "trap", 4) == 0) {
  1446→            /* trap pattern varList script */
  1447→            if (i + 3 >= objc) {
  1448→                tclSetError(interp, "wrong # args: trap requires pattern varList script", -1);
  1449→                return TCL_ERROR;
  1450→            }
  1451→
  1452→            if (!handlerMatched && bodyCode == TCL_ERROR) {
  1453→                /* For now, just match any error with trap {} */
  1454→                size_t patLen;
  1455→                host->getStringPtr(objv[i + 1], &patLen);
  1456→
  1457→                /* Empty pattern matches any error */
  1458→                int matches = (patLen == 0);
  1459→                /* TODO: Match against errorCode prefix */
  1460→
  1461→                if (matches) {
  1462→                    handlerMatched = 1;
  1463→
  1464→                    /* Bind variables from varList */
  1465→                    TclObj **varNames;
  1466→                    size_t varCount;
  1467→                    if (host->asList(objv[i + 2], &varNames, &varCount) == 0) {
  1468→                        void *vars = interp->currentFrame->varsHandle;
  1469→                        if (varCount >= 1) {
  1470→                            size_t vlen;
  1471→                            const char *vname = host->getStringPtr(varNames[0], &vlen);
  1472→                            if (vlen > 0) {
  1473→                                host->varSet(vars, vname, vlen, host->dup(bodyResult));
  1474→                            }
  1475→                        }
  1476→                    }
  1477→
  1478→                    /* Execute handler script */
  1479→                    size_t scriptLen;
  1480→                    const char *script = host->getStringPtr(objv[i + 3], &scriptLen);
  1481→                    handlerCode = tclEvalScript(interp, script, scriptLen);
  1482→                    handlerResult = interp->result ? host->dup(interp->result) : host->newString("", 0);
  1483→                }
  1484→            }
  1485→
  1486→            i += 4;
  1487→            continue;
  1488→        }
  1489→
  1490→        /* Unknown keyword - could be finally without keyword in older syntax */
  1491→        break;
  1492→    }
  1493→
  1494→    /* Execute finally clause if present */
  1495→    if (finallyIdx >= 0) {
  1496→        size_t finallyLen;
  1497→        const char *finallyScript = host->getStringPtr(objv[finallyIdx], &finallyLen);
  1498→        TclResult finallyCode = tclEvalScript(interp, finallyScript, finallyLen);
  1499→
  1500→        /* If finally raises an error, that takes precedence */
  1501→        if (finallyCode == TCL_ERROR) {
  1502→            return TCL_ERROR;
  1503→        }
  1504→    }
  1505→
  1506→    /* Set result and return appropriate code */
  1507→    tclSetResult(interp, handlerResult);
  1508→    return handlerCode;
  1509→}
  1510→
  1511→/* ========================================================================
  1512→ * list Command
  1513→ * ======================================================================== */
  1514→
  1515→TclResult tclCmdList(TclInterp *interp, int objc, TclObj **objv) {
  1516→    const TclHost *host = interp->host;
  1517→
  1518→    /* Create a list from all arguments (skip command name) */
  1519→    if (objc <= 1) {
  1520→        /* Empty list */
  1521→        tclSetResult(interp, host->newString("", 0));
  1522→    } else {
  1523→        TclObj *result = host->newList(objv + 1, objc - 1);
  1524→        tclSetResult(interp, result);
  1525→    }
  1526→
  1527→    return TCL_OK;
  1528→}
  1529→
  1530→/* ========================================================================
  1531→ * llength Command
  1532→ * ======================================================================== */
  1533→
  1534→TclResult tclCmdLlength(TclInterp *interp, int objc, TclObj **objv) {
  1535→    const TclHost *host = interp->host;
  1536→
  1537→    if (objc != 2) {
  1538→        tclSetError(interp, "wrong # args: should be \"llength list\"", -1);
  1539→        return TCL_ERROR;
  1540→    }
  1541→
  1542→    size_t len = host->listLength(objv[1]);
  1543→    tclSetResult(interp, host->newInt((int64_t)len));
  1544→    return TCL_OK;
  1545→}
  1546→
  1547→/* ========================================================================
  1548→ * lindex Command
  1549→ * ======================================================================== */
  1550→
  1551→/* Parse an index value (supports "end", "end-N", and integers) */
  1552→static int parseListIndex(const TclHost *host, TclObj *indexObj, size_t listLen, size_t *out) {
  1553→    size_t idxLen;
  1554→    const char *idxStr = host->getStringPtr(indexObj, &idxLen);
  1555→
  1556→    /* Check for "end" */
  1557→    if (idxLen >= 3 && tclStrncmp(idxStr, "end", 3) == 0) {
  1558→        if (listLen == 0) {
  1559→            *out = 0;
  1560→            return -1;  /* Out of bounds */
  1561→        }
  1562→        if (idxLen == 3) {
  1563→            *out = listLen - 1;
  1564→            return 0;
  1565→        }
  1566→        /* end-N or end+N */
  1567→        if (idxLen > 4 && idxStr[3] == '-') {
  1568→            int64_t offset = 0;
  1569→            for (size_t i = 4; i < idxLen; i++) {
  1570→                if (idxStr[i] >= '0' && idxStr[i] <= '9') {
  1571→                    offset = offset * 10 + (idxStr[i] - '0');
  1572→                } else {
  1573→                    return -1;
  1574→                }
  1575→            }
  1576→            if (offset > (int64_t)(listLen - 1)) {
  1577→                *out = 0;
  1578→                return -1;
  1579→            }
  1580→            *out = listLen - 1 - (size_t)offset;
  1581→            return 0;
  1582→        }
  1583→        return -1;
  1584→    }
  1585→
  1586→    /* Try as integer */
  1587→    int64_t idx;
  1588→    if (host->asInt(indexObj, &idx) != 0) {
  1589→        return -1;
  1590→    }
  1591→
  1592→    if (idx < 0 || (size_t)idx >= listLen) {
  1593→        *out = 0;
  1594→        return -1;  /* Out of bounds */
  1595→    }
  1596→
  1597→    *out = (size_t)idx;
  1598→    return 0;
  1599→}
  1600→
  1601→/* Helper to apply a single index to current value */
  1602→static TclObj *applyIndex(const TclHost *host, TclObj *current, TclObj *indexObj) {
  1603→    size_t idxStrLen;
  1604→    host->getStringPtr(indexObj, &idxStrLen);
  1605→    if (idxStrLen == 0) {
  1606→        return current;  /* Empty index, return as-is */
  1607→    }
  1608→
  1609→    size_t listLen = host->listLength(current);
  1610→    size_t idx;
  1611→
  1612→    if (parseListIndex(host, indexObj, listLen, &idx) != 0) {
  1613→        return NULL;  /* Out of bounds or invalid */
  1614→    }
  1615→
  1616→    return host->listIndex(current, idx);
  1617→}
  1618→
  1619→TclResult tclCmdLindex(TclInterp *interp, int objc, TclObj **objv) {
  1620→    const TclHost *host = interp->host;
  1621→
  1622→    if (objc < 2) {
  1623→        tclSetError(interp, "wrong # args: should be \"lindex list ?index ...?\"", -1);
  1624→        return TCL_ERROR;
  1625→    }
  1626→
  1627→    /* If no index, return the list itself */
  1628→    if (objc == 2) {
  1629→        tclSetResult(interp, host->dup(objv[1]));
  1630→        return TCL_OK;
  1631→    }
  1632→
  1633→    /* Start with the list */
  1634→    TclObj *current = objv[1];
  1635→
  1636→    /* Process each index argument */
  1637→    for (int i = 2; i < objc; i++) {
  1638→        size_t idxStrLen;
  1639→        host->getStringPtr(objv[i], &idxStrLen);
  1640→
  1641→        /* Empty index - return current value */
  1642→        if (idxStrLen == 0) {
  1643→            continue;
  1644→        }
  1645→
  1646→        /* Check if this index argument is itself a list of indices */
  1647→        TclObj **idxElems;
  1648→        size_t idxCount;
  1649→        if (host->asList(objv[i], &idxElems, &idxCount) == 0 && idxCount > 1) {
  1650→            /* It's a list of indices - apply each one */
  1651→            for (size_t j = 0; j < idxCount; j++) {
  1652→                current = applyIndex(host, current, idxElems[j]);
  1653→                if (!current) {
  1654→                    tclSetResult(interp, host->newString("", 0));
  1655→                    return TCL_OK;
  1656→                }
  1657→            }
  1658→        } else {
  1659→            /* Single index */
  1660→            current = applyIndex(host, current, objv[i]);
  1661→            if (!current) {
  1662→                tclSetResult(interp, host->newString("", 0));
  1663→                return TCL_OK;
  1664→            }
  1665→        }
  1666→    }
  1667→
  1668→    tclSetResult(interp, host->dup(current));
  1669→    return TCL_OK;
  1670→}
  1671→
  1672→/* ========================================================================
  1673→ * lrange Command
  1674→ * ======================================================================== */
  1675→
  1676→TclResult tclCmdLrange(TclInterp *interp, int objc, TclObj **objv) {
  1677→    const TclHost *host = interp->host;
  1678→
  1679→    if (objc != 4) {
  1680→        tclSetError(interp, "wrong # args: should be \"lrange list first last\"", -1);
  1681→        return TCL_ERROR;
  1682→    }
  1683→
  1684→    size_t listLen = host->listLength(objv[1]);
  1685→
  1686→    /* Parse first index */
  1687→    size_t first = 0;
  1688→    if (parseListIndex(host, objv[2], listLen, &first) != 0) {
  1689→        /* Check if it's negative - treat as 0 */
  1690→        int64_t val;
  1691→        if (host->asInt(objv[2], &val) == 0 && val < 0) {
  1692→            first = 0;
  1693→        } else {
  1694→            /* Check for end-N that went negative */
  1695→            size_t idxLen;
  1696→            const char *idxStr = host->getStringPtr(objv[2], &idxLen);
  1697→            if (idxLen >= 5 && tclStrncmp(idxStr, "end-", 4) == 0) {
  1698→                first = 0;  /* end-N that goes negative -> treat as 0 for first */
  1699→            } else if (listLen == 0) {
  1700→                tclSetResult(interp, host->newString("", 0));
  1701→                return TCL_OK;
  1702→            }
  1703→        }
  1704→    }
  1705→
  1706→    /* Parse last index */
  1707→    size_t last = listLen > 0 ? listLen - 1 : 0;
  1708→    int lastNegative = 0;
  1709→    if (parseListIndex(host, objv[3], listLen, &last) != 0) {
  1710→        /* Check if it's past end - treat as end */
  1711→        int64_t val;
  1712→        if (host->asInt(objv[3], &val) == 0) {
  1713→            if (val >= (int64_t)listLen) {
  1714→                last = listLen > 0 ? listLen - 1 : 0;
  1715→            } else if (val < 0) {
  1716→                lastNegative = 1;
  1717→            }
  1718→        } else {
  1719→            /* Check for end-N that went negative */
  1720→            size_t idxLen;
  1721→            const char *idxStr = host->getStringPtr(objv[3], &idxLen);
  1722→            if (idxLen >= 5 && tclStrncmp(idxStr, "end-", 4) == 0) {
  1723→                lastNegative = 1;  /* end-N that goes negative for last */
  1724→            }
  1725→        }
  1726→    }
  1727→
  1728→    /* If last is negative or first > last, return empty */
  1729→    if (lastNegative || first > last || listLen == 0) {
  1730→        tclSetResult(interp, host->newString("", 0));
  1731→        return TCL_OK;
  1732→    }
  1733→
  1734→    /* Use host's listRange */
  1735→    TclObj *result = host->listRange(objv[1], first, last);
  1736→    tclSetResult(interp, result);
  1737→    return TCL_OK;
  1738→}
  1739→
  1740→/* ========================================================================
  1741→ * lappend Command
  1742→ * ======================================================================== */
  1743→
  1744→TclResult tclCmdLappend(TclInterp *interp, int objc, TclObj **objv) {
  1745→    const TclHost *host = interp->host;
  1746→
  1747→    if (objc < 2) {
  1748→        tclSetError(interp, "wrong # args: should be \"lappend varName ?value ...?\"", -1);
  1749→        return TCL_ERROR;
  1750→    }
  1751→
  1752→    /* Get variable name */
  1753→    size_t varLen;
  1754→    const char *varName = host->getStringPtr(objv[1], &varLen);
  1755→    void *vars = interp->currentFrame->varsHandle;
  1756→
  1757→    /* Get current value or empty list */
  1758→    TclObj *current = host->varGet(vars, varName, varLen);
  1759→    if (!current) {
  1760→        current = host->newString("", 0);
  1761→        /* If variable doesn't exist, create it */
  1762→        host->varSet(vars, varName, varLen, host->dup(current));
  1763→    }
  1764→
  1765→    /* If no values to append, just return current value */
  1766→    if (objc == 2) {
  1767→        tclSetResult(interp, host->dup(current));
  1768→        return TCL_OK;
  1769→    }
  1770→
  1771→    /* Append each value */
  1772→    TclObj *result = current;
  1773→    for (int i = 2; i < objc; i++) {
  1774→        result = host->listAppend(result, objv[i]);
  1775→    }
  1776→
  1777→    /* Set the variable */
  1778→    host->varSet(vars, varName, varLen, result);
  1779→
  1780→    tclSetResult(interp, host->dup(result));
  1781→    return TCL_OK;
  1782→}
  1783→
  1784→/* ========================================================================
  1785→ * join Command
  1786→ * ======================================================================== */
  1787→
  1788→TclResult tclCmdJoin(TclInterp *interp, int objc, TclObj **objv) {
  1789→    const TclHost *host = interp->host;
  1790→
  1791→    if (objc < 2 || objc > 3) {
  1792→        tclSetError(interp, "wrong # args: should be \"join list ?joinString?\"", -1);
  1793→        return TCL_ERROR;
  1794→    }
  1795→
  1796→    /* Get join string (default is space) */
  1797→    const char *joinStr = " ";
  1798→    size_t joinLen = 1;
  1799→    if (objc == 3) {
  1800→        joinStr = host->getStringPtr(objv[2], &joinLen);
  1801→    }
  1802→
  1803→    /* Parse list */
  1804→    TclObj **elems;
  1805→    size_t elemCount;
  1806→    if (host->asList(objv[1], &elems, &elemCount) != 0) {
  1807→        tclSetError(interp, "invalid list", -1);
  1808→        return TCL_ERROR;
  1809→    }
  1810→
  1811→    /* Empty list returns empty string */
  1812→    if (elemCount == 0) {
  1813→        tclSetResult(interp, host->newString("", 0));
  1814→        return TCL_OK;
  1815→    }
  1816→
  1817→    /* Calculate total length */
  1818→    size_t totalLen = 0;
  1819→    for (size_t i = 0; i < elemCount; i++) {
  1820→        size_t len;
  1821→        host->getStringPtr(elems[i], &len);
  1822→        totalLen += len;
  1823→        if (i > 0) totalLen += joinLen;
  1824→    }
  1825→
  1826→    /* Build result using arena */
  1827→    void *arena = host->arenaPush(interp->hostCtx);
  1828→    char *buf = host->arenaAlloc(arena, totalLen + 1, 1);
  1829→    char *p = buf;
  1830→
  1831→    for (size_t i = 0; i < elemCount; i++) {
  1832→        if (i > 0) {
  1833→            for (size_t j = 0; j < joinLen; j++) {
  1834→                *p++ = joinStr[j];
  1835→            }
  1836→        }
  1837→        size_t len;
  1838→        const char *s = host->getStringPtr(elems[i], &len);
  1839→        for (size_t j = 0; j < len; j++) {
  1840→            *p++ = s[j];
  1841→        }
  1842→    }
  1843→    *p = '\0';
  1844→
  1845→    TclObj *result = host->newString(buf, totalLen);
  1846→    host->arenaPop(interp->hostCtx, arena);
  1847→    tclSetResult(interp, result);
  1848→    return TCL_OK;
  1849→}
  1850→
  1851→/* ========================================================================
  1852→ * split Command
  1853→ * ======================================================================== */
  1854→
  1855→TclResult tclCmdSplit(TclInterp *interp, int objc, TclObj **objv) {
  1856→    const TclHost *host = interp->host;
  1857→
  1858→    if (objc < 2 || objc > 3) {
  1859→        tclSetError(interp, "wrong # args: should be \"split string ?splitChars?\"", -1);
  1860→        return TCL_ERROR;
  1861→    }
  1862→
  1863→    /* Get string to split */
  1864→    size_t strLen;
  1865→    const char *str = host->getStringPtr(objv[1], &strLen);
  1866→
  1867→    /* Get split characters (default is whitespace) */
  1868→    const char *splitChars = " \t\n\r";
  1869→    size_t splitLen = 4;
  1870→    if (objc == 3) {
  1871→        splitChars = host->getStringPtr(objv[2], &splitLen);
  1872→    }
  1873→
  1874→    /* Empty string returns empty list */
  1875→    if (strLen == 0) {
  1876→        tclSetResult(interp, host->newString("", 0));
  1877→        return TCL_OK;
  1878→    }
  1879→
  1880→    /* If splitChars is empty, split into individual characters */
  1881→    if (splitLen == 0) {
  1882→        void *arena = host->arenaPush(interp->hostCtx);
  1883→        TclObj **elems = host->arenaAlloc(arena, strLen * sizeof(TclObj*), sizeof(void*));
  1884→        for (size_t i = 0; i < strLen; i++) {
  1885→            elems[i] = host->newString(&str[i], 1);
  1886→        }
  1887→        TclObj *result = host->newList(elems, strLen);
  1888→        host->arenaPop(interp->hostCtx, arena);
  1889→        tclSetResult(interp, result);
  1890→        return TCL_OK;
  1891→    }
  1892→
  1893→    /* Count elements first */
  1894→    size_t maxElems = strLen + 1;  /* Maximum possible elements */
  1895→    void *arena = host->arenaPush(interp->hostCtx);
  1896→    TclObj **elems = host->arenaAlloc(arena, maxElems * sizeof(TclObj*), sizeof(void*));
  1897→    size_t elemCount = 0;
  1898→
  1899→    /* Helper to check if char is a split char */
  1900→    const char *start = str;
  1901→    const char *end = str + strLen;
  1902→    const char *p = str;
  1903→
  1904→    while (p <= end) {
  1905→        int isSplit = 0;
  1906→        if (p < end) {
  1907→            for (size_t i = 0; i < splitLen; i++) {
  1908→                if (*p == splitChars[i]) {
  1909→                    isSplit = 1;
  1910→                    break;
  1911→                }
  1912→            }
  1913→        }
  1914→
  1915→        if (isSplit || p == end) {
  1916→            /* Add element from start to p */
  1917→            elems[elemCount++] = host->newString(start, p - start);
  1918→            start = p + 1;
  1919→        }
  1920→        p++;
  1921→    }
  1922→
  1923→    TclObj *result = host->newList(elems, elemCount);
  1924→    host->arenaPop(interp->hostCtx, arena);
  1925→    tclSetResult(interp, result);
  1926→    return TCL_OK;
  1927→}
  1928→
  1929→/* ========================================================================
  1930→ * lsort Command
  1931→ * ======================================================================== */
  1932→
  1933→TclResult tclCmdLsort(TclInterp *interp, int objc, TclObj **objv) {
  1934→    const TclHost *host = interp->host;
  1935→
  1936→    if (objc < 2) {
  1937→        tclSetError(interp, "wrong # args: should be \"lsort ?options? list\"", -1);
  1938→        return TCL_ERROR;
  1939→    }
  1940→
  1941→    /* Parse options */
  1942→    /* flags: 1=decreasing, 2=integer, 4=nocase, 8=unique, 16=dictionary, 32=real */
  1943→    int flags = 0;
  1944→    int listIdx = objc - 1;  /* List is last argument */
  1945→
  1946→    for (int i = 1; i < objc - 1; i++) {
  1947→        size_t optLen;
  1948→        const char *opt = host->getStringPtr(objv[i], &optLen);
  1949→
  1950→        if (optLen > 0 && opt[0] == '-') {
  1951→            if (optLen == 11 && tclStrncmp(opt, "-decreasing", 11) == 0) {
  1952→                flags |= 1;
  1953→            } else if (optLen == 11 && tclStrncmp(opt, "-increasing", 11) == 0) {
  1954→                flags &= ~1;
  1955→            } else if (optLen == 8 && tclStrncmp(opt, "-integer", 8) == 0) {
  1956→                flags |= 2;
  1957→                flags &= ~(16 | 32);  /* Clear dictionary and real */
  1958→            } else if (optLen == 6 && tclStrncmp(opt, "-ascii", 6) == 0) {
  1959→                flags &= ~(2 | 16 | 32);  /* Clear integer, dictionary, real */
  1960→            } else if (optLen == 7 && tclStrncmp(opt, "-nocase", 7) == 0) {
  1961→                flags |= 4;
  1962→            } else if (optLen == 7 && tclStrncmp(opt, "-unique", 7) == 0) {
  1963→                flags |= 8;
  1964→            } else if (optLen == 11 && tclStrncmp(opt, "-dictionary", 11) == 0) {
  1965→                flags |= 16;
  1966→                flags &= ~(2 | 32);  /* Clear integer and real */
  1967→            } else if (optLen == 5 && tclStrncmp(opt, "-real", 5) == 0) {
  1968→                flags |= 32;
  1969→                flags &= ~(2 | 16);  /* Clear integer and dictionary */
  1970→            }
  1971→        }
  1972→    }
  1973→
  1974→    TclObj *result = host->listSort(objv[listIdx], flags);
  1975→    tclSetResult(interp, result);
  1976→    return TCL_OK;
  1977→}
  1978→
  1979→/* ========================================================================
  1980→ * Builtin Table
  1981→ * ======================================================================== */
  1982→
  1983→/* Sorted alphabetically for binary search */
  1984→static const TclBuiltinEntry builtinTable[] = {
  1985→    {"append",   tclCmdAppend},
  1986→    {"array",    tclCmdArray},
  1987→    {"break",    tclCmdBreak},
  1988→    {"catch",    tclCmdCatch},
  1989→    {"continue", tclCmdContinue},
  1990→    {"error",    tclCmdError},
  1991→    {"expr",     tclCmdExpr},
  1992→    {"for",      tclCmdFor},
  1993→    {"foreach",  tclCmdForeach},
  1994→    {"global",   tclCmdGlobal},
  1995→    {"if",       tclCmdIf},
  1996→    {"incr",     tclCmdIncr},
  1997→    {"info",     tclCmdInfo},
  1998→    {"join",     tclCmdJoin},
  1999→    {"lappend",  tclCmdLappend},
  2000→    {"lindex",   tclCmdLindex},
  2001→    {"list",     tclCmdList},
  2002→    {"llength",  tclCmdLlength},
  2003→    {"lrange",   tclCmdLrange},
  2004→    {"lsort",    tclCmdLsort},
  2005→    {"proc",     tclCmdProc},
  2006→    {"puts",     tclCmdPuts},
  2007→    {"return",   tclCmdReturn},
  2008→    {"set",      tclCmdSet},
  2009→    {"split",    tclCmdSplit},
  2010→    {"string",   tclCmdString},
  2011→    {"subst",    tclCmdSubst},
  2012→    {"throw",    tclCmdThrow},
  2013→    {"try",      tclCmdTry},
  2014→    {"unset",    tclCmdUnset},
  2015→    {"uplevel",  tclCmdUplevel},
  2016→    {"upvar",    tclCmdUpvar},
  2017→    {"while",    tclCmdWhile},
  2018→};
  2019→
  2020→static const int builtinCount = sizeof(builtinTable) / sizeof(builtinTable[0]);
  2021→
  2022→/* Binary search for builtin command */
  2023→int tclBuiltinLookup(const char *name, size_t len) {
  2024→    int lo = 0;
  2025→    int hi = builtinCount - 1;
  2026→
  2027→    while (lo <= hi) {
  2028→        int mid = (lo + hi) / 2;
  2029→        const char *midName = builtinTable[mid].name;
  2030→        size_t midLen = tclStrlen(midName);
  2031→
  2032→        /* Compare */
  2033→        int cmp;
  2034→        size_t minLen = len < midLen ? len : midLen;
  2035→        cmp = tclStrncmp(name, midName, minLen);
  2036→        if (cmp == 0) {
  2037→            if (len < midLen) cmp = -1;
  2038→            else if (len > midLen) cmp = 1;
  2039→        }
  2040→
  2041→        if (cmp < 0) {
  2042→            hi = mid - 1;
  2043→        } else if (cmp > 0) {
  2044→            lo = mid + 1;
  2045→        } else {
  2046→            return mid;
  2047→        }
  2048→    }
  2049→
  2050→    return -1;  /* Not found */
  2051→}
  2052→
  2053→const TclBuiltinEntry *tclBuiltinGet(int index) {
  2054→    if (index < 0 || index >= builtinCount) {
  2055→        return NULL;
  2056→    }
  2057→    return &builtinTable[index];
  2058→}
  2059→
  2060→int tclBuiltinCount(void) {
  2061→    return builtinCount;
  2062→}
  2063→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
