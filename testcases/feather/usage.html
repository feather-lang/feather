<test-suite>
  <!--
    Usage Command Tests (feather-specific)

    Tests for the 'usage' command implementing CLI argument parsing
    based on the usage specification from https://usage.jdx.dev

    Uses ?arg? instead of [arg] for optional arguments (TCL compatibility).
  -->

  <!-- ============================================= -->
  <!-- Basic subcommand errors                       -->
  <!-- ============================================= -->

  <test-case name="usage with no subcommand errors">
    <script>usage</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage subcommand ?arg ...?"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage with unknown subcommand errors">
    <script>usage foo</script>
    <return>TCL_ERROR</return>
    <error>unknown subcommand "foo": must be for, help, or parse</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage for - defining specs                    -->
  <!-- ============================================= -->

  <test-case name="usage for with no args errors">
    <script>usage for</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage for command ?spec?"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage for with too many args errors">
    <script>usage for cmd spec extra</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage for command ?spec?"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage for defines a spec">
    <script>usage for testcmd {arg "<input>"}
string match {arg "<input>"} [usage for testcmd]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage for without spec retrieves existing">
    <script>usage for testcmd2 {arg "<file>" arg "?output?"}
string match {arg "<file>" arg "?output?"} [usage for testcmd2]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage for undefined command errors">
    <script>usage for nonexistent</script>
    <return>TCL_ERROR</return>
    <error>no usage defined for "nonexistent"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - basic argument parsing          -->
  <!-- ============================================= -->

  <test-case name="usage parse with wrong args errors">
    <script>usage parse</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage parse command args"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse with one arg errors">
    <script>usage parse cmd</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage parse command args"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse undefined command errors">
    <script>usage parse undefined {}</script>
    <return>TCL_ERROR</return>
    <error>no usage defined for "undefined"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse required arg">
    <script>usage for mycmd1 {arg "<input>"}
proc test1 {args} {
    usage parse mycmd1 $args
    return $input
}
test1 hello.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>hello.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse missing required arg errors">
    <script>usage for mycmd2 {arg "<input>"}
proc test2 {args} {
    usage parse mycmd2 $args
    return $input
}
test2</script>
    <return>TCL_ERROR</return>
    <error>missing required argument "input"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse optional arg with value">
    <script>usage for mycmd3 {arg "?output?"}
proc test3 {args} {
    usage parse mycmd3 $args
    return $output
}
test3 result.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>result.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse optional arg without value">
    <script>usage for mycmd4 {arg "?output?"}
proc test4 {args} {
    usage parse mycmd4 $args
    return "got:$output"
}
test4</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>got:</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse multiple positional args">
    <script>usage for mycmd5 {arg "<src>" arg "<dst>"}
proc test5 {args} {
    usage parse mycmd5 $args
    return "$src -> $dst"
}
test5 input.txt output.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>input.txt -> output.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse mixed required and optional">
    <script>usage for mycmd6 {arg "<input>" arg "?output?"}
proc test6 {args} {
    usage parse mycmd6 $args
    return "$input|$output"
}
test6 in.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>in.txt|</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse mixed with both provided">
    <script>usage for mycmd7 {arg "<input>" arg "?output?"}
proc test7 {args} {
    usage parse mycmd7 $args
    return "$input|$output"
}
test7 in.txt out.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>in.txt|out.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - default values                  -->
  <!-- ============================================= -->

  <test-case name="usage parse optional arg with default">
    <script>usage for defcmd1 {arg "?output?" default="default.txt"}
proc deftest1 {args} {
    usage parse defcmd1 $args
    return $output
}
deftest1</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>default.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse override default with value">
    <script>usage for defcmd2 {arg "?output?" default="default.txt"}
proc deftest2 {args} {
    usage parse defcmd2 $args
    return $output
}
deftest2 custom.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>custom.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - boolean flags                   -->
  <!-- ============================================= -->

  <test-case name="usage parse short flag">
    <script>usage for flagcmd1 {flag "-v"}
proc flagtest1 {args} {
    usage parse flagcmd1 $args
    return $v
}
flagtest1 -v</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse short flag not provided">
    <script>usage for flagcmd2 {flag "-v"}
proc flagtest2 {args} {
    usage parse flagcmd2 $args
    return $v
}
flagtest2</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse long flag">
    <script>usage for flagcmd3 {flag "--verbose"}
proc flagtest3 {args} {
    usage parse flagcmd3 $args
    return $verbose
}
flagtest3 --verbose</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse long flag not provided">
    <script>usage for flagcmd4 {flag "--verbose"}
proc flagtest4 {args} {
    usage parse flagcmd4 $args
    return $verbose
}
flagtest4</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse short and long flag - use short">
    <script>usage for flagcmd5 {flag "-v --verbose"}
proc flagtest5 {args} {
    usage parse flagcmd5 $args
    return $verbose
}
flagtest5 -v</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse short and long flag - use long">
    <script>usage for flagcmd6 {flag "-v --verbose"}
proc flagtest6 {args} {
    usage parse flagcmd6 $args
    return $verbose
}
flagtest6 --verbose</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse multiple flags">
    <script>usage for flagcmd7 {flag "-v --verbose" flag "-q --quiet"}
proc flagtest7 {args} {
    usage parse flagcmd7 $args
    return "$verbose|$quiet"
}
flagtest7 -v -q</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse some flags">
    <script>usage for flagcmd8 {flag "-v --verbose" flag "-q --quiet" flag "-d --debug"}
proc flagtest8 {args} {
    usage parse flagcmd8 $args
    return "$verbose|$quiet|$debug"
}
flagtest8 --debug</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>0|0|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - flags with values               -->
  <!-- ============================================= -->

  <test-case name="usage parse flag with required value">
    <script>usage for valflag1 {flag "-n --count <num>"}
proc valtest1 {args} {
    usage parse valflag1 $args
    return $count
}
valtest1 -n 5</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>5</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flag with value using long form">
    <script>usage for valflag2 {flag "-n --count <num>"}
proc valtest2 {args} {
    usage parse valflag2 $args
    return $count
}
valtest2 --count 10</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>10</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flag with value using equals">
    <script>usage for valflag3 {flag "--count <num>"}
proc valtest3 {args} {
    usage parse valflag3 $args
    return $count
}
valtest3 --count=42</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>42</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flag with value not provided">
    <script>usage for valflag4 {flag "-n --count <num>"}
proc valtest4 {args} {
    usage parse valflag4 $args
    return "count:$count"
}
valtest4</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>count:</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flag missing required value errors">
    <script>usage for valflag5 {flag "-n --count <num>"}
proc valtest5 {args} {
    usage parse valflag5 $args
    return $count
}
valtest5 -n</script>
    <return>TCL_ERROR</return>
    <error>flag -n requires a value</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse long flag missing required value errors">
    <script>usage for valflag6 {flag "--count <num>"}
proc valtest6 {args} {
    usage parse valflag6 $args
    return $count
}
valtest6 --count</script>
    <return>TCL_ERROR</return>
    <error>flag --count requires a value</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - mixed args and flags            -->
  <!-- ============================================= -->

  <test-case name="usage parse args and flags mixed">
    <script>usage for mixcmd1 {arg "<input>" flag "-v --verbose" arg "?output?"}
proc mixtest1 {args} {
    usage parse mixcmd1 $args
    return "$input|$verbose|$output"
}
mixtest1 -v input.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>input.txt|1|</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flags between args">
    <script>usage for mixcmd2 {arg "<src>" arg "<dst>" flag "-f --force"}
proc mixtest2 {args} {
    usage parse mixcmd2 $args
    return "$src|$dst|$force"
}
mixtest2 a.txt -f b.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>a.txt|b.txt|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flags with values and args">
    <script>usage for mixcmd3 {arg "<file>" flag "-n --count <num>" flag "-v"}
proc mixtest3 {args} {
    usage parse mixcmd3 $args
    return "$file|$count|$v"
}
mixtest3 data.txt -n 3 -v</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>data.txt|3|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - double dash                     -->
  <!-- ============================================= -->

  <test-case name="usage parse double dash ends flag parsing">
    <script>usage for ddcmd1 {arg "<file>" flag "-v"}
proc ddtest1 {args} {
    usage parse ddcmd1 $args
    return "$file|$v"
}
ddtest1 -- -v</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>-v|0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse double dash with flags before">
    <script>usage for ddcmd2 {arg "<file>" flag "-v"}
proc ddtest2 {args} {
    usage parse ddcmd2 $args
    return "$file|$v"
}
ddtest2 -v -- --not-a-flag</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>--not-a-flag|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - unknown flag errors             -->
  <!-- ============================================= -->

  <test-case name="usage parse unknown short flag errors">
    <script>usage for unkcmd1 {flag "-v"}
proc unktest1 {args} {
    usage parse unkcmd1 $args
}
unktest1 -x</script>
    <return>TCL_ERROR</return>
    <error>unknown flag "-x"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse unknown long flag errors">
    <script>usage for unkcmd2 {flag "--verbose"}
proc unktest2 {args} {
    usage parse unkcmd2 $args
}
unktest2 --unknown</script>
    <return>TCL_ERROR</return>
    <error>unknown flag "--unknown"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - variadic arguments              -->
  <!-- ============================================= -->

  <test-case name="usage parse variadic required arg">
    <script>usage for varcmd1 {arg "<files>..."}
proc vartest1 {args} {
    usage parse varcmd1 $args
    return $files
}
vartest1 a.txt b.txt c.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>a.txt b.txt c.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse variadic optional arg">
    <script>usage for varcmd2 {arg "?files?..."}
proc vartest2 {args} {
    usage parse varcmd2 $args
    return "count:[llength $files]"
}
vartest2</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>count:0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse variadic optional arg with values">
    <script>usage for varcmd3 {arg "?files?..."}
proc vartest3 {args} {
    usage parse varcmd3 $args
    return $files
}
vartest3 x.txt y.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>x.txt y.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse required arg then variadic">
    <script>usage for varcmd4 {arg "<output>" arg "?inputs?..."}
proc vartest4 {args} {
    usage parse varcmd4 $args
    return "$output|$inputs"
}
vartest4 out.txt a.txt b.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>out.txt|a.txt b.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse variadic with flags">
    <script>usage for varcmd5 {flag "-v" arg "<files>..."}
proc vartest5 {args} {
    usage parse varcmd5 $args
    return "$v|$files"
}
vartest5 -v one.txt two.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1|one.txt two.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - unexpected argument             -->
  <!-- ============================================= -->

  <test-case name="usage parse too many args errors">
    <script>usage for extracmd {arg "<one>"}
proc extratest {args} {
    usage parse extracmd $args
}
extratest one two</script>
    <return>TCL_ERROR</return>
    <error>unexpected argument "two"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage help - generating help text             -->
  <!-- ============================================= -->

  <test-case name="usage help with wrong args errors">
    <script>usage help</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage help command"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage help undefined command errors">
    <script>usage help undefined</script>
    <return>TCL_ERROR</return>
    <error>no usage defined for "undefined"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage help simple command">
    <script>usage for helpcmd1 {arg "<file>"}
string match "Usage: helpcmd1 <file>*" [usage help helpcmd1]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage help with optional arg">
    <script>usage for helpcmd2 {arg "<file>" arg "?output?"}
string match "*<file> ?output?*" [usage help helpcmd2]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage help with variadic arg">
    <script>usage for helpcmd3 {arg "<files>..."}
string match "*<files>...*" [usage help helpcmd3]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage help with flags shows options">
    <script>usage for helpcmd4 {arg "<file>" flag "-v --verbose"}
string match "*?options?*" [usage help helpcmd4]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage help shows flag details">
    <script>usage for helpcmd5 {flag "-v --verbose"}
string match "*--verbose*" [usage help helpcmd5]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- Complex real-world scenarios                  -->
  <!-- ============================================= -->

  <test-case name="cp-like command">
    <script>usage for mycp {
    arg "<source>"
    arg "<dest>"
    flag "-r --recursive"
    flag "-f --force"
    flag "-v --verbose"
}
proc mycp {args} {
    usage parse mycp $args
    return "cp $source -> $dest (r=$recursive f=$force v=$verbose)"
}
mycp -r -v src/ dst/</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>cp src/ -> dst/ (r=1 f=0 v=1)</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="grep-like command">
    <script>usage for mygrep {
    arg "<pattern>"
    arg "?files?..."
    flag "-i --ignore-case"
    flag "-n --line-number"
    flag "-c --count"
}
proc mygrep {args} {
    usage parse mygrep $args
    return "pattern=$pattern files=$files i=$ignore_case n=$line_number c=$count"
}
mygrep -i -n "hello" file1.txt file2.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>pattern=hello files=file1.txt file2.txt i=1 n=1 c=0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="curl-like command with value flags">
    <script>usage for mycurl {
    arg "<url>"
    flag "-o --output <file>"
    flag "-H --header <header>"
    flag "-X --request <method>"
    flag "-v --verbose"
}
proc mycurl {args} {
    usage parse mycurl $args
    return "url=$url out=$output method=$request v=$verbose"
}
mycurl -X POST -o response.json https://api.example.com</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>url=https://api.example.com out=response.json method=POST v=0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="tar-like command">
    <script>usage for mytar {
    arg "<archive>"
    arg "?files?..."
    flag "-c --create"
    flag "-x --extract"
    flag "-v --verbose"
    flag "-f --file <name>"
}
proc mytar {args} {
    usage parse mytar $args
    return "arch=$archive files=$files c=$create x=$extract v=$verbose"
}
mytar -c -v archive.tar file1 file2 file3</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>arch=archive.tar files=file1 file2 file3 c=1 x=0 v=1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- Edge cases                                    -->
  <!-- ============================================= -->

  <test-case name="empty args list">
    <script>usage for emptycmd {flag "-v"}
proc emptytest {args} {
    usage parse emptycmd $args
    return "v=$v"
}
emptytest</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>v=0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="arg value looks like flag but after double dash">
    <script>usage for edgecmd1 {arg "<value>"}
proc edgetest1 {args} {
    usage parse edgecmd1 $args
    return $value
}
edgetest1 -- --looks-like-flag</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>--looks-like-flag</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="flag value with spaces">
    <script>usage for edgecmd2 {flag "-m --message <msg>"}
proc edgetest2 {args} {
    usage parse edgecmd2 $args
    return $message
}
edgetest2 -m "hello world"</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>hello world</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="flag value with equals in value">
    <script>usage for edgecmd3 {flag "--key <val>"}
proc edgetest3 {args} {
    usage parse edgecmd3 $args
    return $key
}
edgetest3 --key=a=b=c</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>a=b=c</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="spec with help text">
    <script>usage for helptextcmd {
    arg "<file>" help="input-file"
    flag "-v" help="verbose"
}
set help [usage help helptextcmd]
expr {[string match "*input-file*" $help] && [string match "*verbose*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="redefining spec overwrites">
    <script>usage for redefcmd {arg "<old>"}
usage for redefcmd {arg "<new>"}
proc redeftest {args} {
    usage parse redefcmd $args
    return $new
}
redeftest hello</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>hello</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="multiple commands independent">
    <script>usage for cmdA {arg "<a>"}
usage for cmdB {arg "<b>"}
proc testA {args} {
    usage parse cmdA $args
    return "A:$a"
}
proc testB {args} {
    usage parse cmdB $args
    return "B:$b"
}
list [testA alpha] [testB beta]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>A:alpha B:beta</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

</test-suite>
