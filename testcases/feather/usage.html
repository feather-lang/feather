<test-suite>
  <!--
    Usage Command Tests (feather-specific)

    Tests for the 'usage' command implementing CLI argument parsing
    based on the usage specification from https://usage.jdx.dev

    Uses ?arg? instead of [arg] for optional arguments (TCL compatibility).
    Uses block-based format for options:
      flag -v --verbose { help {description} }
  -->

  <!-- ============================================= -->
  <!-- Basic subcommand errors                       -->
  <!-- ============================================= -->

  <test-case name="usage with no subcommand errors">
    <script>usage</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage subcommand ?arg ...?"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage with unknown subcommand errors">
    <script>usage foo</script>
    <return>TCL_ERROR</return>
    <error>unknown subcommand "foo": must be for, help, or parse</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage for - defining specs                    -->
  <!-- ============================================= -->

  <test-case name="usage for with no args errors">
    <script>usage for</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage for command ?spec?"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage for with too many args errors">
    <script>usage for cmd spec extra</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage for command ?spec?"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage for defines a spec">
    <script>usage for testcmd {arg <input>}
string match {arg <input>} [usage for testcmd]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage for without spec retrieves existing">
    <script>usage for testcmd2 {arg <file> arg ?output?}
string match {arg <file> arg ?output?} [usage for testcmd2]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage for undefined command errors">
    <script>usage for nonexistent</script>
    <return>TCL_ERROR</return>
    <error>no usage defined for "nonexistent"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - basic argument parsing          -->
  <!-- ============================================= -->

  <test-case name="usage parse with wrong args errors">
    <script>usage parse</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage parse command args"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse with one arg errors">
    <script>usage parse cmd</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage parse command args"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse undefined command errors">
    <script>usage parse undefined {}</script>
    <return>TCL_ERROR</return>
    <error>no usage defined for "undefined"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse required arg">
    <script>usage for mycmd1 {arg <input>}
proc test1 {args} {
    usage parse mycmd1 $args
    return $input
}
test1 hello.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>hello.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse missing required arg errors">
    <script>usage for mycmd2 {arg <input>}
proc test2 {args} {
    usage parse mycmd2 $args
    return $input
}
test2</script>
    <return>TCL_ERROR</return>
    <error>missing required argument "input"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse optional arg with value">
    <script>usage for mycmd3 {arg ?output?}
proc test3 {args} {
    usage parse mycmd3 $args
    return $output
}
test3 result.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>result.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse optional arg without value">
    <script>usage for mycmd4 {arg ?output?}
proc test4 {args} {
    usage parse mycmd4 $args
    return "got:$output"
}
test4</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>got:</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse multiple positional args">
    <script>usage for mycmd5 {arg <src> arg <dst>}
proc test5 {args} {
    usage parse mycmd5 $args
    return "$src -> $dst"
}
test5 input.txt output.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>input.txt -> output.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse mixed required and optional">
    <script>usage for mycmd6 {arg <input> arg ?output?}
proc test6 {args} {
    usage parse mycmd6 $args
    return "$input|$output"
}
test6 in.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>in.txt|</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse mixed with both provided">
    <script>usage for mycmd7 {arg <input> arg ?output?}
proc test7 {args} {
    usage parse mycmd7 $args
    return "$input|$output"
}
test7 in.txt out.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>in.txt|out.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - default values                  -->
  <!-- ============================================= -->

  <test-case name="usage parse optional arg with default">
    <script>usage for defcmd1 {arg ?output? {default {default.txt}}}
proc deftest1 {args} {
    usage parse defcmd1 $args
    return $output
}
deftest1</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>default.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse override default with value">
    <script>usage for defcmd2 {arg ?output? {default {default.txt}}}
proc deftest2 {args} {
    usage parse defcmd2 $args
    return $output
}
deftest2 custom.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>custom.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - boolean flags                   -->
  <!-- ============================================= -->

  <test-case name="usage parse short flag">
    <script>usage for flagcmd1 {flag -v}
proc flagtest1 {args} {
    usage parse flagcmd1 $args
    return $v
}
flagtest1 -v</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse short flag not provided">
    <script>usage for flagcmd2 {flag -v}
proc flagtest2 {args} {
    usage parse flagcmd2 $args
    return $v
}
flagtest2</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse long flag">
    <script>usage for flagcmd3 {flag --verbose}
proc flagtest3 {args} {
    usage parse flagcmd3 $args
    return $verbose
}
flagtest3 --verbose</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse long flag not provided">
    <script>usage for flagcmd4 {flag --verbose}
proc flagtest4 {args} {
    usage parse flagcmd4 $args
    return $verbose
}
flagtest4</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse short and long flag - use short">
    <script>usage for flagcmd5 {flag -v --verbose}
proc flagtest5 {args} {
    usage parse flagcmd5 $args
    return $verbose
}
flagtest5 -v</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse short and long flag - use long">
    <script>usage for flagcmd6 {flag -v --verbose}
proc flagtest6 {args} {
    usage parse flagcmd6 $args
    return $verbose
}
flagtest6 --verbose</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse multiple flags">
    <script>usage for flagcmd7 {flag -v --verbose flag -q --quiet}
proc flagtest7 {args} {
    usage parse flagcmd7 $args
    return "$verbose|$quiet"
}
flagtest7 -v -q</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse some flags">
    <script>usage for flagcmd8 {flag -v --verbose flag -q --quiet flag -d --debug}
proc flagtest8 {args} {
    usage parse flagcmd8 $args
    return "$verbose|$quiet|$debug"
}
flagtest8 --debug</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>0|0|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - flags with values               -->
  <!-- ============================================= -->

  <test-case name="usage parse flag with required value">
    <script>usage for valflag1 {flag -n --count <num>}
proc valtest1 {args} {
    usage parse valflag1 $args
    return $count
}
valtest1 -n 5</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>5</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flag with value using long form">
    <script>usage for valflag2 {flag -n --count <num>}
proc valtest2 {args} {
    usage parse valflag2 $args
    return $count
}
valtest2 --count 10</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>10</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flag with value using equals">
    <script>usage for valflag3 {flag --count <num>}
proc valtest3 {args} {
    usage parse valflag3 $args
    return $count
}
valtest3 --count=42</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>42</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flag with value not provided">
    <script>usage for valflag4 {flag -n --count <num>}
proc valtest4 {args} {
    usage parse valflag4 $args
    return "count:$count"
}
valtest4</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>count:</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flag missing required value errors">
    <script>usage for valflag5 {flag -n --count <num>}
proc valtest5 {args} {
    usage parse valflag5 $args
    return $count
}
valtest5 -n</script>
    <return>TCL_ERROR</return>
    <error>flag -n requires a value</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse long flag missing required value errors">
    <script>usage for valflag6 {flag --count <num>}
proc valtest6 {args} {
    usage parse valflag6 $args
    return $count
}
valtest6 --count</script>
    <return>TCL_ERROR</return>
    <error>flag --count requires a value</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - mixed args and flags            -->
  <!-- ============================================= -->

  <test-case name="usage parse args and flags mixed">
    <script>usage for mixcmd1 {arg <input> flag -v --verbose arg ?output?}
proc mixtest1 {args} {
    usage parse mixcmd1 $args
    return "$input|$verbose|$output"
}
mixtest1 -v input.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>input.txt|1|</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flags between args">
    <script>usage for mixcmd2 {arg <src> arg <dst> flag -f --force}
proc mixtest2 {args} {
    usage parse mixcmd2 $args
    return "$src|$dst|$force"
}
mixtest2 a.txt -f b.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>a.txt|b.txt|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse flags with values and args">
    <script>usage for mixcmd3 {arg <file> flag -n --count <num> flag -v}
proc mixtest3 {args} {
    usage parse mixcmd3 $args
    return "$file|$count|$v"
}
mixtest3 data.txt -n 3 -v</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>data.txt|3|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - double dash                     -->
  <!-- ============================================= -->

  <test-case name="usage parse double dash ends flag parsing">
    <script>usage for ddcmd1 {arg <file> flag -v}
proc ddtest1 {args} {
    usage parse ddcmd1 $args
    return "$file|$v"
}
ddtest1 -- -v</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>-v|0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse double dash with flags before">
    <script>usage for ddcmd2 {arg <file> flag -v}
proc ddtest2 {args} {
    usage parse ddcmd2 $args
    return "$file|$v"
}
ddtest2 -v -- --not-a-flag</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>--not-a-flag|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - unknown flag errors             -->
  <!-- ============================================= -->

  <test-case name="usage parse unknown short flag errors">
    <script>usage for unkcmd1 {flag -v}
proc unktest1 {args} {
    usage parse unkcmd1 $args
}
unktest1 -x</script>
    <return>TCL_ERROR</return>
    <error>unknown flag "-x"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage parse unknown long flag errors">
    <script>usage for unkcmd2 {flag --verbose}
proc unktest2 {args} {
    usage parse unkcmd2 $args
}
unktest2 --unknown</script>
    <return>TCL_ERROR</return>
    <error>unknown flag "--unknown"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - variadic arguments              -->
  <!-- ============================================= -->

  <test-case name="usage parse variadic required arg">
    <script>usage for varcmd1 {arg <files>...}
proc vartest1 {args} {
    usage parse varcmd1 $args
    return $files
}
vartest1 a.txt b.txt c.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>a.txt b.txt c.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse variadic optional arg">
    <script>usage for varcmd2 {arg ?files?...}
proc vartest2 {args} {
    usage parse varcmd2 $args
    return "count:[llength $files]"
}
vartest2</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>count:0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse variadic optional arg with values">
    <script>usage for varcmd3 {arg ?files?...}
proc vartest3 {args} {
    usage parse varcmd3 $args
    return $files
}
vartest3 x.txt y.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>x.txt y.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse required arg then variadic">
    <script>usage for varcmd4 {arg <output> arg ?inputs?...}
proc vartest4 {args} {
    usage parse varcmd4 $args
    return "$output|$inputs"
}
vartest4 out.txt a.txt b.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>out.txt|a.txt b.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage parse variadic with flags">
    <script>usage for varcmd5 {flag -v arg <files>...}
proc vartest5 {args} {
    usage parse varcmd5 $args
    return "$v|$files"
}
vartest5 -v one.txt two.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1|one.txt two.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage parse - unexpected argument             -->
  <!-- ============================================= -->

  <test-case name="usage parse too many args errors">
    <script>usage for extracmd {arg <one>}
proc extratest {args} {
    usage parse extracmd $args
}
extratest one two</script>
    <return>TCL_ERROR</return>
    <error>unexpected argument "two"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage help - generating help text             -->
  <!-- ============================================= -->

  <test-case name="usage help with wrong args errors">
    <script>usage help</script>
    <return>TCL_ERROR</return>
    <error>wrong # args: should be "usage help command ?subcommand...?"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage help undefined command errors">
    <script>usage help undefined</script>
    <return>TCL_ERROR</return>
    <error>no usage defined for "undefined"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="usage help simple command">
    <script>usage for helpcmd1 {arg <file>}
string match "Usage: helpcmd1 <file>*" [usage help helpcmd1]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage help with optional arg">
    <script>usage for helpcmd2 {arg <file> arg ?output?}
string match "*<file> ?output?*" [usage help helpcmd2]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage help with variadic arg">
    <script>usage for helpcmd3 {arg <files>...}
string match "*<files>...*" [usage help helpcmd3]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage help with flags shows options">
    <script>usage for helpcmd4 {arg <file> flag -v --verbose}
string match "*?options?*" [usage help helpcmd4]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage help shows flag details">
    <script>usage for helpcmd5 {flag -v --verbose}
string match "*--verbose*" [usage help helpcmd5]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- Complex real-world scenarios                  -->
  <!-- ============================================= -->

  <test-case name="cp-like command">
    <script>usage for mycp {
    arg <source>
    arg <dest>
    flag -r --recursive
    flag -f --force
    flag -v --verbose
}
proc mycp {args} {
    usage parse mycp $args
    return "cp $source -> $dest (r=$recursive f=$force v=$verbose)"
}
mycp -r -v src/ dst/</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>cp src/ -> dst/ (r=1 f=0 v=1)</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="grep-like command">
    <script>usage for mygrep {
    arg <pattern>
    arg ?files?...
    flag -i --ignore-case
    flag -n --line-number
    flag -c --count
}
proc mygrep {args} {
    usage parse mygrep $args
    return "pattern=$pattern files=$files i=$ignore_case n=$line_number c=$count"
}
mygrep -i -n "hello" file1.txt file2.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>pattern=hello files=file1.txt file2.txt i=1 n=1 c=0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="curl-like command with value flags">
    <script>usage for mycurl {
    arg <url>
    flag -o --output <file>
    flag -H --header <header>
    flag -X --request <method>
    flag -v --verbose
}
proc mycurl {args} {
    usage parse mycurl $args
    return "url=$url out=$output method=$request v=$verbose"
}
mycurl -X POST -o response.json https://api.example.com</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>url=https://api.example.com out=response.json method=POST v=0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="tar-like command">
    <script>usage for mytar {
    arg <archive>
    arg ?files?...
    flag -c --create
    flag -x --extract
    flag -v --verbose
    flag -f --file <name>
}
proc mytar {args} {
    usage parse mytar $args
    return "arch=$archive files=$files c=$create x=$extract v=$verbose"
}
mytar -c -v archive.tar file1 file2 file3</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>arch=archive.tar files=file1 file2 file3 c=1 x=0 v=1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- Edge cases                                    -->
  <!-- ============================================= -->

  <test-case name="empty args list">
    <script>usage for emptycmd {flag -v}
proc emptytest {args} {
    usage parse emptycmd $args
    return "v=$v"
}
emptytest</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>v=0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="arg value looks like flag but after double dash">
    <script>usage for edgecmd1 {arg <value>}
proc edgetest1 {args} {
    usage parse edgecmd1 $args
    return $value
}
edgetest1 -- --looks-like-flag</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>--looks-like-flag</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="flag value with spaces">
    <script>usage for edgecmd2 {flag -m --message <msg>}
proc edgetest2 {args} {
    usage parse edgecmd2 $args
    return $message
}
edgetest2 -m "hello world"</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>hello world</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="flag value with equals in value">
    <script>usage for edgecmd3 {flag --key <val>}
proc edgetest3 {args} {
    usage parse edgecmd3 $args
    return $key
}
edgetest3 --key=a=b=c</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>a=b=c</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="spec with help text">
    <script>usage for helptextcmd {
    arg <file> {help {input file}}
    flag -v {help {verbose mode}}
}
set help [usage help helptextcmd]
expr {[string match "*input file*" $help] && [string match "*verbose*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="redefining spec overwrites">
    <script>usage for redefcmd {arg <old>}
usage for redefcmd {arg <new>}
proc redeftest {args} {
    usage parse redefcmd $args
    return $new
}
redeftest hello</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>hello</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="multiple commands independent">
    <script>usage for cmdA {arg <a>}
usage for cmdB {arg <b>}
proc testA {args} {
    usage parse cmdA $args
    return "A:$a"
}
proc testB {args} {
    usage parse cmdB $args
    return "B:$b"
}
list [testA alpha] [testB beta]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>A:alpha B:beta</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- Subcommand support                            -->
  <!-- ============================================= -->

  <test-case name="simple subcommand definition">
    <script>usage for mycli {
    cmd init {
        arg ?dir?
    }
    cmd run {
        arg <script>
    }
}
proc mycli {args} {
    usage parse mycli $args
    return "cmd=$subcommand"
}
mycli init</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>cmd=init</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="subcommand with args">
    <script>usage for cli1 {
    cmd add {
        arg <file>
    }
}
proc cli1 {args} {
    usage parse cli1 $args
    return "$subcommand:$file"
}
cli1 add myfile.txt</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>add:myfile.txt</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="subcommand with flags">
    <script>usage for cli2 {
    cmd build {
        flag -v --verbose
        flag -o --output <file>
    }
}
proc cli2 {args} {
    usage parse cli2 $args
    return "$subcommand:v=$verbose:o=$output"
}
cli2 build -v -o dist/app</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>build:v=1:o=dist/app</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="subcommand with args and flags">
    <script>usage for cli3 {
    cmd copy {
        arg <src>
        arg <dst>
        flag -r --recursive
    }
}
proc cli3 {args} {
    usage parse cli3 $args
    return "$subcommand:$src->$dst:r=$recursive"
}
cli3 copy -r /src /dst</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>copy:/src->/dst:r=1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="unknown subcommand errors">
    <script>usage for cli4 {
    cmd known {}
}
proc cli4 {args} {
    usage parse cli4 $args
}
cli4 unknown</script>
    <return>TCL_ERROR</return>
    <error>unknown subcommand "unknown"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="missing required subcommand errors">
    <script>usage for cli5 {
    cmd sub1 {}
    cmd sub2 {}
}
proc cli5 {args} {
    usage parse cli5 $args
}
cli5</script>
    <return>TCL_ERROR</return>
    <error>missing subcommand: must be sub1 or sub2</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="global flags before subcommand">
    <script>usage for cli6 {
    flag -v --verbose
    cmd run {
        arg <script>
    }
}
proc cli6 {args} {
    usage parse cli6 $args
    return "v=$verbose:$subcommand:$script"
}
cli6 -v run test.tcl</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>v=1:run:test.tcl</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="global flags after subcommand">
    <script>usage for cli7 {
    flag -v --verbose
    cmd run {
        arg <script>
    }
}
proc cli7 {args} {
    usage parse cli7 $args
    return "v=$verbose:$subcommand:$script"
}
cli7 run -v test.tcl</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>v=1:run:test.tcl</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- Nested subcommands (2 levels)                 -->
  <!-- ============================================= -->

  <test-case name="nested subcommand 2 levels">
    <script>usage for git1 {
    cmd remote {
        cmd add {
            arg <name>
            arg <url>
        }
        cmd remove {
            arg <name>
        }
    }
}
proc git1 {args} {
    usage parse git1 $args
    return "$subcommand:name=$name"
}
git1 remote add origin https://example.com</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>remote add:name=origin</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="nested subcommand with url arg">
    <script>usage for git2 {
    cmd remote {
        cmd add {
            arg <name>
            arg <url>
        }
    }
}
proc git2 {args} {
    usage parse git2 $args
    return "$name|$url"
}
git2 remote add origin https://github.com/test/repo</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>origin|https://github.com/test/repo</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="nested subcommand remove">
    <script>usage for git3 {
    cmd remote {
        cmd add {
            arg <name>
            arg <url>
        }
        cmd remove {
            arg <name>
        }
    }
}
proc git3 {args} {
    usage parse git3 $args
    return "$subcommand:$name"
}
git3 remote remove origin</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>remote remove:origin</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="nested subcommand with flags">
    <script>usage for docker1 {
    cmd container {
        cmd run {
            flag -d --detach
            flag -p --publish <port>
            arg <image>
        }
    }
}
proc docker1 {args} {
    usage parse docker1 $args
    return "$subcommand:d=$detach:p=$publish:$image"
}
docker1 container run -d -p 8080:80 nginx</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>container run:d=1:p=8080:80:nginx</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- Nested subcommands (3+ levels)                -->
  <!-- ============================================= -->

  <test-case name="nested subcommand 3 levels">
    <script>usage for k8s1 {
    cmd config {
        cmd current-context {}
        cmd use-context {
            arg <context>
        }
        cmd view {
            cmd users {}
            cmd clusters {}
        }
    }
}
proc k8s1 {args} {
    usage parse k8s1 $args
    return $subcommand
}
k8s1 config view clusters</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>config view clusters</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="nested subcommand 3 levels with args">
    <script>usage for tool1 {
    cmd level1 {
        cmd level2 {
            cmd level3 {
                arg <value>
            }
        }
    }
}
proc tool1 {args} {
    usage parse tool1 $args
    return "$subcommand:$value"
}
tool1 level1 level2 level3 myvalue</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>level1 level2 level3:myvalue</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="nested subcommand unknown at level 2">
    <script>usage for tool2 {
    cmd parent {
        cmd child1 {}
        cmd child2 {}
    }
}
proc tool2 {args} {
    usage parse tool2 $args
}
tool2 parent unknown</script>
    <return>TCL_ERROR</return>
    <error>unknown subcommand "unknown"</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="mixed global and subcommand flags">
    <script>usage for mix1 {
    flag -v --verbose
    flag -q --quiet
    cmd deploy {
        flag -f --force
        arg <target>
    }
}
proc mix1 {args} {
    usage parse mix1 $args
    return "v=$verbose:q=$quiet:f=$force:$target"
}
mix1 -v deploy -f production</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>v=1:q=0:f=1:production</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- usage help with subcommands                   -->
  <!-- ============================================= -->

  <test-case name="usage help shows subcommands">
    <script>usage for helpsub1 {
    cmd start {}
    cmd stop {}
    cmd status {}
}
set help [usage help helpsub1]
expr {[string match "*start*" $help] && [string match "*stop*" $help] && [string match "*status*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage help for specific subcommand">
    <script>usage for helpsub2 {
    cmd run {
        arg <script>
        flag -v --verbose
    }
}
set help [usage help helpsub2 run]
expr {[string match "*<script>*" $help] && [string match "*--verbose*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="usage help for nested subcommand">
    <script>usage for helpsub3 {
    cmd remote {
        cmd add {
            arg <name>
            arg <url>
        }
    }
}
set help [usage help helpsub3 remote add]
expr {[string match "*<name>*" $help] && [string match "*<url>*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- Complex real-world subcommand scenarios       -->
  <!-- ============================================= -->

  <test-case name="git-like CLI">
    <script>usage for mygit {
    flag -v --version
    flag -h --help
    cmd init {
        arg ?directory?
        flag --bare
    }
    cmd clone {
        arg <repository>
        arg ?directory?
        flag --depth <n>
    }
    cmd add {
        arg <pathspec>...
        flag -A --all
    }
    cmd commit {
        flag -m --message <msg>
        flag -a --all
    }
}
proc mygit {args} {
    usage parse mygit $args
    return $subcommand
}
mygit commit -m "test"</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>commit</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="git clone with args">
    <script>usage for mygit2 {
    cmd clone {
        arg <repository>
        arg ?directory?
        flag --depth <n>
    }
}
proc mygit2 {args} {
    usage parse mygit2 $args
    return "$repository|$directory|$depth"
}
mygit2 clone --depth 1 https://github.com/test/repo mydir</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>https://github.com/test/repo|mydir|1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="npm-like CLI">
    <script>usage for mynpm {
    cmd install {
        arg ?packages?...
        flag -g --global
        flag -D --save-dev
    }
    cmd run {
        arg <script>
        arg ?args?...
    }
    cmd init {
        flag -y --yes
    }
}
proc mynpm {args} {
    usage parse mynpm $args
    return "$subcommand:g=$global:D=$save_dev"
}
mynpm install -g typescript</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>install:g=1:D=0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="docker-like CLI nested">
    <script>usage for mydocker {
    cmd container {
        cmd ls {
            flag -a --all
            flag -q --quiet
        }
        cmd run {
            flag -d --detach
            flag -it
            flag --name <name>
            arg <image>
            arg ?command?...
        }
        cmd stop {
            arg <containers>...
        }
    }
    cmd image {
        cmd ls {
            flag -a --all
        }
        cmd pull {
            arg <image>
        }
    }
}
proc mydocker {args} {
    usage parse mydocker $args
    return $subcommand
}
mydocker image pull nginx</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>image pull</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="deep nesting 4 levels">
    <script>usage for deep1 {
    cmd a {
        cmd b {
            cmd c {
                cmd d {
                    arg <value>
                }
            }
        }
    }
}
proc deep1 {args} {
    usage parse deep1 $args
    return "$subcommand:$value"
}
deep1 a b c d final</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>a b c d:final</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- hide feature                                  -->
  <!-- ============================================= -->

  <test-case name="hidden flag not shown in help">
    <script>usage for hidecmd1 {
    flag -v --verbose {help {Show verbose output}}
    flag --debug {hide help {Internal debugging}}
}
set help [usage help hidecmd1]
expr {[string match "*--verbose*" $help] && ![string match "*--debug*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="hidden flag still works when used">
    <script>usage for hidecmd2 {
    flag -v --verbose
    flag --debug {hide}
}
proc hidecmd2 {args} {
    usage parse hidecmd2 $args
    return "v=$verbose:d=$debug"
}
hidecmd2 --debug -v</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>v=1:d=1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="hidden arg not shown in help">
    <script>usage for hidecmd3 {
    arg <input> {help {Input file}}
    arg ?internal? {hide help {Internal use only}}
}
set help [usage help hidecmd3]
expr {[string match "*input*" $help] && ![string match "*internal*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="hidden arg still parsed">
    <script>usage for hidecmd4 {
    arg <visible>
    arg ?hidden? {hide}
}
proc hidecmd4 {args} {
    usage parse hidecmd4 $args
    return "$visible|$hidden"
}
hidecmd4 first second</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>first|second</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="hidden subcommand not shown in help">
    <script>usage for hidecmd5 {
    cmd public {} {help {Public command}}
    cmd internal {} {hide help {Internal command}}
}
set help [usage help hidecmd5]
expr {[string match "*public*" $help] && ![string match "*internal*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="hidden subcommand still works">
    <script>usage for hidecmd6 {
    cmd public {}
    cmd internal {
        arg <secret>
    } {hide}
}
proc hidecmd6 {args} {
    usage parse hidecmd6 $args
    return "$subcommand:$secret"
}
hidecmd6 internal mysecret</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>internal:mysecret</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="all flags hidden shows no options placeholder">
    <script>usage for hidecmd7 {
    flag -v {hide}
    flag -d {hide}
    arg <file>
}
set help [usage help hidecmd7]
expr {![string match "*options*" $help] && [string match "*<file>*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- choices feature                               -->
  <!-- ============================================= -->

  <test-case name="choices shown in flag help">
    <script>usage for choicecmd1 {
    flag -l --level <level> {choices {debug info warn error}}
}
set help [usage help choicecmd1]
string match "*choices: debug info warn error*" $help</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="choices shown in arg help">
    <script>usage for choicecmd2 {
    arg <format> {help {output format} choices {json xml csv}}
}
set help [usage help choicecmd2]
string match "*choices: json xml csv*" $help</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="flag with choices still parses value">
    <script>usage for choicecmd3 {
    flag --format <fmt> {choices {json xml}}
}
proc choicecmd3 {args} {
    usage parse choicecmd3 $args
    return $format
}
choicecmd3 --format json</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>json</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="arg with choices still parses value">
    <script>usage for choicecmd4 {
    arg <mode> {choices {fast slow}}
}
proc choicecmd4 {args} {
    usage parse choicecmd4 $args
    return $mode
}
choicecmd4 fast</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>fast</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="choices with help text">
    <script>usage for choicecmd5 {
    flag -o --output <format> {help {output format} choices {json yaml toml}}
}
set help [usage help choicecmd5]
expr {[string match "*output format*" $help] && [string match "*choices: json yaml toml*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- long_help feature                             -->
  <!-- ============================================= -->

  <test-case name="long_help stored in spec">
    <script>usage for longhcmd1 {
    arg <file> {help {input file} long_help {detailed description}}
}
# Just verify it parses without error
string length [usage for longhcmd1]</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>69</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="flag with long_help parses">
    <script>usage for longhcmd2 {
    flag -v --verbose {help {verbose output} long_help {detailed logging}}
}
proc longhcmd2 {args} {
    usage parse longhcmd2 $args
    return $verbose
}
longhcmd2 -v</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="cmd with long_help parses">
    <script>usage for longhcmd3 {
    cmd run {
        arg <script>
    } {help {run script} long_help {execute script file}}
}
proc longhcmd3 {args} {
    usage parse longhcmd3 $args
    return "$subcommand:$script"
}
longhcmd3 run test.tcl</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>run:test.tcl</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- Combined features                             -->
  <!-- ============================================= -->

  <test-case name="hide with choices and help">
    <script>usage for combcmd1 {
    flag --level <l> {help {log level} choices {debug info warn error}}
    flag --internal-level <l> {hide choices {trace debug}}
}
set help [usage help combcmd1]
expr {[string match "*--level*" $help] && [string match "*debug info warn error*" $help] && ![string match "*--internal-level*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="subcommand with help shown in commands list">
    <script>usage for combcmd2 {
    cmd start {} {help {start service}}
    cmd stop {} {help {stop service}}
}
set help [usage help combcmd2]
expr {[string match "*start*start service*" $help] && [string match "*stop*stop service*" $help]}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="arg with only choices shows in args section">
    <script>usage for combcmd3 {
    arg <type> {choices {a b c}}
}
set help [usage help combcmd3]
string match "*Arguments:*type*choices: a b c*" $help</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- New block-based format tests                  -->
  <!-- ============================================= -->

  <test-case name="multi-line help text in flag">
    <script>usage for blockcmd1 {
    flag -v --verbose {
        help {Enable verbose mode with detailed output}
    }
}
set help [usage help blockcmd1]
string match "*Enable verbose mode*" $help</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="multi-line choices list">
    <script>usage for blockcmd2 {
    flag -l --level <level> {
        choices {
            debug
            info
            warn
            error
        }
    }
}
set help [usage help blockcmd2]
string match "*choices:*debug*info*warn*error*" $help</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="flag with all options in block">
    <script>usage for blockcmd3 {
    flag -o --output <file> {
        help {Output file path}
        long_help {The path where output will be written}
        choices {stdout file.txt file.json}
    }
}
proc blockcmd3 {args} {
    usage parse blockcmd3 $args
    return $output
}
blockcmd3 -o file.json</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>file.json</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="arg with default and help in block">
    <script>usage for blockcmd4 {
    arg ?config? {
        default {config.json}
        help {Configuration file}
    }
}
proc blockcmd4 {args} {
    usage parse blockcmd4 $args
    return $config
}
blockcmd4</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>config.json</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <!-- ============================================= -->
  <!-- type script feature                           -->
  <!-- ============================================= -->

  <test-case name="arg with type script accepts complete script">
    <script>usage for scriptcmd1 {
    arg <code> {type script}
}
proc scriptcmd1 {args} {
    usage parse scriptcmd1 $args
    return $code
}
scriptcmd1 {puts hello; set x 1}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>puts hello; set x 1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="arg with type script rejects incomplete script">
    <script>usage for scriptcmd2 {
    arg <code> {type script}
}
proc scriptcmd2 {args} {
    usage parse scriptcmd2 $args
    return $code
}
scriptcmd2 {puts [list}</script>
    <return>TCL_ERROR</return>
    <error>argument "code" must be a complete script</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="arg with type script rejects unbalanced quotes">
    <script>usage for scriptcmd3 {
    arg <code> {type script}
}
proc scriptcmd3 {args} {
    usage parse scriptcmd3 $args
    return $code
}
scriptcmd3 {puts "hello}</script>
    <return>TCL_ERROR</return>
    <error>argument "code" must be a complete script</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="flag with type script accepts complete script">
    <script>usage for scriptcmd4 {
    flag -c --code <script> {type script}
}
proc scriptcmd4 {args} {
    usage parse scriptcmd4 $args
    return $code
}
scriptcmd4 --code {foreach x {1 2 3} {puts $x}}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>foreach x {1 2 3} {puts $x}</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="flag with type script rejects incomplete script">
    <script>usage for scriptcmd5 {
    flag --eval <script> {type script}
}
proc scriptcmd5 {args} {
    usage parse scriptcmd5 $args
    return $eval
}
# Create incomplete script using escaped brace
set incomplete "if \{condition"
scriptcmd5 --eval $incomplete</script>
    <return>TCL_ERROR</return>
    <error>flag --eval value must be a complete script</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="short flag with type script rejects incomplete">
    <script>usage for scriptcmd6 {
    flag -e <script> {type script}
}
proc scriptcmd6 {args} {
    usage parse scriptcmd6 $args
    return $e
}
# Create incomplete script using escaped brace
set incomplete "while \{1"
scriptcmd6 -e $incomplete</script>
    <return>TCL_ERROR</return>
    <error>flag -e value must be a complete script</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

  <test-case name="type script accepts empty string">
    <script>usage for scriptcmd7 {
    arg ?code? {type script}
}
proc scriptcmd7 {args} {
    usage parse scriptcmd7 $args
    return "len:[string length $code]"
}
scriptcmd7</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>len:0</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="type script with help text">
    <script>usage for scriptcmd8 {
    arg <code> {type script help {TCL code to execute}}
}
set help [usage help scriptcmd8]
string match "*TCL code to execute*" $help</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>1</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="type script in subcommand">
    <script>usage for scriptcli {
    cmd eval {
        arg <code> {type script}
    }
}
proc scriptcli {args} {
    usage parse scriptcli $args
    return "$subcommand:$code"
}
scriptcli eval {expr {1 + 2}}</script>
    <return>TCL_OK</return>
    <error></error>
    <stdout>eval:expr {1 + 2}</stdout>
    <stderr></stderr>
    <exit-code>0</exit-code>
  </test-case>

  <test-case name="type script in subcommand rejects incomplete">
    <script>usage for scriptcli2 {
    cmd run {
        arg <script> {type script}
    }
}
proc scriptcli2 {args} {
    usage parse scriptcli2 $args
    return $script
}
# Create incomplete script using escaped brace
set incomplete "proc foo \{"
scriptcli2 run $incomplete</script>
    <return>TCL_ERROR</return>
    <error>argument "script" must be a complete script</error>
    <stderr></stderr>
    <exit-code>1</exit-code>
  </test-case>

</test-suite>
