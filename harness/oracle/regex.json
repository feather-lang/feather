{
  "feature": "regex",
  "tclsh": "tclsh",
  "tests": [
    {
      "name": "regexp-1.0",
      "file": "spec/tests/regex/regexp-1.0.tcl",
      "script": "# Test: regexp basic matching - returns 1 on match, 0 on no match\nputs [regexp {foo} \"foobar\"]\nputs [regexp {baz} \"foobar\"]\n",
      "stdout": "1\n0\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-1.1",
      "file": "spec/tests/regex/regexp-1.1.tcl",
      "script": "# Test: regexp with match variable\nregexp {f(..)bar} \"foobar\" match sub1\nputs $match\nputs $sub1\n",
      "stdout": "foobar\noo\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-1.2",
      "file": "spec/tests/regex/regexp-1.2.tcl",
      "script": "# Test: regexp with multiple submatches\nregexp {(\\w+)@(\\w+)\\.(\\w+)} \"user@example.com\" match user domain tld\nputs $match\nputs $user\nputs $domain\nputs $tld\n",
      "stdout": "user@example.com\nuser\nexample\ncom\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-1.3",
      "file": "spec/tests/regex/regexp-1.3.tcl",
      "script": "# Test: regexp -nocase option\nputs [regexp -nocase {foo} \"FOOBAR\"]\nputs [regexp -nocase {foo} \"FooBar\"]\nputs [regexp {foo} \"FOOBAR\"]\n",
      "stdout": "1\n1\n0\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-1.4",
      "file": "spec/tests/regex/regexp-1.4.tcl",
      "script": "# Test: regexp -indices option\nregexp -indices {foo} \"abcfoodef\" match\nputs $match\n",
      "stdout": "3 5\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-1.5",
      "file": "spec/tests/regex/regexp-1.5.tcl",
      "script": "# Test: regexp -indices with submatches\nregexp -indices {f(..)bar} \"xfoobarx\" match sub1\nputs $match\nputs $sub1\n",
      "stdout": "1 6\n2 3\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-1.6",
      "file": "spec/tests/regex/regexp-1.6.tcl",
      "script": "# Test: regexp -all option - count matches\nputs [regexp -all {o} \"foobar\"]\nputs [regexp -all {x} \"foobar\"]\nputs [regexp -all {\\d} \"a1b2c3d4\"]\n",
      "stdout": "2\n0\n4\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-1.7",
      "file": "spec/tests/regex/regexp-1.7.tcl",
      "script": "# Test: regexp -inline option\nputs [regexp -inline {f(..)bar} \"xfoobarx\"]\n",
      "stdout": "foobar oo\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-1.8",
      "file": "spec/tests/regex/regexp-1.8.tcl",
      "script": "# Test: regexp -all -inline combination\nputs [regexp -all -inline {\\w+} \"hello world foo\"]\n",
      "stdout": "hello world foo\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-1.9",
      "file": "spec/tests/regex/regexp-1.9.tcl",
      "script": "# Test: regexp -- to mark end of switches\nputs [regexp -- {-test} \"this-test-works\"]\n",
      "stdout": "1\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-2.0",
      "file": "spec/tests/regex/regexp-2.0.tcl",
      "script": "# Test: regexp with no match - variables should be empty\nset result [regexp {xyz} \"foobar\" match]\nputs $result\nif {[info exists match]} { puts \"match=$match\" } else { puts \"match unset\" }\n",
      "stdout": "0\nmatch unset\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-2.1",
      "file": "spec/tests/regex/regexp-2.1.tcl",
      "script": "# Test: regexp empty string and empty pattern\nputs [regexp {} \"foobar\"]\nputs [regexp {foo} \"\"]\n",
      "stdout": "1\n0\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-2.2",
      "file": "spec/tests/regex/regexp-2.2.tcl",
      "script": "# Test: regexp -start option\nputs [regexp -start 3 {foo} \"foofoofoo\"]\nputs [regexp -start 3 {foo} \"foobarfoo\"]\nregexp -start 3 {foo} \"foobarfoo\" match\nputs $match\n",
      "stdout": "1\n1\nfoo\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-2.3",
      "file": "spec/tests/regex/regexp-2.3.tcl",
      "script": "# Test: regexp with special regex characters\nputs [regexp {\\d+} \"abc123def\"]\nputs [regexp {\\s+} \"hello world\"]\nputs [regexp {\\.} \"file.txt\"]\n",
      "stdout": "1\n1\n1\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-2.4",
      "file": "spec/tests/regex/regexp-2.4.tcl",
      "script": "# Test: regexp anchors\nputs [regexp {^foo} \"foobar\"]\nputs [regexp {^foo} \"barfoo\"]\nputs [regexp {bar$} \"foobar\"]\nputs [regexp {bar$} \"barfoo\"]\n",
      "stdout": "1\n0\n1\n0\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regexp-2.5",
      "file": "spec/tests/regex/regexp-2.5.tcl",
      "script": "# Test: regexp optional submatch (when group doesn't match)\nregexp {foo(bar)?baz} \"foobaz\" match sub1\nputs $match\nputs \"sub1=\u003c$sub1\u003e\"\n",
      "stdout": "foobaz\nsub1=\u003c\u003e\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-1.0",
      "file": "spec/tests/regex/regsub-1.0.tcl",
      "script": "# Test: regsub basic substitution\nputs [regsub {foo} \"foobar\" \"XXX\"]\n",
      "stdout": "XXXbar\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-1.1",
      "file": "spec/tests/regex/regsub-1.1.tcl",
      "script": "# Test: regsub with variable\nregsub {foo} \"foobar\" \"XXX\" result\nputs $result\n",
      "stdout": "XXXbar\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-1.2",
      "file": "spec/tests/regex/regsub-1.2.tcl",
      "script": "# Test: regsub -all option\nputs [regsub -all {o} \"foobar\" \"X\"]\nputs [regsub -all {\\d} \"a1b2c3\" \"X\"]\n",
      "stdout": "fXXbar\naXbXcX\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-1.3",
      "file": "spec/tests/regex/regsub-1.3.tcl",
      "script": "# Test: regsub -nocase option\nputs [regsub -nocase {foo} \"FOOBAR\" \"xxx\"]\nputs [regsub -nocase {foo} \"FooBar\" \"xxx\"]\n",
      "stdout": "xxxBAR\nxxxBar\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-1.4",
      "file": "spec/tests/regex/regsub-1.4.tcl",
      "script": "# Test: regsub with \u0026 back-reference (entire match)\nputs [regsub {\\w+} \"hello world\" {[\\0]}]\nputs [regsub {\\w+} \"hello world\" {[\u0026]}]\n",
      "stdout": "[hello] world\n[hello] world\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-1.5",
      "file": "spec/tests/regex/regsub-1.5.tcl",
      "script": "# Test: regsub with numbered back-references\nputs [regsub {(\\w+)@(\\w+)} \"user@host\" {\\2-\\1}]\n",
      "stdout": "host-user\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-1.6",
      "file": "spec/tests/regex/regsub-1.6.tcl",
      "script": "# Test: regsub no match - returns original string\nputs [regsub {xyz} \"foobar\" \"XXX\"]\n",
      "stdout": "foobar\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-1.7",
      "file": "spec/tests/regex/regsub-1.7.tcl",
      "script": "# Test: regsub return value with varName (count of replacements)\nset count [regsub -all {o} \"foobar\" \"X\" result]\nputs $count\nputs $result\n",
      "stdout": "2\nfXXbar\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-1.8",
      "file": "spec/tests/regex/regsub-1.8.tcl",
      "script": "# Test: regsub -- to mark end of switches\nputs [regsub -- {-test} \"a-test-b\" \"XXX\"]\n",
      "stdout": "aXXX-b\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-1.9",
      "file": "spec/tests/regex/regsub-1.9.tcl",
      "script": "# Test: regsub with empty replacement\nputs [regsub {foo} \"foobar\" \"\"]\nputs [regsub -all {\\d} \"a1b2c3\" \"\"]\n",
      "stdout": "bar\nabc\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-2.0",
      "file": "spec/tests/regex/regsub-2.0.tcl",
      "script": "# Test: regsub -all with back-references\nputs [regsub -all {(\\w+)} \"hello world foo\" {\u003c\\1\u003e}]\n",
      "stdout": "\u003chello\u003e \u003cworld\u003e \u003cfoo\u003e\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-2.1",
      "file": "spec/tests/regex/regsub-2.1.tcl",
      "script": "# Test: regsub empty string and empty pattern\nputs [regsub {} \"foobar\" \"X\"]\nputs [regsub {foo} \"\" \"X\"]\n",
      "stdout": "Xfoobar\n\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "regsub-2.2",
      "file": "spec/tests/regex/regsub-2.2.tcl",
      "script": "# Test: regsub -start option\nputs [regsub -start 3 {foo} \"foofoofoo\" \"XXX\"]\n",
      "stdout": "fooXXXfoo\n",
      "stderr": "",
      "returncode": 0
    }
  ]
}