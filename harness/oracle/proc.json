{
  "feature": "proc",
  "tclsh": "tclsh",
  "tests": [
    {
      "name": "apply-1.0",
      "file": "spec/tests/proc/apply-1.0.tcl",
      "script": "# Test: apply - basic anonymous function with single argument\nputs [apply {x {expr {$x * 2}}} 5]\n",
      "stdout": "10\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-1.1",
      "file": "spec/tests/proc/apply-1.1.tcl",
      "script": "# Test: apply - anonymous function with multiple arguments\nputs [apply {{x y} {expr {$x + $y}}} 3 4]\n",
      "stdout": "7\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-1.2",
      "file": "spec/tests/proc/apply-1.2.tcl",
      "script": "# Test: apply - anonymous function with no arguments\nputs [apply {{} {expr {1 + 2}}}]\n",
      "stdout": "3\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-1.3",
      "file": "spec/tests/proc/apply-1.3.tcl",
      "script": "# Test: apply - anonymous function with default argument\nputs [apply {{x {y 10}} {expr {$x + $y}}} 5]\n",
      "stdout": "15\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-1.4",
      "file": "spec/tests/proc/apply-1.4.tcl",
      "script": "# Test: apply - anonymous function with default argument overridden\nputs [apply {{x {y 10}} {expr {$x + $y}}} 5 20]\n",
      "stdout": "25\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-1.5",
      "file": "spec/tests/proc/apply-1.5.tcl",
      "script": "# Test: apply - anonymous function with args (variable arguments)\nputs [apply {{x args} {list $x $args}} a b c d]\n",
      "stdout": "a {b c d}\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-1.6",
      "file": "spec/tests/proc/apply-1.6.tcl",
      "script": "# Test: apply - anonymous function with only args\nputs [apply {args {llength $args}} a b c d e]\n",
      "stdout": "5\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-1.7",
      "file": "spec/tests/proc/apply-1.7.tcl",
      "script": "# Test: apply - anonymous function with explicit return\nputs [apply {x {return [expr {$x * 3}]}} 7]\n",
      "stdout": "21\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-1.8",
      "file": "spec/tests/proc/apply-1.8.tcl",
      "script": "# Test: apply - string manipulation in lambda body\nputs [apply {s {string length $s}} hello]\n",
      "stdout": "5\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-1.9",
      "file": "spec/tests/proc/apply-1.9.tcl",
      "script": "# Test: apply - local variable in lambda body\nputs [apply {x {\n    set y [expr {$x + 1}]\n    expr {$y * 2}\n}} 4]\n",
      "stdout": "10\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-2.0",
      "file": "spec/tests/proc/apply-2.0.tcl",
      "script": "# Test: apply - error when lambda has wrong number of elements (1 element)\ncatch {apply {x}} result\nputs $result\n",
      "stdout": "can't interpret \"x\" as a lambda expression\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-2.1",
      "file": "spec/tests/proc/apply-2.1.tcl",
      "script": "# Test: apply - error when lambda has wrong number of elements (4 elements)\ncatch {apply {a b c d}} result\nputs $result\n",
      "stdout": "can't interpret \"a b c d\" as a lambda expression\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-2.2",
      "file": "spec/tests/proc/apply-2.2.tcl",
      "script": "# Test: apply - error when too few arguments passed\ncatch {apply {{x y} {expr {$x + $y}}} 5} result\nputs $result\n",
      "stdout": "wrong # args: should be \"apply lambdaExpr x y\"\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-2.3",
      "file": "spec/tests/proc/apply-2.3.tcl",
      "script": "# Test: apply - error when too many arguments passed\ncatch {apply {{x} {expr {$x * 2}}} 5 6 7} result\nputs $result\n",
      "stdout": "wrong # args: should be \"apply lambdaExpr x\"\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-2.4",
      "file": "spec/tests/proc/apply-2.4.tcl",
      "script": "# Test: apply - 3-element lambda with namespace (global namespace)\nputs [apply {{x} {expr {$x + 1}} ::} 10]\n",
      "stdout": "11\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-2.5",
      "file": "spec/tests/proc/apply-2.5.tcl",
      "script": "# Test: apply - scope isolation (lambda does not see caller's local variables)\nproc testscope {} {\n    set localvar 100\n    catch {apply {{} {set localvar}}} result\n    return $result\n}\nputs [testscope]\n",
      "stdout": "can't read \"localvar\": no such variable\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-2.6",
      "file": "spec/tests/proc/apply-2.6.tcl",
      "script": "# Test: apply - accessing global variable with global command\nset globalvar 42\nputs [apply {{} {global globalvar; set globalvar}}]\n",
      "stdout": "42\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-2.7",
      "file": "spec/tests/proc/apply-2.7.tcl",
      "script": "# Test: apply - nested apply calls\nputs [apply {x {apply {y {expr {$y * 2}}} [expr {$x + 1}]}} 5]\n",
      "stdout": "12\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-2.8",
      "file": "spec/tests/proc/apply-2.8.tcl",
      "script": "# Test: apply - using upvar within lambda\nproc testupvar {} {\n    set x 10\n    apply {{varname} {upvar 1 $varname v; set v 20}} x\n    return $x\n}\nputs [testupvar]\n",
      "stdout": "20\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-2.9",
      "file": "spec/tests/proc/apply-2.9.tcl",
      "script": "# Test: apply - map example from documentation\nproc map {lambda list} {\n    set result {}\n    foreach item $list {\n        lappend result [apply $lambda $item]\n    }\n    return $result\n}\nputs [map {x {expr {$x * $x}}} {1 2 3 4 5}]\n",
      "stdout": "1 4 9 16 25\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-3.0",
      "file": "spec/tests/proc/apply-3.0.tcl",
      "script": "# Test: apply - empty body returns empty string\nputs \"[apply {{} {}}]end\"\n",
      "stdout": "end\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-3.1",
      "file": "spec/tests/proc/apply-3.1.tcl",
      "script": "# Test: apply - error with empty lambda list\ncatch {apply {}} result\nputs $result\n",
      "stdout": "can't interpret \"\" as a lambda expression\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "apply-3.2",
      "file": "spec/tests/proc/apply-3.2.tcl",
      "script": "# Test: apply - modifying global variable inside lambda\nset counter 0\napply {{} {global counter; incr counter}}\napply {{} {global counter; incr counter}}\napply {{} {global counter; incr counter}}\nputs $counter\n",
      "stdout": "3\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "args-1.1",
      "file": "spec/tests/proc/args-1.1.tcl",
      "script": "# Test: procedure with args (varargs)\nproc printall {args} {\n    puts \"args: $args\"\n}\nprintall\nprintall one\nprintall one two three\n",
      "stdout": "args: \nargs: one\nargs: one two three\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "args-1.2",
      "file": "spec/tests/proc/args-1.2.tcl",
      "script": "# Test: procedure with required args and varargs\nproc printf {fmt args} {\n    puts \"format: $fmt\"\n    puts \"values: $args\"\n}\nprintf \"%s %d\"\nprintf \"%s %d\" hello 42\n",
      "stdout": "format: %s %d\nvalues: \nformat: %s %d\nvalues: hello 42\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "basic-1.1",
      "file": "spec/tests/proc/basic-1.1.tcl",
      "script": "# Test: basic procedure definition and invocation\nproc hello {} {\n    puts \"Hello, World!\"\n}\nhello\n",
      "stdout": "Hello, World!\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "basic-1.2",
      "file": "spec/tests/proc/basic-1.2.tcl",
      "script": "# Test: procedure with single argument\nproc greet {name} {\n    puts \"Hello, $name!\"\n}\ngreet Alice\ngreet Bob\n",
      "stdout": "Hello, Alice!\nHello, Bob!\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "basic-1.3",
      "file": "spec/tests/proc/basic-1.3.tcl",
      "script": "# Test: procedure with multiple arguments\nproc add {a b} {\n    puts [expr $a + $b]\n}\nadd 3 4\nadd 10 20\n",
      "stdout": "7\n30\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "default-1.1",
      "file": "spec/tests/proc/default-1.1.tcl",
      "script": "# Test: procedure with default argument\nproc greet {{name World}} {\n    puts \"Hello, $name!\"\n}\ngreet\ngreet Alice\n",
      "stdout": "Hello, World!\nHello, Alice!\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "default-1.2",
      "file": "spec/tests/proc/default-1.2.tcl",
      "script": "# Test: procedure with multiple default arguments\nproc config {{host localhost} {port 8080}} {\n    puts \"Connecting to $host:$port\"\n}\nconfig\nconfig myserver\nconfig myserver 9000\n",
      "stdout": "Connecting to localhost:8080\nConnecting to myserver:8080\nConnecting to myserver:9000\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "nested-1.1",
      "file": "spec/tests/proc/nested-1.1.tcl",
      "script": "# Test: nested procedure calls\nproc double {x} {\n    return [expr $x * 2]\n}\nproc quadruple {x} {\n    return [double [double $x]]\n}\nputs [quadruple 3]\n",
      "stdout": "12\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "recurse-1.1",
      "file": "spec/tests/proc/recurse-1.1.tcl",
      "script": "# Test: recursive procedure (factorial)\nproc factorial {n} {\n    if {$n \u003c= 1} {\n        return 1\n    }\n    return [expr $n * [factorial [expr $n - 1]]]\n}\nputs [factorial 5]\n",
      "stdout": "120\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "rename-1.0",
      "file": "spec/tests/proc/rename-1.0.tcl",
      "script": "# Test: basic rename - rename a procedure\nproc foo {} {\n    return \"hello from foo\"\n}\nrename foo bar\nputs [bar]\n",
      "stdout": "hello from foo\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "rename-1.1",
      "file": "spec/tests/proc/rename-1.1.tcl",
      "script": "# Test: original name no longer exists after rename\nproc foo {} {\n    return \"hello\"\n}\nrename foo bar\ncatch {foo} err\nputs $err\n",
      "stdout": "invalid command name \"foo\"\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "rename-1.2",
      "file": "spec/tests/proc/rename-1.2.tcl",
      "script": "# Test: rename returns empty string\nproc foo {} {\n    return \"hello\"\n}\nset result [rename foo bar]\nputs \"result: '$result'\"\n",
      "stdout": "result: ''\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "rename-1.3",
      "file": "spec/tests/proc/rename-1.3.tcl",
      "script": "# Test: delete command by renaming to empty string\nproc foo {} {\n    return \"hello\"\n}\nrename foo \"\"\ncatch {foo} err\nputs $err\n",
      "stdout": "invalid command name \"foo\"\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "rename-1.4",
      "file": "spec/tests/proc/rename-1.4.tcl",
      "script": "# Test: error when renaming non-existent command\ncatch {rename nonexistent newname} err\nputs $err\n",
      "stdout": "can't rename \"nonexistent\": command doesn't exist\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "rename-1.5",
      "file": "spec/tests/proc/rename-1.5.tcl",
      "script": "# Test: error when renaming to existing command name\nproc foo {} { return \"foo\" }\nproc bar {} { return \"bar\" }\ncatch {rename foo bar} err\nputs $err\n",
      "stdout": "can't rename to \"bar\": command already exists\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "rename-1.6",
      "file": "spec/tests/proc/rename-1.6.tcl",
      "script": "# Test: rename a builtin command\nrename puts myputs\nmyputs \"hello from myputs\"\nrename myputs puts\n",
      "stdout": "hello from myputs\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "rename-1.7",
      "file": "spec/tests/proc/rename-1.7.tcl",
      "script": "# Test: chain of renames\nproc original {} { return \"original\" }\nrename original step1\nrename step1 step2\nrename step2 final\nputs [final]\n",
      "stdout": "original\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "rename-1.8",
      "file": "spec/tests/proc/rename-1.8.tcl",
      "script": "# Test: rename with special characters in name\nproc {my proc} {} { return \"special\" }\nrename {my proc} normalname\nputs [normalname]\n",
      "stdout": "special\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "return-1.1",
      "file": "spec/tests/proc/return-1.1.tcl",
      "script": "# Test: return value from procedure\nproc double {x} {\n    return [expr $x * 2]\n}\nputs [double 5]\nputs [double 21]\n",
      "stdout": "10\n42\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "return-1.2",
      "file": "spec/tests/proc/return-1.2.tcl",
      "script": "# Test: implicit return (last command result)\nproc square {x} {\n    expr $x * $x\n}\nputs [square 3]\nputs [square 7]\n",
      "stdout": "9\n49\n",
      "stderr": "",
      "returncode": 0
    },
    {
      "name": "scope-1.1",
      "file": "spec/tests/proc/scope-1.1.tcl",
      "script": "# Test: local variable scoping\nset x 100\nproc test {} {\n    set x 1\n    puts \"inside: $x\"\n}\ntest\nputs \"outside: $x\"\n",
      "stdout": "inside: 1\noutside: 100\n",
      "stderr": "",
      "returncode": 0
    }
  ]
}