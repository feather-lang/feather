# eval Builtin Command

Comparison of feather's `eval` implementation against the TCL manual.

## Summary of Our Implementation

Our implementation in `src/builtin_eval.c` provides the core `eval` functionality:

1. **Argument validation**: Requires at least one argument, returns error "wrong # args: should be \"eval arg ?arg ...?\"" if no arguments provided.

2. **Single argument case**: If exactly one argument is provided, it is used directly as the script to evaluate.

3. **Multiple arguments case**: If multiple arguments are provided, they are concatenated using the `concat` builtin before evaluation.

4. **Script evaluation**: The resulting script (either the single argument or the concatenated result) is passed to `feather_script_eval_obj` for recursive evaluation.

5. **Result handling**: The interpreter result is cleared before evaluation, and the result of the evaluated script (or any error) is returned.

## TCL Features We Support

- **Basic evaluation**: Evaluating a single script argument
- **Argument concatenation**: Concatenating multiple arguments in the same fashion as `concat` before evaluation
- **Recursive evaluation**: Passing the concatenated string to the interpreter recursively
- **Error propagation**: Returning any error generated by the evaluation
- **Result propagation**: Returning the result of the evaluation

## TCL Features We Do NOT Support

Based on the TCL manual, our implementation appears to be **feature-complete** for the `eval` command itself. The `eval` command in TCL is quite simple - it concatenates arguments and evaluates the result.

However, the TCL manual mentions related features that may or may not be fully supported in feather:

1. **`{*}` expansion syntax**: The manual notes that `{*}$script` is often preferred over `eval` for command prefix invocation patterns. This is a language-level feature, not specific to `eval`.

2. **Related commands**: The manual references `catch`, `error`, `errorCode`, `errorInfo`, `interp`, `namespace`, `subst`, and `uplevel` as related commands. Support for these would affect the full utility of `eval` in complex scripts.

## Notes on Implementation Differences

1. **Concatenation method**: Our implementation explicitly builds a list and calls `feather_builtin_concat`, which matches TCL's documented behavior of concatenating "in the same fashion as the concat command."

2. **Result clearing**: Our implementation explicitly clears the result before evaluation (`ops->interp.set_result(interp, ops->string.intern(interp, "", 0))`). This ensures a clean state before script evaluation.

3. **Return code handling**: We return `TCL_OK` or `TCL_ERROR` based on the result of `feather_script_eval_obj`. TCL also supports other return codes (`TCL_RETURN`, `TCL_BREAK`, `TCL_CONTINUE`) which may or may not be handled by our script evaluation infrastructure.

4. **Script object handling**: We use `feather_script_eval_obj` which takes an object directly. This is an implementation detail that differs from how the TCL manual describes "passing the concatenated string" - we work with objects throughout rather than converting to/from strings unnecessarily.
